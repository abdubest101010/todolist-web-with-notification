/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-telegram-bot-api";
exports.ids = ["vendor-chunks/node-telegram-bot-api"];
exports.modules = {

/***/ "(rsc)/./node_modules/node-telegram-bot-api/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * If running on Nodejs 5.x and below, we load the transpiled code.\n * Otherwise, we use the ES6 code.\n * We are deprecating support for Node.js v5.x and below.\n */\nconst majorVersion = parseInt(process.versions.node.split('.')[0], 10);\nif (majorVersion <= 5) {\n  const deprecate = (__webpack_require__(/*! ./src/utils */ \"(rsc)/./node_modules/node-telegram-bot-api/src/utils.js\").deprecate);\n  deprecate('Node.js v5.x and below will no longer be supported in the future');\n  module.exports = __webpack_require__(/*! ./lib/telegram */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/telegram.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./src/telegram */ \"(rsc)/./node_modules/node-telegram-bot-api/src/telegram.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZHQUFnQztBQUNwRDtBQUNBLEVBQUUsd0hBQTBDO0FBQzVDLEVBQUU7QUFDRixFQUFFLHdIQUEwQztBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG9saXN0LXdlYi8uL25vZGVfbW9kdWxlcy9ub2RlLXRlbGVncmFtLWJvdC1hcGkvaW5kZXguanM/YmJkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIElmIHJ1bm5pbmcgb24gTm9kZWpzIDUueCBhbmQgYmVsb3csIHdlIGxvYWQgdGhlIHRyYW5zcGlsZWQgY29kZS5cbiAqIE90aGVyd2lzZSwgd2UgdXNlIHRoZSBFUzYgY29kZS5cbiAqIFdlIGFyZSBkZXByZWNhdGluZyBzdXBwb3J0IGZvciBOb2RlLmpzIHY1LnggYW5kIGJlbG93LlxuICovXG5jb25zdCBtYWpvclZlcnNpb24gPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKVswXSwgMTApO1xuaWYgKG1ham9yVmVyc2lvbiA8PSA1KSB7XG4gIGNvbnN0IGRlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vc3JjL3V0aWxzJykuZGVwcmVjYXRlO1xuICBkZXByZWNhdGUoJ05vZGUuanMgdjUueCBhbmQgYmVsb3cgd2lsbCBubyBsb25nZXIgYmUgc3VwcG9ydGVkIGluIHRoZSBmdXR1cmUnKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi90ZWxlZ3JhbScpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy90ZWxlZ3JhbScpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/lib/errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/lib/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nexports.BaseError = function (_Error) {\n  _inherits(BaseError, _Error);\n\n  /**\n   * @class BaseError\n   * @constructor\n   * @private\n   * @param  {String} code Error code\n   * @param  {String} message Error message\n   */\n  function BaseError(code, message) {\n    _classCallCheck(this, BaseError);\n\n    var _this = _possibleConstructorReturn(this, (BaseError.__proto__ || Object.getPrototypeOf(BaseError)).call(this, code + ': ' + message));\n\n    _this.code = code;\n    return _this;\n  }\n\n  _createClass(BaseError, [{\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        code: this.code,\n        message: this.message\n      };\n    }\n  }]);\n\n  return BaseError;\n}(Error);\n\nexports.FatalError = function (_exports$BaseError) {\n  _inherits(FatalError, _exports$BaseError);\n\n  /**\n   * Fatal Error. Error code is `\"EFATAL\"`.\n   * @class FatalError\n   * @constructor\n   * @param  {String|Error} data Error object or message\n   */\n  function FatalError(data) {\n    _classCallCheck(this, FatalError);\n\n    var error = typeof data === 'string' ? null : data;\n    var message = error ? error.message : data;\n\n    var _this2 = _possibleConstructorReturn(this, (FatalError.__proto__ || Object.getPrototypeOf(FatalError)).call(this, 'EFATAL', message));\n\n    if (error) _this2.stack = error.stack;\n    return _this2;\n  }\n\n  return FatalError;\n}(exports.BaseError);\n\nexports.ParseError = function (_exports$BaseError2) {\n  _inherits(ParseError, _exports$BaseError2);\n\n  /**\n   * Error during parsing. Error code is `\"EPARSE\"`.\n   * @class ParseError\n   * @constructor\n   * @param  {String} message Error message\n   * @param  {http.IncomingMessage} response Server response\n   */\n  function ParseError(message, response) {\n    _classCallCheck(this, ParseError);\n\n    var _this3 = _possibleConstructorReturn(this, (ParseError.__proto__ || Object.getPrototypeOf(ParseError)).call(this, 'EPARSE', message));\n\n    _this3.response = response;\n    return _this3;\n  }\n\n  return ParseError;\n}(exports.BaseError);\n\nexports.TelegramError = function (_exports$BaseError3) {\n  _inherits(TelegramError, _exports$BaseError3);\n\n  /**\n   * Error returned from Telegram. Error code is `\"ETELEGRAM\"`.\n   * @class TelegramError\n   * @constructor\n   * @param  {String} message Error message\n   * @param  {http.IncomingMessage} response Server response\n   */\n  function TelegramError(message, response) {\n    _classCallCheck(this, TelegramError);\n\n    var _this4 = _possibleConstructorReturn(this, (TelegramError.__proto__ || Object.getPrototypeOf(TelegramError)).call(this, 'ETELEGRAM', message));\n\n    _this4.response = response;\n    return _this4;\n  }\n\n  return TelegramError;\n}(exports.BaseError);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixrREFBa0QsMENBQTBDOztBQUU1RixrREFBa0QsYUFBYSx5RkFBeUY7O0FBRXhKLDJDQUEyQywrREFBK0QsdUdBQXVHLHlFQUF5RSxlQUFlLDBFQUEwRSxHQUFHOztBQUV0WCxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvbGlzdC13ZWIvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi9lcnJvcnMuanM/OWY4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZXhwb3J0cy5CYXNlRXJyb3IgPSBmdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhCYXNlRXJyb3IsIF9FcnJvcik7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBCYXNlRXJyb3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gY29kZSBFcnJvciBjb2RlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gICAqL1xuICBmdW5jdGlvbiBCYXNlRXJyb3IoY29kZSwgbWVzc2FnZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlRXJyb3IpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJhc2VFcnJvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJhc2VFcnJvcikpLmNhbGwodGhpcywgY29kZSArICc6ICcgKyBtZXNzYWdlKSk7XG5cbiAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZUVycm9yLCBbe1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlRXJyb3I7XG59KEVycm9yKTtcblxuZXhwb3J0cy5GYXRhbEVycm9yID0gZnVuY3Rpb24gKF9leHBvcnRzJEJhc2VFcnJvcikge1xuICBfaW5oZXJpdHMoRmF0YWxFcnJvciwgX2V4cG9ydHMkQmFzZUVycm9yKTtcblxuICAvKipcbiAgICogRmF0YWwgRXJyb3IuIEVycm9yIGNvZGUgaXMgYFwiRUZBVEFMXCJgLlxuICAgKiBAY2xhc3MgRmF0YWxFcnJvclxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7U3RyaW5nfEVycm9yfSBkYXRhIEVycm9yIG9iamVjdCBvciBtZXNzYWdlXG4gICAqL1xuICBmdW5jdGlvbiBGYXRhbEVycm9yKGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmF0YWxFcnJvcik7XG5cbiAgICB2YXIgZXJyb3IgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBudWxsIDogZGF0YTtcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yID8gZXJyb3IubWVzc2FnZSA6IGRhdGE7XG5cbiAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZhdGFsRXJyb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGYXRhbEVycm9yKSkuY2FsbCh0aGlzLCAnRUZBVEFMJywgbWVzc2FnZSkpO1xuXG4gICAgaWYgKGVycm9yKSBfdGhpczIuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgcmV0dXJuIEZhdGFsRXJyb3I7XG59KGV4cG9ydHMuQmFzZUVycm9yKTtcblxuZXhwb3J0cy5QYXJzZUVycm9yID0gZnVuY3Rpb24gKF9leHBvcnRzJEJhc2VFcnJvcjIpIHtcbiAgX2luaGVyaXRzKFBhcnNlRXJyb3IsIF9leHBvcnRzJEJhc2VFcnJvcjIpO1xuXG4gIC8qKlxuICAgKiBFcnJvciBkdXJpbmcgcGFyc2luZy4gRXJyb3IgY29kZSBpcyBgXCJFUEFSU0VcImAuXG4gICAqIEBjbGFzcyBQYXJzZUVycm9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0gIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVzcG9uc2UgU2VydmVyIHJlc3BvbnNlXG4gICAqL1xuICBmdW5jdGlvbiBQYXJzZUVycm9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnNlRXJyb3IpO1xuXG4gICAgdmFyIF90aGlzMyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQYXJzZUVycm9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGFyc2VFcnJvcikpLmNhbGwodGhpcywgJ0VQQVJTRScsIG1lc3NhZ2UpKTtcblxuICAgIF90aGlzMy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICByZXR1cm4gUGFyc2VFcnJvcjtcbn0oZXhwb3J0cy5CYXNlRXJyb3IpO1xuXG5leHBvcnRzLlRlbGVncmFtRXJyb3IgPSBmdW5jdGlvbiAoX2V4cG9ydHMkQmFzZUVycm9yMykge1xuICBfaW5oZXJpdHMoVGVsZWdyYW1FcnJvciwgX2V4cG9ydHMkQmFzZUVycm9yMyk7XG5cbiAgLyoqXG4gICAqIEVycm9yIHJldHVybmVkIGZyb20gVGVsZWdyYW0uIEVycm9yIGNvZGUgaXMgYFwiRVRFTEVHUkFNXCJgLlxuICAgKiBAY2xhc3MgVGVsZWdyYW1FcnJvclxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7U3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtICB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlc3BvbnNlIFNlcnZlciByZXNwb25zZVxuICAgKi9cbiAgZnVuY3Rpb24gVGVsZWdyYW1FcnJvcihtZXNzYWdlLCByZXNwb25zZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZWxlZ3JhbUVycm9yKTtcblxuICAgIHZhciBfdGhpczQgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGVsZWdyYW1FcnJvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRlbGVncmFtRXJyb3IpKS5jYWxsKHRoaXMsICdFVEVMRUdSQU0nLCBtZXNzYWdlKSk7XG5cbiAgICBfdGhpczQucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICByZXR1cm4gX3RoaXM0O1xuICB9XG5cbiAgcmV0dXJuIFRlbGVncmFtRXJyb3I7XG59KGV4cG9ydHMuQmFzZUVycm9yKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/lib/telegram.js":
/*!************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/lib/telegram.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// shims\n(__webpack_require__(/*! array.prototype.findindex */ \"(rsc)/./node_modules/array.prototype.findindex/index.js\").shim)(); // for Node.js v0.x\n\nvar errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/errors.js\");\nvar TelegramBotWebHook = __webpack_require__(/*! ./telegramWebHook */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/telegramWebHook.js\");\nvar TelegramBotPolling = __webpack_require__(/*! ./telegramPolling */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/telegramPolling.js\");\nvar debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"(rsc)/./node_modules/eventemitter3/index.js\");\nvar fileType = __webpack_require__(/*! file-type */ \"(rsc)/./node_modules/file-type/index.js\");\nvar request = __webpack_require__(/*! @cypress/request-promise */ \"(rsc)/./node_modules/@cypress/request-promise/lib/rp.js\");\nvar streamedRequest = __webpack_require__(/*! @cypress/request */ \"(rsc)/./node_modules/@cypress/request/index.js\");\nvar qs = __webpack_require__(/*! querystring */ \"querystring\");\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar mime = __webpack_require__(/*! mime */ \"(rsc)/./node_modules/mime/mime.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar URL = __webpack_require__(/*! url */ \"url\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar pump = __webpack_require__(/*! pump */ \"(rsc)/./node_modules/pump/index.js\");\nvar deprecate = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/utils.js\").deprecate);\n\nvar _messageTypes = ['text', 'animation', 'audio', 'channel_chat_created', 'contact', 'delete_chat_photo', 'dice', 'document', 'game', 'group_chat_created', 'invoice', 'left_chat_member', 'location', 'migrate_from_chat_id', 'migrate_to_chat_id', 'new_chat_members', 'new_chat_photo', 'new_chat_title', 'passport_data', 'photo', 'pinned_message', 'poll', 'sticker', 'successful_payment', 'supergroup_chat_created', 'video', 'video_note', 'voice', 'video_chat_started', 'video_chat_ended', 'video_chat_participants_invited', 'video_chat_scheduled', 'message_auto_delete_timer_changed', 'chat_invite_link', 'chat_member_updated', 'web_app_data', 'message_reaction'];\n\nvar _deprecatedMessageTypes = ['new_chat_participant', 'left_chat_participant'];\n\n/**\n * JSON-serialize data. If the provided data is already a String,\n * return it as is.\n * @private\n * @param  {*} data\n * @return {String}\n */\nfunction stringify(data) {\n  if (typeof data === 'string') {\n    return data;\n  }\n  return JSON.stringify(data);\n}\n\nvar TelegramBot = function (_EventEmitter) {\n  _inherits(TelegramBot, _EventEmitter);\n\n  _createClass(TelegramBot, [{\n    key: 'on',\n\n\n    /**\n     * Add listener for the specified [event](https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events).\n     * This is the usual `emitter.on()` method.\n     * @param  {String} event\n     * @param  {Function} listener\n     * @see {@link https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events|Available events}\n     * @see https://nodejs.org/api/events.html#events_emitter_on_eventname_listener\n     */\n    value: function on(event, listener) {\n      if (_deprecatedMessageTypes.indexOf(event) !== -1) {\n        var url = 'https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events';\n        deprecate('Events ' + _deprecatedMessageTypes.join(',') + ' are deprecated. See the updated list of events: ' + url);\n      }\n      _get(TelegramBot.prototype.__proto__ || Object.getPrototypeOf(TelegramBot.prototype), 'on', this).call(this, event, listener);\n    }\n\n    /**\n     * Both request method to obtain messages are implemented. To use standard polling, set `polling: true`\n     * on `options`. Notice that [webHook](https://core.telegram.org/bots/api#setwebhook) will need a SSL certificate.\n     * Emits `message` when a message arrives.\n     *\n     * @class TelegramBot\n     * @constructor\n     * @param {String} token Bot Token\n     * @param {Object} [options]\n     * @param {Boolean|Object} [options.polling=false] Set true to enable polling or set options.\n     *  If a WebHook has been set, it will be deleted automatically.\n     * @param {String|Number} [options.polling.timeout=10] *Deprecated. Use `options.polling.params` instead*.\n     *  Timeout in seconds for long polling.\n     * @param {Boolean} [options.testEnvironment=false] Set true to  work with test enviroment.\n     * When working with the test environment, you may use HTTP links without TLS to test your Web App.\n     * @param {String|Number} [options.polling.interval=300] Interval between requests in miliseconds\n     * @param {Boolean} [options.polling.autoStart=true] Start polling immediately\n     * @param {Object} [options.polling.params] Parameters to be used in polling API requests.\n     *  See https://core.telegram.org/bots/api#getupdates for more information.\n     * @param  {Number} [options.polling.params.timeout=10] Timeout in seconds for long polling.\n     * @param {Boolean|Object} [options.webHook=false] Set true to enable WebHook or set options\n     * @param {String} [options.webHook.host=\"0.0.0.0\"] Host to bind to\n     * @param {Number} [options.webHook.port=8443] Port to bind to\n     * @param {String} [options.webHook.key] Path to file with PEM private key for webHook server.\n     *  The file is read **synchronously**!\n     * @param {String} [options.webHook.cert] Path to file with PEM certificate (public) for webHook server.\n     *  The file is read **synchronously**!\n     * @param {String} [options.webHook.pfx] Path to file with PFX private key and certificate chain for webHook server.\n     *  The file is read **synchronously**!\n     * @param {Boolean} [options.webHook.autoOpen=true] Open webHook immediately\n     * @param {Object} [options.webHook.https] Options to be passed to `https.createServer()`.\n     *  Note that `options.webHook.key`, `options.webHook.cert` and `options.webHook.pfx`, if provided, will be\n     *  used to override `key`, `cert` and `pfx` in this object, respectively.\n     *  See https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener for more information.\n     * @param {String} [options.webHook.healthEndpoint=\"/healthz\"] An endpoint for health checks that always responds with 200 OK\n     * @param {Boolean} [options.onlyFirstMatch=false] Set to true to stop after first match. Otherwise, all regexps are executed\n     * @param {Object} [options.request] Options which will be added for all requests to telegram api.\n     *  See https://github.com/request/request#requestoptions-callback for more information.\n     * @param {String} [options.baseApiUrl=\"https://api.telegram.org\"] API Base URl; useful for proxying and testing\n     * @param {Boolean} [options.filepath=true] Allow passing file-paths as arguments when sending files,\n     *  such as photos using `TelegramBot#sendPhoto()`. See [usage information][usage-sending-files-performance]\n     *  for more information on this option and its consequences.\n     * @param {Boolean} [options.badRejection=false] Set to `true`\n     *  **if and only if** the Node.js version you're using terminates the\n     *  process on unhandled rejections. This option is only for\n     *  *forward-compatibility purposes*.\n     * @see https://core.telegram.org/bots/api\n     */\n\n  }], [{\n    key: 'errors',\n\n    /**\n     * The different errors the library uses.\n     * @type {Object}\n     */\n    get: function get() {\n      return errors;\n    }\n\n    /**\n     * The types of message updates the library handles.\n     * @type {String[]}\n     */\n\n  }, {\n    key: 'messageTypes',\n    get: function get() {\n      return _messageTypes;\n    }\n  }]);\n\n  function TelegramBot(token) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TelegramBot);\n\n    var _this = _possibleConstructorReturn(this, (TelegramBot.__proto__ || Object.getPrototypeOf(TelegramBot)).call(this));\n\n    _this.token = token;\n    _this.options = options;\n    _this.options.polling = typeof options.polling === 'undefined' ? false : options.polling;\n    _this.options.webHook = typeof options.webHook === 'undefined' ? false : options.webHook;\n    _this.options.baseApiUrl = options.baseApiUrl || 'https://api.telegram.org';\n    _this.options.filepath = typeof options.filepath === 'undefined' ? true : options.filepath;\n    _this.options.badRejection = typeof options.badRejection === 'undefined' ? false : options.badRejection;\n    _this._textRegexpCallbacks = [];\n    _this._replyListenerId = 0;\n    _this._replyListeners = [];\n    _this._polling = null;\n    _this._webHook = null;\n\n    if (options.polling) {\n      var autoStart = options.polling.autoStart;\n      if (typeof autoStart === 'undefined' || autoStart === true) {\n        _this.startPolling();\n      }\n    }\n\n    if (options.webHook) {\n      var autoOpen = options.webHook.autoOpen;\n      if (typeof autoOpen === 'undefined' || autoOpen === true) {\n        _this.openWebHook();\n      }\n    }\n    return _this;\n  }\n\n  /**\n   * Generates url with bot token and provided path/method you want to be got/executed by bot\n   * @param  {String} path\n   * @return {String} url\n   * @private\n   * @see https://core.telegram.org/bots/api#making-requests\n   */\n\n\n  _createClass(TelegramBot, [{\n    key: '_buildURL',\n    value: function _buildURL(_path) {\n      return this.options.baseApiUrl + '/bot' + this.token + (this.options.testEnvironment ? '/test' : '') + '/' + _path;\n    }\n\n    /**\n     * Fix 'reply_markup' parameter by making it JSON-serialized, as\n     * required by the Telegram Bot API\n     * @param {Object} obj Object; either 'form' or 'qs'\n     * @private\n     * @see https://core.telegram.org/bots/api#sendmessage\n     */\n\n  }, {\n    key: '_fixReplyMarkup',\n    value: function _fixReplyMarkup(obj) {\n      var replyMarkup = obj.reply_markup;\n      if (replyMarkup && typeof replyMarkup !== 'string') {\n        obj.reply_markup = stringify(replyMarkup);\n      }\n    }\n\n    /**\n     * Fix 'entities' or 'caption_entities' or 'explanation_entities' parameter by making it JSON-serialized, as\n     * required by the Telegram Bot API\n     * @param {Object} obj Object;\n     * @private\n     * @see https://core.telegram.org/bots/api#sendmessage\n     * @see https://core.telegram.org/bots/api#copymessage\n     * @see https://core.telegram.org/bots/api#sendpoll\n     */\n\n  }, {\n    key: '_fixEntitiesField',\n    value: function _fixEntitiesField(obj) {\n      var entities = obj.entities;\n      var captionEntities = obj.caption_entities;\n      var explanationEntities = obj.explanation_entities;\n      if (entities && typeof entities !== 'string') {\n        obj.entities = stringify(entities);\n      }\n\n      if (captionEntities && typeof captionEntities !== 'string') {\n        obj.caption_entities = stringify(captionEntities);\n      }\n\n      if (explanationEntities && typeof explanationEntities !== 'string') {\n        obj.explanation_entities = stringify(explanationEntities);\n      }\n    }\n  }, {\n    key: '_fixAddFileThumbnail',\n    value: function _fixAddFileThumbnail(options, opts) {\n      if (options.thumb) {\n        if (opts.formData === null) {\n          opts.formData = {};\n        }\n\n        var attachName = 'photo';\n\n        var _formatSendData2 = this._formatSendData(attachName, options.thumb.replace('attach://', '')),\n            _formatSendData3 = _slicedToArray(_formatSendData2, 1),\n            formData = _formatSendData3[0];\n\n        if (formData) {\n          opts.formData[attachName] = formData[attachName];\n          opts.qs.thumbnail = 'attach://' + attachName;\n        }\n      }\n    }\n\n    /**\n     * Fix 'reply_parameters' parameter by making it JSON-serialized, as\n     * required by the Telegram Bot API\n     * @param {Object} obj Object; either 'form' or 'qs'\n     * @private\n     * @see https://core.telegram.org/bots/api#sendmessage\n     */\n\n  }, {\n    key: '_fixReplyParameters',\n    value: function _fixReplyParameters(obj) {\n      if (obj.hasOwnProperty('reply_parameters') && typeof obj.reply_parameters !== 'string') {\n        obj.reply_parameters = stringify(obj.reply_parameters);\n      }\n    }\n\n    /**\n     * Make request against the API\n     * @param  {String} _path API endpoint\n     * @param  {Object} [options]\n     * @private\n     * @return {Promise}\n     */\n\n  }, {\n    key: '_request',\n    value: function _request(_path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!this.token) {\n        return Promise.reject(new errors.FatalError('Telegram Bot Token not provided!'));\n      }\n\n      if (this.options.request) {\n        Object.assign(options, this.options.request);\n      }\n\n      if (options.form) {\n        this._fixReplyMarkup(options.form);\n        this._fixEntitiesField(options.form);\n        this._fixReplyParameters(options.form);\n      }\n      if (options.qs) {\n        this._fixReplyMarkup(options.qs);\n        this._fixReplyParameters(options.qs);\n      }\n\n      options.method = 'POST';\n      options.url = this._buildURL(_path);\n      options.simple = false;\n      options.resolveWithFullResponse = true;\n      options.forever = true;\n      debug('HTTP request: %j', options);\n      return request(options).then(function (resp) {\n        var data = void 0;\n        try {\n          data = resp.body = JSON.parse(resp.body);\n        } catch (err) {\n          throw new errors.ParseError('Error parsing response: ' + resp.body, resp);\n        }\n\n        if (data.ok) {\n          return data.result;\n        }\n\n        throw new errors.TelegramError(data.error_code + ' ' + data.description, resp);\n      }).catch(function (error) {\n        // TODO: why can't we do `error instanceof errors.BaseError`?\n        if (error.response) throw error;\n        throw new errors.FatalError(error);\n      });\n    }\n\n    /**\n     * Format data to be uploaded; handles file paths, streams and buffers\n     * @param  {String} type\n     * @param  {String|stream.Stream|Buffer} data\n     * @param  {Object} fileOptions File options\n     * @param  {String} [fileOptions.filename] File name\n     * @param  {String} [fileOptions.contentType] Content type (i.e. MIME)\n     * @return {Array} formatted\n     * @return {Object} formatted[0] formData\n     * @return {String} formatted[1] fileId\n     * @throws Error if Buffer file type is not supported.\n     * @see https://npmjs.com/package/file-type\n     * @private\n     */\n\n  }, {\n    key: '_formatSendData',\n    value: function _formatSendData(type, data) {\n      var fileOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var deprecationMessage = 'See https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files' + ' for more information on how sending files has been improved and' + ' on how to disable this deprecation message altogether.';\n      var filedata = data;\n      var filename = fileOptions.filename;\n      var contentType = fileOptions.contentType;\n\n      if (data instanceof stream.Stream) {\n        if (!filename && data.path) {\n          // Will be 'null' if could not be parsed.\n          // For example, 'data.path' === '/?id=123' from 'request(\"https://example.com/?id=123\")'\n          var url = URL.parse(path.basename(data.path.toString()));\n          if (url.pathname) {\n            filename = qs.unescape(url.pathname);\n          }\n        }\n      } else if (Buffer.isBuffer(data)) {\n        if (!filename && !process.env.NTBA_FIX_350) {\n          deprecate('Buffers will have their filenames default to \"filename\" instead of \"data\". ' + deprecationMessage);\n          filename = 'data';\n        }\n        if (!contentType) {\n          var filetype = fileType(data);\n          if (filetype) {\n            contentType = filetype.mime;\n            var ext = filetype.ext;\n            if (ext && !process.env.NTBA_FIX_350) {\n              filename = filename + '.' + ext;\n            }\n          } else if (!process.env.NTBA_FIX_350) {\n            deprecate('An error will no longer be thrown if file-type of buffer could not be detected. ' + deprecationMessage);\n            throw new errors.FatalError('Unsupported Buffer file-type');\n          }\n        }\n      } else if (data) {\n        if (this.options.filepath && fs.existsSync(data)) {\n          filedata = fs.createReadStream(data);\n          if (!filename) {\n            filename = path.basename(data);\n          }\n        } else {\n          return [null, data];\n        }\n      } else {\n        return [null, data];\n      }\n\n      filename = filename || 'filename';\n      contentType = contentType || mime.lookup(filename);\n      if (process.env.NTBA_FIX_350) {\n        contentType = contentType || 'application/octet-stream';\n      } else {\n        deprecate('In the future, content-type of files you send will default to \"application/octet-stream\". ' + deprecationMessage);\n      }\n\n      // TODO: Add missing file extension.\n\n      return [_defineProperty({}, type, {\n        value: filedata,\n        options: {\n          filename: filename,\n          contentType: contentType\n        }\n      }), null];\n    }\n\n    /**\n     * Start polling.\n     * Rejects returned promise if a WebHook is being used by this instance.\n     * @param  {Object} [options]\n     * @param  {Boolean} [options.restart=true] Consecutive calls to this method causes polling to be restarted\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'startPolling',\n    value: function startPolling() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.hasOpenWebHook()) {\n        return Promise.reject(new errors.FatalError('Polling and WebHook are mutually exclusive'));\n      }\n      options.restart = typeof options.restart === 'undefined' ? true : options.restart;\n      if (!this._polling) {\n        this._polling = new TelegramBotPolling(this);\n      }\n      return this._polling.start(options);\n    }\n\n    /**\n     * Alias of `TelegramBot#startPolling()`. This is **deprecated**.\n     * @param  {Object} [options]\n     * @return {Promise}\n     * @deprecated\n     */\n\n  }, {\n    key: 'initPolling',\n    value: function initPolling() {\n      deprecate('TelegramBot#initPolling() is deprecated. Use TelegramBot#startPolling() instead.');\n      return this.startPolling();\n    }\n\n    /**\n     * Stops polling after the last polling request resolves.\n     * Multiple invocations do nothing if polling is already stopped.\n     * Returning the promise of the last polling request is **deprecated**.\n     * @param  {Object} [options] Options\n     * @param  {Boolean} [options.cancel] Cancel current request\n     * @param  {String} [options.reason] Reason for stopping polling\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'stopPolling',\n    value: function stopPolling(options) {\n      if (!this._polling) {\n        return Promise.resolve();\n      }\n      return this._polling.stop(options);\n    }\n\n    /**\n     * Get link for file.\n     * Use this method to get link for file for subsequent use.\n     * Attention: link will be valid for 1 hour.\n     *\n     * This method is a sugar extension of the (getFile)[#getfilefileid] method,\n     * which returns just path to file on remote server (you will have to manually build full uri after that).\n     *\n     * @param  {String} fileId  File identifier to get info about\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Promise which will have  *fileURI* in resolve callback\n     * @see https://core.telegram.org/bots/api#getfile\n     */\n\n  }, {\n    key: 'getFileLink',\n    value: function getFileLink(fileId) {\n      var _this2 = this;\n\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      return this.getFile(fileId, form).then(function (resp) {\n        return _this2.options.baseApiUrl + '/file/bot' + _this2.token + '/' + resp.file_path;\n      });\n    }\n\n    /**\n     * Return a readable stream for file.\n     *\n     * `fileStream.path` is the specified file ID i.e. `fileId`.\n     * `fileStream` emits event `info` passing a single argument i.e.\n     * `info` with the interface `{ uri }` where `uri` is the URI of the\n     * file on Telegram servers.\n     *\n     * This method is a sugar extension of the [getFileLink](#TelegramBot+getFileLink) method,\n     * which returns the full URI to the file on remote server.\n     *\n     * @param  {String} fileId File identifier to get info about\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {stream.Readable} fileStream\n     */\n\n  }, {\n    key: 'getFileStream',\n    value: function getFileStream(fileId) {\n      var _this3 = this;\n\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var fileStream = new stream.PassThrough();\n      fileStream.path = fileId;\n      this.getFileLink(fileId, form).then(function (fileURI) {\n        fileStream.emit('info', {\n          uri: fileURI\n        });\n        pump(streamedRequest(Object.assign({ uri: fileURI }, _this3.options.request)), fileStream);\n      }).catch(function (error) {\n        fileStream.emit('error', error);\n      });\n      return fileStream;\n    }\n\n    /**\n     * Downloads file in the specified folder.\n     *\n     * This method is a sugar extension of the [getFileStream](#TelegramBot+getFileStream) method,\n     * which returns a readable file stream.\n     *\n     * @param  {String} fileId  File identifier to get info about\n     * @param  {String} downloadDir Absolute path to the folder in which file will be saved\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Promise, which will have *filePath* of downloaded file in resolve callback\n     */\n\n  }, {\n    key: 'downloadFile',\n    value: function downloadFile(fileId, downloadDir) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var resolve = void 0;\n      var reject = void 0;\n      var promise = new Promise(function (a, b) {\n        resolve = a;\n        reject = b;\n      });\n      var fileStream = this.getFileStream(fileId, form);\n      fileStream.on('info', function (info) {\n        var fileName = info.uri.slice(info.uri.lastIndexOf('/') + 1);\n        // TODO: Ensure fileName doesn't contains slashes\n        var filePath = path.join(downloadDir, fileName);\n        pump(fileStream, fs.createWriteStream(filePath), function (error) {\n          if (error) {\n            return reject(error);\n          }\n          return resolve(filePath);\n        });\n      });\n      fileStream.on('error', function (err) {\n        reject(err);\n      });\n      return promise;\n    }\n\n    /**\n     * Register a RegExp to test against an incomming text message.\n     * @param  {RegExp}   regexpRexecuted with `exec`.\n     * @param  {Function} callback     Callback will be called with 2 parameters,\n     * the `msg` and the result of executing `regexp.exec` on message text.\n     */\n\n  }, {\n    key: 'onText',\n    value: function onText(regexp, callback) {\n      this._textRegexpCallbacks.push({ regexp: regexp, callback: callback });\n    }\n\n    /**\n     * Remove a listener registered with `onText()`.\n     * @param  {RegExp} regexp RegExp used previously in `onText()`\n     * @return {Object} deletedListener The removed reply listener if\n     *   found. This object has `regexp` and `callback`\n     *   properties. If not found, returns `null`.\n     */\n\n  }, {\n    key: 'removeTextListener',\n    value: function removeTextListener(regexp) {\n      var index = this._textRegexpCallbacks.findIndex(function (textListener) {\n        return String(textListener.regexp) === String(regexp);\n      });\n      if (index === -1) {\n        return null;\n      }\n      return this._textRegexpCallbacks.splice(index, 1)[0];\n    }\n\n    /**\n     * Remove all listeners registered with `onText()`.\n     */\n\n  }, {\n    key: 'clearTextListeners',\n    value: function clearTextListeners() {\n      this._textRegexpCallbacks = [];\n    }\n\n    /**\n     * Register a reply to wait for a message response.\n     *\n     * @param  {Number|String} chatId The chat id where the message cames from.\n     * @param  {Number|String} messageId The message id to be replied.\n     * @param  {Function} callback Callback will be called with the reply\n     *  message.\n     * @return {Number} id The ID of the inserted reply listener.\n     */\n\n  }, {\n    key: 'onReplyToMessage',\n    value: function onReplyToMessage(chatId, messageId, callback) {\n      var id = ++this._replyListenerId;\n      this._replyListeners.push({\n        id: id,\n        chatId: chatId,\n        messageId: messageId,\n        callback: callback\n      });\n      return id;\n    }\n\n    /**\n     * Removes a reply that has been prev. registered for a message response.\n     * @param   {Number} replyListenerId The ID of the reply listener.\n     * @return  {Object} deletedListener The removed reply listener if\n     *   found. This object has `id`, `chatId`, `messageId` and `callback`\n     *   properties. If not found, returns `null`.\n     */\n\n  }, {\n    key: 'removeReplyListener',\n    value: function removeReplyListener(replyListenerId) {\n      var index = this._replyListeners.findIndex(function (replyListener) {\n        return replyListener.id === replyListenerId;\n      });\n      if (index === -1) {\n        return null;\n      }\n      return this._replyListeners.splice(index, 1)[0];\n    }\n\n    /**\n     * Removes all replies that have been prev. registered for a message response.\n     *\n     * @return  {Array} deletedListeners An array of removed listeners.\n     */\n\n  }, {\n    key: 'clearReplyListeners',\n    value: function clearReplyListeners() {\n      this._replyListeners = [];\n    }\n\n    /**\n     * Return true if polling. Otherwise, false.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isPolling',\n    value: function isPolling() {\n      return this._polling ? this._polling.isPolling() : false;\n    }\n\n    /**\n     * Open webhook.\n     * Multiple invocations do nothing if webhook is already open.\n     * Rejects returned promise if Polling is being used by this instance.\n     *\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'openWebHook',\n    value: function openWebHook() {\n      if (this.isPolling()) {\n        return Promise.reject(new errors.FatalError('WebHook and Polling are mutually exclusive'));\n      }\n      if (!this._webHook) {\n        this._webHook = new TelegramBotWebHook(this);\n      }\n      return this._webHook.open();\n    }\n\n    /**\n     * Close webhook after closing all current connections.\n     * Multiple invocations do nothing if webhook is already closed.\n     *\n     * @return {Promise} Promise\n     */\n\n  }, {\n    key: 'closeWebHook',\n    value: function closeWebHook() {\n      if (!this._webHook) {\n        return Promise.resolve();\n      }\n      return this._webHook.close();\n    }\n\n    /**\n     * Return true if using webhook and it is open i.e. accepts connections.\n     * Otherwise, false.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasOpenWebHook',\n    value: function hasOpenWebHook() {\n      return this._webHook ? this._webHook.isOpen() : false;\n    }\n\n    /**\n     * Process an update; emitting the proper events and executing regexp\n     * callbacks. This method is useful should you be using a different\n     * way to fetch updates, other than those provided by TelegramBot.\n     *\n     * @param  {Object} update\n     * @see https://core.telegram.org/bots/api#update\n     */\n\n  }, {\n    key: 'processUpdate',\n    value: function processUpdate(update) {\n      var _this4 = this;\n\n      debug('Process Update %j', update);\n      var message = update.message;\n      var editedMessage = update.edited_message;\n      var channelPost = update.channel_post;\n      var editedChannelPost = update.edited_channel_post;\n      var businessConnection = update.business_connection;\n      var businesssMessage = update.business_message;\n      var editedBusinessMessage = update.edited_business_message;\n      var deletedBusinessMessage = update.deleted_business_messages;\n      var messageReaction = update.message_reaction;\n      var messageReactionCount = update.message_reaction_count;\n      var inlineQuery = update.inline_query;\n      var chosenInlineResult = update.chosen_inline_result;\n      var callbackQuery = update.callback_query;\n      var shippingQuery = update.shipping_query;\n      var preCheckoutQuery = update.pre_checkout_query;\n      var poll = update.poll;\n      var pollAnswer = update.poll_answer;\n      var myChatMember = update.my_chat_member;\n      var chatMember = update.chat_member;\n      var chatJoinRequest = update.chat_join_request;\n      var chatBoost = update.chat_boost;\n      var removedChatBoost = update.removed_chat_boost;\n\n      if (message) {\n        debug('Process Update message %j', message);\n        var metadata = {};\n        metadata.type = TelegramBot.messageTypes.find(function (messageType) {\n          return message[messageType];\n        });\n        this.emit('message', message, metadata);\n        if (metadata.type) {\n          debug('Emitting %s: %j', metadata.type, message);\n          this.emit(metadata.type, message, metadata);\n        }\n        if (message.text) {\n          debug('Text message');\n          this._textRegexpCallbacks.some(function (reg) {\n            debug('Matching %s with %s', message.text, reg.regexp);\n\n            if (!(reg.regexp instanceof RegExp)) {\n              reg.regexp = new RegExp(reg.regexp);\n            }\n\n            var result = reg.regexp.exec(message.text);\n            if (!result) {\n              return false;\n            }\n            // reset index so we start at the beginning of the regex each time\n            reg.regexp.lastIndex = 0;\n            debug('Matches %s', reg.regexp);\n            reg.callback(message, result);\n            // returning truthy value exits .some\n            return _this4.options.onlyFirstMatch;\n          });\n        }\n        if (message.reply_to_message) {\n          // Only callbacks waiting for this message\n          this._replyListeners.forEach(function (reply) {\n            // Message from the same chat\n            if (reply.chatId === message.chat.id) {\n              // Responding to that message\n              if (reply.messageId === message.reply_to_message.message_id) {\n                // Resolve the promise\n                reply.callback(message);\n              }\n            }\n          });\n        }\n      } else if (editedMessage) {\n        debug('Process Update edited_message %j', editedMessage);\n        this.emit('edited_message', editedMessage);\n        if (editedMessage.text) {\n          this.emit('edited_message_text', editedMessage);\n        }\n        if (editedMessage.caption) {\n          this.emit('edited_message_caption', editedMessage);\n        }\n      } else if (channelPost) {\n        debug('Process Update channel_post %j', channelPost);\n        this.emit('channel_post', channelPost);\n      } else if (editedChannelPost) {\n        debug('Process Update edited_channel_post %j', editedChannelPost);\n        this.emit('edited_channel_post', editedChannelPost);\n        if (editedChannelPost.text) {\n          this.emit('edited_channel_post_text', editedChannelPost);\n        }\n        if (editedChannelPost.caption) {\n          this.emit('edited_channel_post_caption', editedChannelPost);\n        }\n      } else if (businessConnection) {\n        debug('Process Update business_connection %j', businessConnection);\n        this.emit('business_connection', businessConnection);\n      } else if (businesssMessage) {\n        debug('Process Update business_message %j', businesssMessage);\n        this.emit('business_message', businesssMessage);\n      } else if (editedBusinessMessage) {\n        debug('Process Update edited_business_message %j', editedBusinessMessage);\n        this.emit('edited_business_message', editedBusinessMessage);\n      } else if (deletedBusinessMessage) {\n        debug('Process Update deleted_business_messages %j', deletedBusinessMessage);\n        this.emit('deleted_business_messages', deletedBusinessMessage);\n      } else if (messageReaction) {\n        debug('Process Update message_reaction %j', messageReaction);\n        this.emit('message_reaction', messageReaction);\n      } else if (messageReactionCount) {\n        debug('Process Update message_reaction_count %j', messageReactionCount);\n        this.emit('message_reaction_count', messageReactionCount);\n      } else if (inlineQuery) {\n        debug('Process Update inline_query %j', inlineQuery);\n        this.emit('inline_query', inlineQuery);\n      } else if (chosenInlineResult) {\n        debug('Process Update chosen_inline_result %j', chosenInlineResult);\n        this.emit('chosen_inline_result', chosenInlineResult);\n      } else if (callbackQuery) {\n        debug('Process Update callback_query %j', callbackQuery);\n        this.emit('callback_query', callbackQuery);\n      } else if (shippingQuery) {\n        debug('Process Update shipping_query %j', shippingQuery);\n        this.emit('shipping_query', shippingQuery);\n      } else if (preCheckoutQuery) {\n        debug('Process Update pre_checkout_query %j', preCheckoutQuery);\n        this.emit('pre_checkout_query', preCheckoutQuery);\n      } else if (poll) {\n        debug('Process Update poll %j', poll);\n        this.emit('poll', poll);\n      } else if (pollAnswer) {\n        debug('Process Update poll_answer %j', pollAnswer);\n        this.emit('poll_answer', pollAnswer);\n      } else if (chatMember) {\n        debug('Process Update chat_member %j', chatMember);\n        this.emit('chat_member', chatMember);\n      } else if (myChatMember) {\n        debug('Process Update my_chat_member %j', myChatMember);\n        this.emit('my_chat_member', myChatMember);\n      } else if (chatJoinRequest) {\n        debug('Process Update my_chat_member %j', chatJoinRequest);\n        this.emit('chat_join_request', chatJoinRequest);\n      } else if (chatBoost) {\n        debug('Process Update chat_boost %j', chatBoost);\n        this.emit('chat_boost', chatBoost);\n      } else if (removedChatBoost) {\n        debug('Process Update removed_chat_boost %j', removedChatBoost);\n        this.emit('removed_chat_boost', removedChatBoost);\n      }\n    }\n\n    /** Start Telegram Bot API methods */\n\n    /**\n    * Use this method to receive incoming updates using long polling.\n    * This method has an [older, compatible signature][getUpdates-v0.25.0]\n    * that is being deprecated.\n    *\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise}\n    * @see https://core.telegram.org/bots/api#getupdates\n    */\n\n  }, {\n    key: 'getUpdates',\n    value: function getUpdates() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      /* The older method signature was getUpdates(timeout, limit, offset).\n       * We need to ensure backwards-compatibility while maintaining\n       * consistency of the method signatures throughout the library */\n      if ((typeof form === 'undefined' ? 'undefined' : _typeof(form)) !== 'object') {\n        /* eslint-disable no-param-reassign, prefer-rest-params */\n        deprecate('The method signature getUpdates(timeout, limit, offset) has been deprecated since v0.25.0');\n        form = {\n          timeout: arguments[0],\n          limit: arguments[1],\n          offset: arguments[2]\n        };\n        /* eslint-enable no-param-reassign, prefer-rest-params */\n      }\n\n      return this._request('getUpdates', { form: form });\n    }\n\n    /**\n     * Specify an url to receive incoming updates via an outgoing webHook.\n     * This method has an [older, compatible signature][setWebHook-v0.25.0]\n     * that is being deprecated.\n     *\n     * @param  {String} url URL where Telegram will make HTTP Post. Leave empty to\n     * delete webHook.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {String|stream.Stream} [options.certificate] PEM certificate key (public).\n     * @param  {String} [options.secret_token] Optional secret token to be sent in a header `X-Telegram-Bot-Api-Secret-Token` in every webhook request.\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise}\n     * @see https://core.telegram.org/bots/api#setwebhook\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'setWebHook',\n    value: function setWebHook(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var fileOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      /* The older method signature was setWebHook(url, cert).\n       * We need to ensure backwards-compatibility while maintaining\n       * consistency of the method signatures throughout the library */\n      var cert = void 0;\n      // Note: 'options' could be an object, if a stream was provided (in place of 'cert')\n      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' || options instanceof stream.Stream) {\n        deprecate('The method signature setWebHook(url, cert) has been deprecated since v0.25.0');\n        cert = options;\n        options = {}; // eslint-disable-line no-param-reassign\n      } else {\n        cert = options.certificate;\n      }\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.url = url;\n\n      if (cert) {\n        try {\n          var sendData = this._formatSendData('certificate', cert, fileOptions);\n          opts.formData = sendData[0];\n          opts.qs.certificate = sendData[1];\n        } catch (ex) {\n          return Promise.reject(ex);\n        }\n      }\n\n      return this._request('setWebHook', opts);\n    }\n\n    /**\n     * Use this method to remove webhook integration if you decide to\n     * switch back to getUpdates. Returns True on success.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}\n     * @see https://core.telegram.org/bots/api#deletewebhook\n     */\n\n  }, {\n    key: 'deleteWebHook',\n    value: function deleteWebHook() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('deleteWebhook', { form: form });\n    }\n\n    /**\n     * Use this method to get current webhook status.\n     * On success, returns a [WebhookInfo](https://core.telegram.org/bots/api#webhookinfo) object.\n     * If the bot is using getUpdates, will return an object with the\n     * url field empty.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}\n     * @see https://core.telegram.org/bots/api#getwebhookinfo\n     */\n\n  }, {\n    key: 'getWebHookInfo',\n    value: function getWebHookInfo() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getWebhookInfo', { form: form });\n    }\n\n    /**\n     * A simple method for testing your bot's authentication token. Requires no parameters.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} basic information about the bot in form of a [User](https://core.telegram.org/bots/api#user) object.\n     * @see https://core.telegram.org/bots/api#getme\n     */\n\n  }, {\n    key: 'getMe',\n    value: function getMe() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getMe', { form: form });\n    }\n\n    /**\n     * This method log out your bot from the cloud Bot API server before launching the bot locally.\n     * You must log out the bot before running it locally, otherwise there is no guarantee that the bot will receive updates.\n     * After a successful call, you will not be able to log in again using the same token for 10 minutes.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}  True on success\n     * @see https://core.telegram.org/bots/api#logout\n     */\n\n  }, {\n    key: 'logOut',\n    value: function logOut() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('logOut', { form: form });\n    }\n\n    /**\n     * This method close the bot instance before moving it from one local server to another.\n     * This method will return error 429 in the first 10 minutes after the bot is launched.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}  True on success\n     * @see https://core.telegram.org/bots/api#close\n     */\n\n  }, {\n    key: 'close',\n    value: function close() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('close', { form: form });\n    }\n\n    /**\n     * Send text message.\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} text Text of the message to be sent\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendmessage\n     */\n\n  }, {\n    key: 'sendMessage',\n    value: function sendMessage(chatId, text) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.text = text;\n      return this._request('sendMessage', { form: form });\n    }\n\n    /**\n     * Forward messages of any kind.\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * or username of the target channel (in the format `@channelusername`)\n     * @param  {Number|String} fromChatId Unique identifier for the chat where the\n     * original message was sent (or channel username in the format `@channelusername`)\n     * @param  {Number|String} messageId  Unique message identifier in the chat specified in fromChatId\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}\n     * @see https://core.telegram.org/bots/api#forwardmessage\n     */\n\n  }, {\n    key: 'forwardMessage',\n    value: function forwardMessage(chatId, fromChatId, messageId) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.from_chat_id = fromChatId;\n      form.message_id = messageId;\n      return this._request('forwardMessage', { form: form });\n    }\n\n    /**\n     * Use this method to forward multiple messages of any kind.\n     * If some of the specified messages can't be found or forwarded, they are skipped.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * or username of the target channel (in the format `@channelusername`)\n     * @param  {Number|String} fromChatId Unique identifier for the chat where the\n     * original message was sent (or channel username in the format `@channelusername`)\n     * @param  {Array<Number|String>} messageIds Identifiers of 1-100 messages in the chat from_chat_id to forward.\n     * The identifiers must be specified in a strictly increasing order.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} An array of MessageId of the sent messages on success\n     * @see https://core.telegram.org/bots/api#forwardmessages\n     */\n\n  }, {\n    key: 'forwardMessages',\n    value: function forwardMessages(chatId, fromChatId, messageIds) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.from_chat_id = fromChatId;\n      form.message_ids = messageIds;\n      return this._request('forwardMessages', { form: form });\n    }\n\n    /**\n     * Copy messages of any kind. **Service messages and invoice messages can't be copied.**\n     * The method is analogous to the method forwardMessages, but the copied message doesn't\n     * have a link to the original message.\n     * Returns the MessageId of the sent message on success.\n     * @param  {Number|String} chatId     Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number|String} fromChatId Unique identifier for the chat where the\n     * original message was sent\n     * @param  {Number|String} messageId  Unique message identifier\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} The [MessageId](https://core.telegram.org/bots/api#messageid) of the sent message on success\n     * @see https://core.telegram.org/bots/api#copymessage\n     */\n\n  }, {\n    key: 'copyMessage',\n    value: function copyMessage(chatId, fromChatId, messageId) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.from_chat_id = fromChatId;\n      form.message_id = messageId;\n      return this._request('copyMessage', { form: form });\n    }\n\n    /**\n     * Use this method to copy messages of any kind. If some of the specified messages can't be found or copied, they are skipped.\n     * Service messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied.\n     * Returns the MessageId of the sent message on success.\n     * @param  {Number|String} chatId Unique identifier for the target chat\n     * @param  {Number|String} fromChatId Unique identifier for the chat where the\n     * original message was sent\n     * @param  {Array} messageIds  Identifiers of 1-100 messages in the chat from_chat_id to copy.\n     * The identifiers must be specified in a strictly increasing order.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} An array of MessageId of the sent messages\n     * @see https://core.telegram.org/bots/api#copymessages\n     */\n\n  }, {\n    key: 'copyMessages',\n    value: function copyMessages(chatId, fromChatId, messageIds) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.from_chat_id = fromChatId;\n      form.message_ids = stringify(messageIds);\n      return this._request('copyMessages', { form: form });\n    }\n\n    /**\n     * Send photo\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} photo A file path or a Stream. Can\n     * also be a `file_id` previously uploaded\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendphoto\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'sendPhoto',\n    value: function sendPhoto(chatId, photo) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('photo', photo, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.photo = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendPhoto', opts);\n    }\n\n    /**\n    * Send audio\n    *\n    * **Your audio must be in the .MP3 or .M4A format.**\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {String|stream.Stream|Buffer} audio A file path, Stream or Buffer.\n    * Can also be a `file_id` previously uploaded.\n    * @param  {Object} [options] Additional Telegram query options\n    * @param  {Object} [fileOptions] Optional file related meta-data\n    * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n    * @see https://core.telegram.org/bots/api#sendaudio\n    * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n    */\n\n  }, {\n    key: 'sendAudio',\n    value: function sendAudio(chatId, audio) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n\n      opts.qs.chat_id = chatId;\n\n      try {\n        var sendData = this._formatSendData('audio', audio, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.audio = sendData[1];\n        this._fixAddFileThumbnail(options, opts);\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n\n      return this._request('sendAudio', opts);\n    }\n\n    /**\n    * Send Document\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {String|stream.Stream|Buffer} doc A file path, Stream or Buffer.\n    * Can also be a `file_id` previously uploaded.\n    * @param  {Object} [options] Additional Telegram query options\n    * @param  {Object} [fileOptions] Optional file related meta-data\n    * @return {Promise}  On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n    * @see https://core.telegram.org/bots/api#sendDocument\n    * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n    */\n\n  }, {\n    key: 'sendDocument',\n    value: function sendDocument(chatId, doc) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('document', doc, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.document = sendData[1];\n        this._fixAddFileThumbnail(options, opts);\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n\n      return this._request('sendDocument', opts);\n    }\n\n    /**\n     * Use this method to send video files, **Telegram clients support mp4 videos** (other formats may be sent as Document).\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} video A file path or Stream.\n     * Can also be a `file_id` previously uploaded.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendvideo\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'sendVideo',\n    value: function sendVideo(chatId, video) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('video', video, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.video = sendData[1];\n        this._fixAddFileThumbnail(options, opts);\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendVideo', opts);\n    }\n\n    /**\n     * Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound).\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} animation A file path, Stream or Buffer.\n     * Can also be a `file_id` previously uploaded.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendanimation\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'sendAnimation',\n    value: function sendAnimation(chatId, animation) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('animation', animation, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.animation = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendAnimation', opts);\n    }\n\n    /**\n     * Send voice\n     *\n     * **Your audio must be in an .OGG file encoded with OPUS**, or in .MP3 format, or in .M4A format (other formats may be sent as Audio or Document)\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} voice A file path, Stream or Buffer.\n     * Can also be a `file_id` previously uploaded.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendvoice\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'sendVoice',\n    value: function sendVoice(chatId, voice) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('voice', voice, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.voice = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendVoice', opts);\n    }\n\n    /**\n     * Use this method to send video messages\n     * Telegram clients support **rounded square MPEG4 videos** of up to 1 minute long.\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} videoNote A file path or Stream.\n     * Can also be a `file_id` previously uploaded.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @info The length parameter is actually optional. However, the API (at time of writing) requires you to always provide it until it is fixed.\n     * @see https://core.telegram.org/bots/api#sendvideonote\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n    */\n\n  }, {\n    key: 'sendVideoNote',\n    value: function sendVideoNote(chatId, videoNote) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('video_note', videoNote, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.video_note = sendData[1];\n        this._fixAddFileThumbnail(options, opts);\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendVideoNote', opts);\n    }\n\n    /**\n     * Use this method to send a group of photos or videos as an album.\n     *\n     * **Documents and audio files can be only grouped in an album with messages of the same type**\n     *\n     * If you wish to [specify file options](https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files),\n     * add a `fileOptions` property to the target input in `media`.\n     *\n     * @param  {String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Array} media A JSON-serialized array describing photos and videos to be sent, must include 2–10 items\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, an array of the sent [Messages](https://core.telegram.org/bots/api#message)\n     * is returned.\n     * @see https://core.telegram.org/bots/api#sendmediagroup\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'sendMediaGroup',\n    value: function sendMediaGroup(chatId, media) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n\n      opts.formData = {};\n      var inputMedia = [];\n      var index = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = media[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var input = _step.value;\n\n          var payload = Object.assign({}, input);\n          delete payload.media;\n          delete payload.fileOptions;\n          try {\n            var attachName = String(index);\n\n            var _formatSendData4 = this._formatSendData(attachName, input.media, input.fileOptions),\n                _formatSendData5 = _slicedToArray(_formatSendData4, 2),\n                formData = _formatSendData5[0],\n                fileId = _formatSendData5[1];\n\n            if (formData) {\n              opts.formData[attachName] = formData[attachName];\n              payload.media = 'attach://' + attachName;\n            } else {\n              payload.media = fileId;\n            }\n          } catch (ex) {\n            return Promise.reject(ex);\n          }\n          inputMedia.push(payload);\n          index++;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      opts.qs.media = stringify(inputMedia);\n\n      return this._request('sendMediaGroup', opts);\n    }\n\n    /**\n     * Send location.\n     * Use this method to send point on the map.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Float} latitude Latitude of location\n     * @param  {Float} longitude Longitude of location\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendlocation\n     */\n\n  }, {\n    key: 'sendLocation',\n    value: function sendLocation(chatId, latitude, longitude) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.latitude = latitude;\n      form.longitude = longitude;\n      return this._request('sendLocation', { form: form });\n    }\n\n    /**\n     * Use this method to edit live location messages sent by\n     * the bot or via the bot (for inline bots).\n     *\n     *  A location **can be edited until its live_period expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.telegram.org/bots/api#stopmessagelivelocation)**\n     *\n     * Note that you must provide one of chat_id, message_id, or\n     * inline_message_id in your request.\n     *\n     * @param  {Float} latitude Latitude of location\n     * @param  {Float} longitude Longitude of location\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned.\n     * @see https://core.telegram.org/bots/api#editmessagelivelocation\n     */\n\n  }, {\n    key: 'editMessageLiveLocation',\n    value: function editMessageLiveLocation(latitude, longitude) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.latitude = latitude;\n      form.longitude = longitude;\n      return this._request('editMessageLiveLocation', { form: form });\n    }\n\n    /**\n     * Use this method to stop updating a live location message sent by\n     * the bot or via the bot (for inline bots) before live_period expires.\n     *\n     * Note that you must provide one of chat_id, message_id, or\n     * inline_message_id in your request.\n     *\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned.\n     * @see https://core.telegram.org/bots/api#stopmessagelivelocation\n     */\n\n  }, {\n    key: 'stopMessageLiveLocation',\n    value: function stopMessageLiveLocation() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('stopMessageLiveLocation', { form: form });\n    }\n\n    /**\n     * Send venue.\n     * Use this method to send information about a venue.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Float} latitude Latitude of location\n     * @param  {Float} longitude Longitude of location\n     * @param  {String} title Name of the venue\n     * @param  {String} address Address of the venue\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned.\n     * @see https://core.telegram.org/bots/api#sendvenue\n     */\n\n  }, {\n    key: 'sendVenue',\n    value: function sendVenue(chatId, latitude, longitude, title, address) {\n      var form = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n      form.chat_id = chatId;\n      form.latitude = latitude;\n      form.longitude = longitude;\n      form.title = title;\n      form.address = address;\n      return this._request('sendVenue', { form: form });\n    }\n\n    /**\n     * Send contact.\n     * Use this method to send phone contacts.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} phoneNumber Contact's phone number\n     * @param  {String} firstName Contact's first name\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendcontact\n     */\n\n  }, {\n    key: 'sendContact',\n    value: function sendContact(chatId, phoneNumber, firstName) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.phone_number = phoneNumber;\n      form.first_name = firstName;\n      return this._request('sendContact', { form: form });\n    }\n\n    /**\n     * Send poll.\n     * Use this method to send a native poll.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the group/channel\n     * @param  {String} question Poll question, 1-300 characters\n     * @param  {Array} pollOptions Poll options, between 2-10 options (only 1-100 characters each)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendpoll\n     */\n\n  }, {\n    key: 'sendPoll',\n    value: function sendPoll(chatId, question, pollOptions) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.question = question;\n      form.options = stringify(pollOptions);\n      return this._request('sendPoll', { form: form });\n    }\n\n    /**\n     * Send Dice\n     * Use this method to send an animated emoji that will display a random value.\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}  On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#senddice\n     */\n\n  }, {\n    key: 'sendDice',\n    value: function sendDice(chatId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('dice');\n        opts.formData = sendData[0];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendDice', opts);\n    }\n\n    /**\n     * Send chat action.\n     *\n     * Use this method when you need to tell the user that something is happening on the bot's side.\n     * **The status is set for 5 seconds or less** (when a message arrives from your bot, Telegram clients clear its typing status).\n     *\n     *  Action `typing` for [text messages](https://core.telegram.org/bots/api#sendmessage),\n     * `upload_photo` for [photos](https://core.telegram.org/bots/api#sendphoto), `record_video` or `upload_video` for [videos](https://core.telegram.org/bots/api#sendvideo),\n     * `record_voice` or `upload_voice` for [voice notes](https://core.telegram.org/bots/api#sendvoice), `upload_document` for [general files](https://core.telegram.org/bots/api#senddocument),\n     * `choose_sticker` for [stickers](https://core.telegram.org/bots/api#sendsticker), `find_location` for [location data](https://core.telegram.org/bots/api#sendlocation),\n     * `record_video_note` or `upload_video_note` for [video notes](https://core.telegram.org/bots/api#sendvideonote).\n     *\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} action Type of action to broadcast.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#sendchataction\n     */\n\n  }, {\n    key: 'sendChatAction',\n    value: function sendChatAction(chatId, action) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.action = action;\n      return this._request('sendChatAction', { form: form });\n    }\n\n    /**\n     * Use this method to change the chosen reactions on a message.\n     * - Service messages can't be reacted to.\n     * - Automatically forwarded messages from a channel to its discussion group have the same available reactions as messages in the channel.\n     * - In albums, bots must react to the first message.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n     * @param  {Number} messageId  Unique identifier of the target message\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise<Boolean>} True on success\n     * @see https://core.telegram.org/bots/api#setmessagereaction\n     */\n\n  }, {\n    key: 'setMessageReaction',\n    value: function setMessageReaction(chatId, messageId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_id = messageId;\n      if (form.reaction) {\n        form.reaction = stringify(form.reaction);\n      }\n      return this._request('setMessageReaction', { form: form });\n    }\n\n    /**\n     * Use this method to get a list of profile pictures for a user.\n     * Returns a [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object.\n     * This method has an [older, compatible signature][getUserProfilePhotos-v0.25.0]\n     * that is being deprecated.\n     *\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}  Returns a [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object\n     * @see https://core.telegram.org/bots/api#getuserprofilephotos\n     */\n\n  }, {\n    key: 'getUserProfilePhotos',\n    value: function getUserProfilePhotos(userId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      /* The older method signature was getUserProfilePhotos(userId, offset, limit).\n       * We need to ensure backwards-compatibility while maintaining\n       * consistency of the method signatures throughout the library */\n      if ((typeof form === 'undefined' ? 'undefined' : _typeof(form)) !== 'object') {\n        /* eslint-disable no-param-reassign, prefer-rest-params */\n        deprecate('The method signature getUserProfilePhotos(userId, offset, limit) has been deprecated since v0.25.0');\n        form = {\n          offset: arguments[1],\n          limit: arguments[2]\n        };\n        /* eslint-enable no-param-reassign, prefer-rest-params */\n      }\n      form.user_id = userId;\n      return this._request('getUserProfilePhotos', { form: form });\n    }\n\n    /**\n     * Get file.\n     * Use this method to get basic info about a file and prepare it for downloading.\n     *\n     * Attention: **link will be valid for 1 hour.**\n     *\n     * @param  {String} fileId  File identifier to get info about\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, a [File](https://core.telegram.org/bots/api#file) object is returned\n     * @see https://core.telegram.org/bots/api#getfile\n     */\n\n  }, {\n    key: 'getFile',\n    value: function getFile(fileId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.file_id = fileId;\n      return this._request('getFile', { form: form });\n    }\n\n    /**\n      * Use this method to ban a user in a group, a supergroup or a channel.\n      * In the case of supergroups and channels, the user will not be able to\n      * return to the chat on their own using invite links, etc., unless unbanned first..\n      *\n      * The **bot must be an administrator in the group, supergroup or a channel** for this to work.\n      *\n      *\n      * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n      * @param  {Number} userId  Unique identifier of the target user\n      * @param  {Object} [options] Additional Telegram query options\n      * @return {Promise} True on success.\n      * @see https://core.telegram.org/bots/api#banchatmember\n      */\n\n  }, {\n    key: 'banChatMember',\n    value: function banChatMember(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('banChatMember', { form: form });\n    }\n\n    /**\n    * Use this method to unban a previously kicked user in a supergroup.\n    * The user will not return to the group automatically, but will be\n    * able to join via link, etc.\n    *\n    * The **bot must be an administrator** in the supergroup or channel for this to work.\n    *\n    * **By default**, this method guarantees that after the call the user is not a member of the chat, but will be able to join it.\n    * So **if the user is a member of the chat they will also be removed from the chat**. If you don't want this, use the parameter *only_if_banned*\n    *\n    * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Number} userId  Unique identifier of the target user\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#unbanchatmember\n    */\n\n  }, {\n    key: 'unbanChatMember',\n    value: function unbanChatMember(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('unbanChatMember', { form: form });\n    }\n\n    /**\n    * Use this method to restrict a user in a supergroup.\n    * The bot **must be an administrator in the supergroup** for this to work\n    * and must have the appropriate admin rights. Pass True for all boolean parameters\n    * to lift restrictions from a user. Returns True on success.\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Number} userId Unique identifier of the target user\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#restrictchatmember\n    */\n\n  }, {\n    key: 'restrictChatMember',\n    value: function restrictChatMember(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('restrictChatMember', { form: form });\n    }\n\n    /**\n     * Use this method to promote or demote a user in a supergroup or a channel.\n     * The bot **must be an administrator** in the chat for this to work\n     * and must have the appropriate admin rights. Pass False for all boolean parameters to demote a user.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} userId\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success.\n     * @see https://core.telegram.org/bots/api#promotechatmember\n     */\n\n  }, {\n    key: 'promoteChatMember',\n    value: function promoteChatMember(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('promoteChatMember', { form: form });\n    }\n\n    /**\n     * Use this method to set a custom title for an administrator in a supergroup promoted by the bot.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} userId Unique identifier of the target user\n     * @param  {String} customTitle New custom title for the administrator; 0-16 characters, emoji are not allowed\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatadministratorcustomtitle\n     */\n\n  }, {\n    key: 'setChatAdministratorCustomTitle',\n    value: function setChatAdministratorCustomTitle(chatId, userId, customTitle) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      form.custom_title = customTitle;\n      return this._request('setChatAdministratorCustomTitle', { form: form });\n    }\n\n    /**\n     * Use this method to ban a channel chat in a supergroup or a channel.\n     *\n     * Until the chat is [unbanned](https://core.telegram.org/bots/api#unbanchatsenderchat), the owner of the banned chat won't be able to send messages on behalf of any of their channels.\n     * The bot **must be an administrator in the supergroup or channel** for this to work and must have the appropriate administrator rights\n     *\n     * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} senderChatId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success.\n     * @see https://core.telegram.org/bots/api#banchatsenderchat\n     */\n\n  }, {\n    key: 'banChatSenderChat',\n    value: function banChatSenderChat(chatId, senderChatId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.sender_chat_id = senderChatId;\n      return this._request('banChatSenderChat', { form: form });\n    }\n\n    /**\n    * Use this method to unban a previously banned channel chat in a supergroup or channel.\n    *\n    * The bot **must be an administrator** for this to work and must have the appropriate administrator rights.\n    *\n    * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Number} senderChatId Unique identifier of the target user\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#unbanchatsenderchat\n    */\n\n  }, {\n    key: 'unbanChatSenderChat',\n    value: function unbanChatSenderChat(chatId, senderChatId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.sender_chat_id = senderChatId;\n      return this._request('unbanChatSenderChat', { form: form });\n    }\n\n    /**\n     * Use this method to set default chat permissions for all members.\n     *\n     * The bot **must be an administrator in the group or a supergroup** for this to\n     * work and **must have the `can_restrict_members` admin rights.**\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Array} chatPermissions New default chat permissions\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatpermissions\n     */\n\n  }, {\n    key: 'setChatPermissions',\n    value: function setChatPermissions(chatId, chatPermissions) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.permissions = stringify(chatPermissions);\n      return this._request('setChatPermissions', { form: form });\n    }\n\n    /**\n     * Use this method to generate a new primary invite link for a chat. **Any previously generated primary link is revoked**.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate administrator rights.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Exported invite link as String on success.\n     * @see https://core.telegram.org/bots/api#exportchatinvitelink\n     */\n\n  }, {\n    key: 'exportChatInviteLink',\n    value: function exportChatInviteLink(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('exportChatInviteLink', { form: form });\n    }\n\n    /**\n     * Use this method to create an additional invite link for a chat.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * The link generated with this method can be revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api#revokechatinvitelink)\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Object} The new invite link as [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n     * @see https://core.telegram.org/bots/api#createchatinvitelink\n     */\n\n  }, {\n    key: 'createChatInviteLink',\n    value: function createChatInviteLink(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('createChatInviteLink', { form: form });\n    }\n\n    /**\n     * Use this method to edit a non-primary invite link created by the bot.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} inviteLink Text with the invite link to edit\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} The edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n     * @see https://core.telegram.org/bots/api#editchatinvitelink\n     */\n\n  }, {\n    key: 'editChatInviteLink',\n    value: function editChatInviteLink(chatId, inviteLink) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.invite_link = inviteLink;\n      return this._request('editChatInviteLink', { form: form });\n    }\n\n    /**\n     * Use this method to revoke an invite link created by the bot.\n     * Note: If the primary link is revoked, a new link is automatically generated\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} inviteLink The invite link to revoke\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} The revoked invite link as [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n     * @see https://core.telegram.org/bots/api#revokechatinvitelink\n     */\n\n  }, {\n    key: 'revokeChatInviteLink',\n    value: function revokeChatInviteLink(chatId, inviteLink) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.invite_link = inviteLink;\n      return this._request('revokeChatInviteLink', { form: form });\n    }\n\n    /**\n     * Use this method to approve a chat join request.\n     *\n     * The bot **must be an administrator in the chat** for this to work and **must have the `can_invite_users` administrator right.**\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#approvechatjoinrequest\n     */\n\n  }, {\n    key: 'approveChatJoinRequest',\n    value: function approveChatJoinRequest(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('approveChatJoinRequest', { form: form });\n    }\n\n    /**\n     * Use this method to decline a chat join request.\n     *\n     * The bot **must be an administrator in the chat** for this to work and **must have the `can_invite_users` administrator right**.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#declinechatjoinrequest\n     */\n\n  }, {\n    key: 'declineChatJoinRequest',\n    value: function declineChatJoinRequest(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('declineChatJoinRequest', { form: form });\n    }\n\n    /**\n     * Use this method to set a new profile photo for the chat. **Photos can't be changed for private chats**.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {stream.Stream|Buffer} photo A file path or a Stream.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatphoto\n     */\n\n  }, {\n    key: 'setChatPhoto',\n    value: function setChatPhoto(chatId, photo) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('photo', photo, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.photo = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('setChatPhoto', opts);\n    }\n\n    /**\n    * Use this method to delete a chat photo. **Photos can't be changed for private chats**.\n    *\n    * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#deletechatphoto\n    */\n\n  }, {\n    key: 'deleteChatPhoto',\n    value: function deleteChatPhoto(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('deleteChatPhoto', { form: form });\n    }\n\n    /**\n     * Use this method to change the title of a chat. **Titles can't be changed for private chats**.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} title New chat title, 1-255 characters\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchattitle\n     */\n\n  }, {\n    key: 'setChatTitle',\n    value: function setChatTitle(chatId, title) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.title = title;\n      return this._request('setChatTitle', { form: form });\n    }\n\n    /**\n     * Use this method to change the description of a group, a supergroup or a channel.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} description New chat title, 0-255 characters\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatdescription\n     */\n\n  }, {\n    key: 'setChatDescription',\n    value: function setChatDescription(chatId, description) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.description = description;\n      return this._request('setChatDescription', { form: form });\n    }\n\n    /**\n     * Use this method to pin a message in a supergroup.\n     *\n     * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n     * right in a supergroup or `can_edit_messages` administrator right in a channel.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} messageId Identifier of a message to pin\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#pinchatmessage\n     */\n\n  }, {\n    key: 'pinChatMessage',\n    value: function pinChatMessage(chatId, messageId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_id = messageId;\n      return this._request('pinChatMessage', { form: form });\n    }\n\n    /**\n     * Use this method to remove a message from the list of pinned messages in a chat\n     *\n     * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n     * right in a supergroup or `can_edit_messages` administrator right in a channel.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#unpinchatmessage\n     */\n\n  }, {\n    key: 'unpinChatMessage',\n    value: function unpinChatMessage(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('unpinChatMessage', { form: form });\n    }\n\n    /**\n    * Use this method to clear the list of pinned messages in a chat.\n    *\n    * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n    * right in a supergroup or `can_edit_messages` administrator right in a channel.\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#unpinallchatmessages\n    */\n\n  }, {\n    key: 'unpinAllChatMessages',\n    value: function unpinAllChatMessages(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('unpinAllChatMessages', { form: form });\n    }\n\n    /**\n     * Use this method for your bot to leave a group, supergroup or channel\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#leavechat\n     */\n\n  }, {\n    key: 'leaveChat',\n    value: function leaveChat(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('leaveChat', { form: form });\n    }\n\n    /**\n     * Use this method to get up to date information about the chat\n     * (current name of the user for one-on-one conversations, current\n     * username of a user, group or channel, etc.).\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`) or channel\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} [ChatFullInfo](https://core.telegram.org/bots/api#chatfullinfo) object on success\n     * @see https://core.telegram.org/bots/api#getchat\n     */\n\n  }, {\n    key: 'getChat',\n    value: function getChat(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('getChat', { form: form });\n    }\n\n    /**\n     * Use this method to get a list of administrators in a chat\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, returns an Array of [ChatMember](https://core.telegram.org/bots/api#chatmember) objects that contains information about all chat administrators except other bots.\n     * If the chat is a group or a supergroup and no administrators were appointed, only the creator will be returned\n     * @see https://core.telegram.org/bots/api#getchatadministrators\n     */\n\n  }, {\n    key: 'getChatAdministrators',\n    value: function getChatAdministrators(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('getChatAdministrators', { form: form });\n    }\n\n    /**\n    * Use this method to get the number of members in a chat.\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} Int on success\n    * @see https://core.telegram.org/bots/api#getchatmembercount\n    */\n\n  }, {\n    key: 'getChatMemberCount',\n    value: function getChatMemberCount(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('getChatMemberCount', { form: form });\n    }\n\n    /**\n     * Use this method to get information about a member of a chat.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} [ChatMember](https://core.telegram.org/bots/api#chatmember) object on success\n     * @see https://core.telegram.org/bots/api#getchatmember\n     */\n\n  }, {\n    key: 'getChatMember',\n    value: function getChatMember(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('getChatMember', { form: form });\n    }\n\n    /**\n     * Use this method to set a new group sticker set for a supergroup.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate administrator rights.\n     *\n     * **Note:** Use the field `can_set_sticker_set` optionally returned in [getChat](https://core.telegram.org/bots/api#getchat) requests to check if the bot can use this method.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param  {String} stickerSetName Name of the sticker set to be set as the group sticker set\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatstickerset\n     */\n\n  }, {\n    key: 'setChatStickerSet',\n    value: function setChatStickerSet(chatId, stickerSetName) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.sticker_set_name = stickerSetName;\n      return this._request('setChatStickerSet', { form: form });\n    }\n\n    /**\n     * Use this method to delete a group sticker set from a supergroup.\n     *\n     * Use the field `can_set_sticker_set` optionally returned in [getChat](https://core.telegram.org/bots/api#getchat) requests to check if the bot can use this method.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#deletechatstickerset\n     */\n\n  }, {\n    key: 'deleteChatStickerSet',\n    value: function deleteChatStickerSet(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('deleteChatStickerSet', { form: form });\n    }\n\n    /**\n     * Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Array of [Sticker](https://core.telegram.org/bots/api#sticker) objects\n     * @see https://core.telegram.org/bots/api#getforumtopiciconstickers\n     */\n\n  }, {\n    key: 'getForumTopicIconStickers',\n    value: function getForumTopicIconStickers(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('getForumTopicIconStickers', { form: form });\n    }\n\n    /**\n     * Use this method to create a topic in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n     *\n     * Returns information about the created topic as a [ForumTopic](https://core.telegram.org/bots/api#forumtopic) object.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param  {String} name Topic name, 1-128 characters\n     * @param  {Object} [options] Additional Telegram query options\n     * @see https://core.telegram.org/bots/api#createforumtopic\n     */\n\n  }, {\n    key: 'createForumTopic',\n    value: function createForumTopic(chatId, name) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.name = name;\n      return this._request('createForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to edit name and icon of a topic in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have can_manage_topics administrator rights, unless it is the creator of the topic.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#editforumtopic\n     */\n\n  }, {\n    key: 'editForumTopic',\n    value: function editForumTopic(chatId, messageThreadId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_thread_id = messageThreadId;\n      return this._request('editForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to close an open topic in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#closeforumtopic\n     */\n\n  }, {\n    key: 'closeForumTopic',\n    value: function closeForumTopic(chatId, messageThreadId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_thread_id = messageThreadId;\n      return this._request('closeForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to reopen a closed topic in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#reopenforumtopic\n     */\n\n  }, {\n    key: 'reopenForumTopic',\n    value: function reopenForumTopic(chatId, messageThreadId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_thread_id = messageThreadId;\n      return this._request('reopenForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to delete a forum topic along with all its messages in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have the can_delete_messages administrator rights.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#deleteforumtopic\n     */\n\n  }, {\n    key: 'deleteForumTopic',\n    value: function deleteForumTopic(chatId, messageThreadId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_thread_id = messageThreadId;\n      return this._request('deleteForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to clear the list of pinned messages in a forum topic.\n     * The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#unpinallforumtopicmessages\n     */\n\n  }, {\n    key: 'unpinAllForumTopicMessages',\n    value: function unpinAllForumTopicMessages(chatId, messageThreadId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_thread_id = messageThreadId;\n      return this._request('unpinAllForumTopicMessages', { form: form });\n    }\n\n    /**\n    * Use this method to edit the name of the 'General' topic in a forum supergroup chat.\n    * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n    * The topic will be automatically unhidden if it was hidden.\n    *\n    * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n    * @param {String} name New topic name, 1-128 characters\n    * @param {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#editgeneralforumtopic\n    */\n\n  }, {\n    key: 'editGeneralForumTopic',\n    value: function editGeneralForumTopic(chatId, name) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.name = name;\n      return this._request('editGeneralForumTopic', { form: form });\n    }\n\n    /**\n    * Use this method to close an open 'General' topic in a forum supergroup chat.\n    * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n    * The topic will be automatically unhidden if it was hidden.\n    *\n    * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n    * @param {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#closegeneralforumtopic\n    */\n\n  }, {\n    key: 'closeGeneralForumTopic',\n    value: function closeGeneralForumTopic(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('closeGeneralForumTopic', { form: form });\n    }\n\n    /**\n    * Use this method to reopen a closed 'General' topic in a forum supergroup chat.\n    * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n    * The topic will be automatically unhidden if it was hidden.\n    *\n    * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n    * @param {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#reopengeneralforumtopic\n    */\n\n  }, {\n    key: 'reopenGeneralForumTopic',\n    value: function reopenGeneralForumTopic(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('reopenGeneralForumTopic', { form: form });\n    }\n\n    /**\n    * Use this method to hide the 'General' topic in a forum supergroup chat.\n    * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n    * The topic will be automatically closed if it was open.\n    *\n    * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n    * @param {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#hidegeneralforumtopic\n    */\n\n  }, {\n    key: 'hideGeneralForumTopic',\n    value: function hideGeneralForumTopic(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('hideGeneralForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to unhide the 'General' topic in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#unhidegeneralforumtopic\n     */\n\n  }, {\n    key: 'unhideGeneralForumTopic',\n    value: function unhideGeneralForumTopic(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('unhideGeneralForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to clear the list of pinned messages in a General forum topic.\n     * The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#unpinallgeneralforumtopicmessages\n     */\n\n  }, {\n    key: 'unpinAllGeneralForumTopicMessages',\n    value: function unpinAllGeneralForumTopicMessages(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('unhideGeneralForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to send answers to callback queries sent from\n     * [inline keyboards](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating).\n     *\n     * The answer will be displayed to the user as a notification at the top of the chat screen or as an alert.\n     *\n     * This method has **older, compatible signatures ([1][answerCallbackQuery-v0.27.1])([2][answerCallbackQuery-v0.29.0])**\n     * that are being deprecated.\n     *\n     * @param  {String} callbackQueryId Unique identifier for the query to be answered\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#answercallbackquery\n     */\n\n  }, {\n    key: 'answerCallbackQuery',\n    value: function answerCallbackQuery(callbackQueryId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      /* The older method signature (in/before v0.27.1) was answerCallbackQuery(callbackQueryId, text, showAlert).\n       * We need to ensure backwards-compatibility while maintaining\n       * consistency of the method signatures throughout the library */\n      if ((typeof form === 'undefined' ? 'undefined' : _typeof(form)) !== 'object') {\n        /* eslint-disable no-param-reassign, prefer-rest-params */\n        deprecate('The method signature answerCallbackQuery(callbackQueryId, text, showAlert) has been deprecated since v0.27.1');\n        form = {\n          callback_query_id: arguments[0],\n          text: arguments[1],\n          show_alert: arguments[2]\n        };\n        /* eslint-enable no-param-reassign, prefer-rest-params */\n      }\n      /* The older method signature (in/before v0.29.0) was answerCallbackQuery([options]).\n       * We need to ensure backwards-compatibility while maintaining\n       * consistency of the method signatures throughout the library. */\n      if ((typeof callbackQueryId === 'undefined' ? 'undefined' : _typeof(callbackQueryId)) === 'object') {\n        /* eslint-disable no-param-reassign, prefer-rest-params */\n        deprecate('The method signature answerCallbackQuery([options]) has been deprecated since v0.29.0');\n        form = callbackQueryId;\n        /* eslint-enable no-param-reassign, prefer-rest-params */\n      } else {\n        form.callback_query_id = callbackQueryId;\n      }\n      return this._request('answerCallbackQuery', { form: form });\n    }\n\n    /**\n     * Use this method to get the list of boosts added to a chat by a use.\n     * Requires administrator rights in the chat\n     *\n     * @param  {Number|String} chatId  Unique identifier for the group/channel\n     * @param  {Number} user_id Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, returns a [UserChatBoosts](https://core.telegram.org/bots/api#userchatboosts) object\n     * @see https://core.telegram.org/bots/api#getuserchatboosts\n     */\n\n  }, {\n    key: 'getUserChatBoosts',\n    value: function getUserChatBoosts(chatId, pollId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_id = pollId;\n      return this._request('getUserChatBoosts', { form: form });\n    }\n\n    /**\n     * Use this method to get information about the connection of the bot with a business account\n     *\n     * @param  {Number|String} businessConnectionId  Unique identifier for the group/channel\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, returns [BusinessConnection](https://core.telegram.org/bots/api#businessconnection) object\n     * @see https://core.telegram.org/bots/api#getbusinessconnection\n     */\n\n  }, {\n    key: 'getBusinessConnection',\n    value: function getBusinessConnection(businessConnectionId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.business_connection_id = businessConnectionId;\n      return this._request('getBusinessConnection', { form: form });\n    }\n\n    /**\n     * Use this method to change the list of the bot's commands.\n     *\n     * See https://core.telegram.org/bots#commands for more details about bot commands\n     *\n     * @param  {Array} commands  List of bot commands to be set as the list of the [bot's commands](https://core.telegram.org/bots/api#botcommand). At most 100 commands can be specified.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setmycommands\n     */\n\n  }, {\n    key: 'setMyCommands',\n    value: function setMyCommands(commands) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.commands = stringify(commands);\n\n      if (form.scope) {\n        form.scope = stringify(form.scope);\n      }\n\n      return this._request('setMyCommands', { form: form });\n    }\n\n    /**\n     * Use this method to delete the list of the bot's commands for the given scope and user language.\n     *\n     *  After deletion, [higher level commands](https://core.telegram.org/bots/api#determining-list-of-commands) will be shown to affected users.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#deletemycommands\n     */\n\n  }, {\n    key: 'deleteMyCommands',\n    value: function deleteMyCommands() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('deleteMyCommands', { form: form });\n    }\n\n    /**\n     * Use this method to get the current list of the bot's commands for the given scope and user language.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Array of [BotCommand](https://core.telegram.org/bots/api#botcommand) on success. If commands aren't set, an empty list is returned.\n     * @see https://core.telegram.org/bots/api#getmycommands\n     */\n\n  }, {\n    key: 'getMyCommands',\n    value: function getMyCommands() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (form.scope) {\n        form.scope = stringify(form.scope);\n      }\n      return this._request('getMyCommands', { form: form });\n    }\n\n    /**\n     * Use this method to change the bot's name.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setmyname\n     */\n\n  }, {\n    key: 'setMyName',\n    value: function setMyName() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('setMyName', { form: form });\n    }\n\n    /**\n     * Use this method to get the current bot name for the given user language.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} [BotName](https://core.telegram.org/bots/api#botname) on success\n     * @see https://core.telegram.org/bots/api#getmyname\n     */\n\n  }, {\n    key: 'getMyName',\n    value: function getMyName() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getMyName', { form: form });\n    }\n\n    /**\n     * Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty.\n     *\n     * Returns True on success.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setmydescription\n     */\n\n  }, {\n    key: 'setMyDescription',\n    value: function setMyDescription() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('setMyDescription', { form: form });\n    }\n\n    /**\n     * Use this method to get the current bot description for the given user language.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Returns [BotDescription](https://core.telegram.org/bots/api#botdescription) on success.\n     * @see https://core.telegram.org/bots/api#getmydescription\n     */\n\n  }, {\n    key: 'getMyDescription',\n    value: function getMyDescription() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getMyDescription', { form: form });\n    }\n\n    /**\n     * Use this method to change the bot's short description, which is shown on the bot's profile page\n     * and is sent together with the link when users share the bot.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Returns True on success.\n     * @see https://core.telegram.org/bots/api#setmyshortdescription\n     */\n\n  }, {\n    key: 'setMyShortDescription',\n    value: function setMyShortDescription() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('setMyShortDescription', { form: form });\n    }\n\n    /**\n     * Use this method to get the current bot short description for the given user language.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Returns [BotShortDescription](https://core.telegram.org/bots/api#botshortdescription) on success.\n     * @see https://core.telegram.org/bots/api#getmyshortdescription\n     */\n\n  }, {\n    key: 'getMyShortDescription',\n    value: function getMyShortDescription() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getMyShortDescription', { form: form });\n    }\n\n    /**\n     * Use this method to change the bot's menu button in a private chat, or the default menu button.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatmenubutton\n     */\n\n  }, {\n    key: 'setChatMenuButton',\n    value: function setChatMenuButton() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('setChatMenuButton', { form: form });\n    }\n\n    /**\n     * Use this method to get the current value of the bot's menu button in a private chat, or the default menu button.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} [MenuButton](https://core.telegram.org/bots/api#menubutton) on success\n     * @see https://core.telegram.org/bots/api#getchatmenubutton\n     */\n\n  }, {\n    key: 'getChatMenuButton',\n    value: function getChatMenuButton() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getChatMenuButton', { form: form });\n    }\n\n    /**\n     * Use this method to change the default administrator rights requested by the bot when it's added as an administrator to groups or channels.\n     *\n     * These rights will be suggested to users, but they are are free to modify the list before adding the bot.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#getchatmenubutton\n     */\n\n  }, {\n    key: 'setMyDefaultAdministratorRights',\n    value: function setMyDefaultAdministratorRights() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('setMyDefaultAdministratorRights', { form: form });\n    }\n\n    /**\n     * Use this method to get the current default administrator rights of the bot.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} [ChatAdministratorRights](https://core.telegram.org/bots/api#chatadministratorrights) on success\n     * @see https://core.telegram.org/bots/api#getmydefaultadministratorrights\n     */\n\n  }, {\n    key: 'getMyDefaultAdministratorRights',\n    value: function getMyDefaultAdministratorRights() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getMyDefaultAdministratorRights', { form: form });\n    }\n\n    /**\n     * Use this method to edit text or [game](https://core.telegram.org/bots/api#games) messages sent by the bot or via the bot (for inline bots).\n     *\n     * Note: that **you must provide one of chat_id, message_id, or inline_message_id** in your request.\n     *\n     * @param  {String} text  New text of the message\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n     * @see https://core.telegram.org/bots/api#editmessagetext\n     */\n\n  }, {\n    key: 'editMessageText',\n    value: function editMessageText(text) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.text = text;\n      return this._request('editMessageText', { form: form });\n    }\n\n    /**\n     * Use this method to edit captions of messages sent by the bot or via the bot (for inline bots).\n     *\n     * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n     *\n     * @param  {String} caption  New caption of the message\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n     * @see https://core.telegram.org/bots/api#editmessagecaption\n     */\n\n  }, {\n    key: 'editMessageCaption',\n    value: function editMessageCaption(caption) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.caption = caption;\n      return this._request('editMessageCaption', { form: form });\n    }\n\n    /**\n     * Use this method to edit animation, audio, document, photo, or video messages.\n     *\n     * If a message is a part of a message album, then it can be edited only to a photo or a video.\n     *\n     * Otherwise, message type can be changed arbitrarily. When inline message is edited, new file can't be uploaded.\n     * Use previously uploaded file via its file_id or specify a URL.\n     *\n     * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n     *\n     * @param  {Object} media  A JSON-serialized object for a new media content of the message\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n     * @see https://core.telegram.org/bots/api#editmessagemedia\n     */\n\n  }, {\n    key: 'editMessageMedia',\n    value: function editMessageMedia(media) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var regexAttach = /attach:\\/\\/.+/;\n\n      if (typeof media.media === 'string' && regexAttach.test(media.media)) {\n        var opts = {\n          qs: form\n        };\n\n        opts.formData = {};\n\n        var payload = Object.assign({}, media);\n        delete payload.media;\n\n        try {\n          var attachName = String(0);\n\n          var _formatSendData6 = this._formatSendData(attachName, media.media.replace('attach://', ''), media.fileOptions),\n              _formatSendData7 = _slicedToArray(_formatSendData6, 1),\n              formData = _formatSendData7[0];\n\n          if (formData) {\n            opts.formData[attachName] = formData[attachName];\n            payload.media = 'attach://' + attachName;\n          } else {\n            throw new errors.FatalError('Failed to process the replacement action for your ' + media.type);\n          }\n        } catch (ex) {\n          return Promise.reject(ex);\n        }\n\n        opts.qs.media = stringify(payload);\n\n        return this._request('editMessageMedia', opts);\n      }\n\n      form.media = stringify(media);\n\n      return this._request('editMessageMedia', { form: form });\n    }\n\n    /**\n     * Use this method to edit only the reply markup of messages sent by the bot or via the bot (for inline bots).\n     *\n     * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n     *\n     * @param  {Object} replyMarkup  A JSON-serialized object for an inline keyboard.\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n     * @see https://core.telegram.org/bots/api#editmessagetext\n     */\n\n  }, {\n    key: 'editMessageReplyMarkup',\n    value: function editMessageReplyMarkup(replyMarkup) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.reply_markup = replyMarkup;\n      return this._request('editMessageReplyMarkup', { form: form });\n    }\n\n    /**\n     * Use this method to stop a poll which was sent by the bot.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the group/channel\n     * @param  {Number} pollId Identifier of the original message with the poll\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the stopped [Poll](https://core.telegram.org/bots/api#poll) is returned\n     * @see https://core.telegram.org/bots/api#stoppoll\n     */\n\n  }, {\n    key: 'stopPoll',\n    value: function stopPoll(chatId, pollId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_id = pollId;\n      return this._request('stopPoll', { form: form });\n    }\n\n    /**\n     * Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS,\n     * or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers.\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} sticker A file path, Stream or Buffer.\n     * Can also be a `file_id` previously uploaded. Stickers are WebP format files.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n     * @see https://core.telegram.org/bots/api#sendsticker\n     */\n\n  }, {\n    key: 'sendSticker',\n    value: function sendSticker(chatId, sticker) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('sticker', sticker, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.sticker = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendSticker', opts);\n    }\n\n    /**\n     * Use this method to get a sticker set.\n     *\n     * @param  {String} name Name of the sticker set\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, a [StickerSet](https://core.telegram.org/bots/api#stickerset) object is returned\n     * @see https://core.telegram.org/bots/api#getstickerset\n     */\n\n  }, {\n    key: 'getStickerSet',\n    value: function getStickerSet(name) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.name = name;\n      return this._request('getStickerSet', { form: form });\n    }\n\n    /**\n     * Use this method to get information about custom emoji stickers by their identifiers.\n     *\n     * @param  {Array} custom_emoji_ids List of custom emoji identifiers. At most 200 custom emoji identifiers can be specified.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Array of [Sticker](https://core.telegram.org/bots/api#sticker) objects.\n     * @see https://core.telegram.org/bots/api#getcustomemojistickers\n     */\n\n  }, {\n    key: 'getCustomEmojiStickers',\n    value: function getCustomEmojiStickers(customEmojiIds) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.custom_emoji_ids = stringify(customEmojiIds);\n      return this._request('getCustomEmojiStickers', { form: form });\n    }\n\n    /**\n     * Use this method to upload a file with a sticker for later use in *createNewStickerSet* and *addStickerToSet* methods (can be used multiple\n     * times).\n     *\n     * @param  {Number} userId User identifier of sticker file owner\n     * @param  {String|stream.Stream|Buffer} sticker A file path or a Stream with the sticker in .WEBP, .PNG, .TGS, or .WEBM format. Can also be a `file_id` previously uploaded.\n     * @param {String} stickerFormat Allow values:  `static`, `animated` or `video`\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, a [File](https://core.telegram.org/bots/api#file) object is returned\n     * @see https://core.telegram.org/bots/api#uploadstickerfile\n     */\n\n  }, {\n    key: 'uploadStickerFile',\n    value: function uploadStickerFile(userId, sticker) {\n      var stickerFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'static';\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var fileOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.user_id = userId;\n      opts.qs.sticker_format = stickerFormat;\n\n      try {\n        var sendData = this._formatSendData('sticker', sticker, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.sticker = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('uploadStickerFile', opts);\n    }\n\n    /**\n     * Use this method to create new sticker set owned by a user.\n     *\n     * The bot will be able to edit the created sticker set.\n     *\n     * You must use exactly one of the fields *png_sticker*, *tgs_sticker*, or *webm_sticker*\n     *\n     * @param  {Number} userId User identifier of created sticker set owner\n     * @param  {String} name Short name of sticker set, to be used in `t.me/addstickers/` URLs (e.g.,   *\"animals\"*). Can contain only english letters, digits and underscores.\n     *  Must begin with a letter, can't contain consecutive underscores and must end in `\"_by_<bot_username>\"`. `<bot_username>` is case insensitive. 1-64 characters.\n     * @param  {String} title Sticker set title, 1-64 characters\n     * @param  {String|stream.Stream|Buffer} pngSticker Png image with the sticker, must be up to 512 kilobytes in size,\n     *  dimensions must not exceed 512px, and either width or height must be exactly 512px.\n     * @param  {String} emojis One or more emoji corresponding to the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise}  True on success\n     * @see https://core.telegram.org/bots/api#createnewstickerset\n     */\n\n  }, {\n    key: 'createNewStickerSet',\n    value: function createNewStickerSet(userId, name, title, pngSticker, emojis) {\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n      var fileOptions = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.user_id = userId;\n      opts.qs.name = name;\n      opts.qs.title = title;\n      opts.qs.emojis = emojis;\n      opts.qs.mask_position = stringify(options.mask_position);\n      try {\n        var sendData = this._formatSendData('png_sticker', pngSticker, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.png_sticker = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('createNewStickerSet', opts);\n    }\n\n    /**\n     * Use this method to add a new sticker to a set created by the bot.\n     *\n     * You must use exactly one of the fields *png_sticker*, *tgs_sticker*, or *webm_sticker*\n     *\n     * Animated stickers can be added to animated sticker sets and only to them\n     *\n     * Note:\n     * - Emoji sticker sets can have up to 200 sticker\n     * - Static or Animated sticker sets can have up to 120 stickers\n     *\n     * @param  {Number} userId User identifier of sticker set owner\n     * @param  {String} name Sticker set name\n     * @param  {String|stream.Stream|Buffer} sticker Png image with the sticker (must be up to 512 kilobytes in size,\n     * dimensions must not exceed 512px, and either width or height must be exactly 512px, [TGS animation](https://core.telegram.org/stickers#animated-sticker-requirements)\n     * with the sticker or [WEBM video](https://core.telegram.org/stickers#video-sticker-requirements) with the sticker.\n     * @param  {String} emojis One or more emoji corresponding to the sticker\n     * @param  {String} stickerType Allow values: `png_sticker`, `tgs_sticker`, or `webm_sticker`.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise}  True on success\n     * @see https://core.telegram.org/bots/api#addstickertoset\n     */\n\n  }, {\n    key: 'addStickerToSet',\n    value: function addStickerToSet(userId, name, sticker, emojis) {\n      var stickerType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'png_sticker';\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n      var fileOptions = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.user_id = userId;\n      opts.qs.name = name;\n      opts.qs.emojis = emojis;\n      opts.qs.mask_position = stringify(options.mask_position);\n\n      if (typeof stickerType !== 'string' || ['png_sticker', 'tgs_sticker', 'webm_sticker'].indexOf(stickerType) === -1) {\n        return Promise.reject(new Error('stickerType must be a string and the allow types is: png_sticker, tgs_sticker, webm_sticker'));\n      }\n\n      try {\n        var sendData = this._formatSendData(stickerType, sticker, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs[stickerType] = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('addStickerToSet', opts);\n    }\n\n    /**\n     * Use this method to move a sticker in a set created by the bot to a specific position.\n     *\n     * @param  {String} sticker File identifier of the sticker\n     * @param  {Number} position New sticker position in the set, zero-based\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickerpositioninset\n     */\n\n  }, {\n    key: 'setStickerPositionInSet',\n    value: function setStickerPositionInSet(sticker, position) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.sticker = sticker;\n      form.position = position;\n      return this._request('setStickerPositionInSet', { form: form });\n    }\n\n    /**\n     * Use this method to delete a sticker from a set created by the bot.\n     *\n     * @param  {String} sticker File identifier of the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#deletestickerfromset\n     * @todo Add tests for this method!\n     */\n\n  }, {\n    key: 'deleteStickerFromSet',\n    value: function deleteStickerFromSet(sticker) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.sticker = sticker;\n      return this._request('deleteStickerFromSet', { form: form });\n    }\n\n    /**\n     * Use this method to replace an existing sticker in a sticker set with a new one\n     *\n     * @param  {Number} user_id User identifier of the sticker set owner\n     * @param  {String} name Sticker set name\n     * @param  {String} sticker File identifier of the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#replacestickerinset\n     * @todo Add tests for this method!\n     */\n\n  }, {\n    key: 'replaceStickerInSet',\n    value: function replaceStickerInSet(userId, name, oldSticker) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.user_id = userId;\n      form.name = name;\n      form.old_sticker = oldSticker;\n      return this._request('deleteStickerFromSet', { form: form });\n    }\n\n    /**\n     * Use this method to change the list of emoji assigned to a regular or custom emoji sticker.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} sticker File identifier of the sticker\n     * @param { Array } emojiList A JSON-serialized list of 1-20 emoji associated with the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickeremojilist\n     */\n\n  }, {\n    key: 'setStickerEmojiList',\n    value: function setStickerEmojiList(sticker, emojiList) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.sticker = sticker;\n      form.emoji_list = stringify(emojiList);\n      return this._request('setStickerEmojiList', { form: form });\n    }\n\n    /**\n     * Use this method to change the list of emoji assigned to a `regular` or `custom emoji` sticker.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} sticker File identifier of the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickerkeywords\n     */\n\n  }, {\n    key: 'setStickerKeywords',\n    value: function setStickerKeywords(sticker) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.sticker = sticker;\n      if (form.keywords) {\n        form.keywords = stringify(form.keywords);\n      }\n      return this._request('setStickerKeywords', { form: form });\n    }\n\n    /**\n     * Use this method to change the [mask position](https://core.telegram.org/bots/api#maskposition) of a mask sticker.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} sticker File identifier of the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickermaskposition\n     */\n\n  }, {\n    key: 'setStickerMaskPosition',\n    value: function setStickerMaskPosition(sticker) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.sticker = sticker;\n      if (form.mask_position) {\n        form.mask_position = stringify(form.mask_position);\n      }\n      return this._request('setStickerMaskPosition', { form: form });\n    }\n\n    /**\n     * Use this method to set the title of a created sticker set.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} name Sticker set name\n     * @param  {String} title Sticker set title, 1-64 characters\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickersettitle\n     */\n\n  }, {\n    key: 'setStickerSetTitle',\n    value: function setStickerSetTitle(name, title) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.name = name;\n      form.title = title;\n      return this._request('setStickerSetTitle', { form: form });\n    }\n\n    /**\n     * Use this method to add a thumb to a set created by the bot.\n     *\n     * Animated thumbnails can be set for animated sticker sets only. Video thumbnails can be set only for video sticker sets only\n     *\n     * @param  {Number} userId User identifier of sticker set owner\n     * @param  {String} name Sticker set name\n     * @param  {String|stream.Stream|Buffer} thumbnail A .WEBP or .PNG image with the thumbnail,\n     * must be up to 128 kilobytes in size and have width and height exactly 100px,\n     * a TGS animation with the thumbnail up to 32 kilobytes in size or a WEBM video with the thumbnail up to 32 kilobytes in size.\n     *\n     * Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram\n     * to get a file from the Internet, or upload a new one. Animated sticker set thumbnails can't be uploaded via HTTP URL.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickersetthumbnail\n     */\n\n  }, {\n    key: 'setStickerSetThumbnail',\n    value: function setStickerSetThumbnail(userId, name, thumbnail) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var fileOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.user_id = userId;\n      opts.qs.name = name;\n      opts.qs.mask_position = stringify(options.mask_position);\n      try {\n        var sendData = this._formatSendData('thumbnail', thumbnail, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.thumbnail = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('setStickerSetThumbnail', opts);\n    }\n\n    /**\n     * Use this method to set the thumbnail of a custom emoji sticker set.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} name Sticker set name\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setcustomemojistickersetthumbnail\n     */\n\n  }, {\n    key: 'setCustomEmojiStickerSetThumbnail',\n    value: function setCustomEmojiStickerSetThumbnail(name) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.name = name;\n      return this._request('setCustomEmojiStickerSetThumbnail', { form: form });\n    }\n\n    /**\n     * Use this method to delete a sticker set that was created by the bot.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} name Sticker set name\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#deletestickerset\n     */\n\n  }, {\n    key: 'deleteStickerSet',\n    value: function deleteStickerSet(name) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.name = name;\n      return this._request('deleteStickerSet', { form: form });\n    }\n\n    /**\n     * Send answers to an inline query.\n     *\n     * Note: No more than 50 results per query are allowed.\n     *\n     * @param  {String} inlineQueryId Unique identifier of the query\n     * @param  {InlineQueryResult[]} results An array of results for the inline query\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, True is returned\n     * @see https://core.telegram.org/bots/api#answerinlinequery\n     */\n\n  }, {\n    key: 'answerInlineQuery',\n    value: function answerInlineQuery(inlineQueryId, results) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.inline_query_id = inlineQueryId;\n      form.results = stringify(results);\n      return this._request('answerInlineQuery', { form: form });\n    }\n\n    /**\n     * Use this method to set the result of an interaction with a [Web App](https://core.telegram.org/bots/webapps)\n     * and send a corresponding message on behalf of the user to the chat from which the query originated.\n     *\n     * @param  {String} webAppQueryId Unique identifier for the query to be answered\n     * @param  {InlineQueryResult} result object that represents one result of an inline query\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, a [SentWebAppMessage](https://core.telegram.org/bots/api#sentwebappmessage) object is returned\n     * @see https://core.telegram.org/bots/api#answerwebappquery\n     */\n\n  }, {\n    key: 'answerWebAppQuery',\n    value: function answerWebAppQuery(webAppQueryId, result) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.web_app_query_id = webAppQueryId;\n      form.result = stringify(result);\n      return this._request('answerWebAppQuery', { form: form });\n    }\n\n    /**\n     * Use this method to send an invoice.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} title Product name, 1-32 characters\n     * @param  {String} description Product description, 1-255 characters\n     * @param  {String} payload Bot defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.\n     * @param  {String} providerToken Payments provider token, obtained via `@BotFather`\n     * @param  {String} currency Three-letter ISO 4217 currency code\n     * @param  {Array} prices Breakdown of prices\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n     * @see https://core.telegram.org/bots/api#sendinvoice\n     */\n\n  }, {\n    key: 'sendInvoice',\n    value: function sendInvoice(chatId, title, description, payload, providerToken, currency, prices) {\n      var form = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n\n      form.chat_id = chatId;\n      form.title = title;\n      form.description = description;\n      form.payload = payload;\n      form.provider_token = providerToken;\n      form.currency = currency;\n      form.prices = stringify(prices);\n      form.provider_data = stringify(form.provider_data);\n      if (form.suggested_tip_amounts) {\n        form.suggested_tip_amounts = stringify(form.suggested_tip_amounts);\n      }\n      return this._request('sendInvoice', { form: form });\n    }\n\n    /**\n    * Use this method to create a link for an invoice.\n    *\n    * @param {String} title Product name, 1-32 characters\n    * @param {String} description Product description, 1-255 characters\n    * @param {String} payload Bot defined invoice payload\n    * @param {String} providerToken Payment provider token\n    * @param {String} currency Three-letter ISO 4217 currency code\n    * @param {Array} prices Breakdown of prices\n    * @param {Object} [options] Additional Telegram query options\n    * @returns {Promise} The created invoice link as String on success.\n    * @see https://core.telegram.org/bots/api#createinvoicelink\n    */\n\n  }, {\n    key: 'createInvoiceLink',\n    value: function createInvoiceLink(title, description, payload, providerToken, currency, prices) {\n      var form = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n      form.title = title;\n      form.description = description;\n      form.payload = payload;\n      form.provider_token = providerToken;\n      form.currency = currency;\n      form.prices = stringify(prices);\n      return this._request('createInvoiceLink', { form: form });\n    }\n\n    /**\n    * Use this method to reply to shipping queries.\n    *\n    * If you sent an invoice requesting a shipping address and the parameter is_flexible was specified,\n    * the Bot API will send an [Update](https://core.telegram.org/bots/api#update) with a shipping_query field to the bot\n    *\n    * @param  {String} shippingQueryId  Unique identifier for the query to be answered\n    * @param  {Boolean} ok Specify if delivery of the product is possible\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} On success, True is returned\n    * @see https://core.telegram.org/bots/api#answershippingquery\n    */\n\n  }, {\n    key: 'answerShippingQuery',\n    value: function answerShippingQuery(shippingQueryId, ok) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.shipping_query_id = shippingQueryId;\n      form.ok = ok;\n      form.shipping_options = stringify(form.shipping_options);\n      return this._request('answerShippingQuery', { form: form });\n    }\n\n    /**\n     * Use this method to respond to such pre-checkout queries\n     *\n     * Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of\n     * an [Update](https://core.telegram.org/bots/api#update) with the field *pre_checkout_query*.\n     *\n     * **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.\n     *\n     * @param  {String} preCheckoutQueryId  Unique identifier for the query to be answered\n     * @param  {Boolean} ok Specify if every order details are ok\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, True is returned\n     * @see https://core.telegram.org/bots/api#answerprecheckoutquery\n     */\n\n  }, {\n    key: 'answerPreCheckoutQuery',\n    value: function answerPreCheckoutQuery(preCheckoutQueryId, ok) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.pre_checkout_query_id = preCheckoutQueryId;\n      form.ok = ok;\n      return this._request('answerPreCheckoutQuery', { form: form });\n    }\n\n    /**\n     * Use this method to send a game.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} gameShortName name of the game to be sent. Set up your games via `@BotFather`.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n     * @see https://core.telegram.org/bots/api#sendgame\n     */\n\n  }, {\n    key: 'sendGame',\n    value: function sendGame(chatId, gameShortName) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.game_short_name = gameShortName;\n      return this._request('sendGame', { form: form });\n    }\n\n    /**\n     * Use this method to set the score of the specified user in a game message.\n     *\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Number} score New score value, must be non-negative\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, if the message is not an inline message, the [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n     * @see https://core.telegram.org/bots/api#setgamescore\n     */\n\n  }, {\n    key: 'setGameScore',\n    value: function setGameScore(userId, score) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.user_id = userId;\n      form.score = score;\n      return this._request('setGameScore', { form: form });\n    }\n\n    /**\n     * Use this method to get data for high score tables.\n     *\n     * Will return the score of the specified user and several of their neighbors in a game.\n     *\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, returns an Array of [GameHighScore](https://core.telegram.org/bots/api#gamehighscore) objects\n     * @see https://core.telegram.org/bots/api#getgamehighscores\n     */\n\n  }, {\n    key: 'getGameHighScores',\n    value: function getGameHighScores(userId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.user_id = userId;\n      return this._request('getGameHighScores', { form: form });\n    }\n\n    /**\n    * Use this method to delete a message, including service messages, with the following limitations:\n    * - A message can only be deleted if it was sent less than 48 hours ago.\n    * - A dice message can only be deleted if it was sent more than 24 hours ago.\n    * - Bots can delete outgoing messages in groups and supergroups.\n    * - Bots can delete incoming messages in groups, supergroups and channels.\n    * - Bots granted `can_post_messages` permissions can delete outgoing messages in channels.\n    * - If the bot is an administrator of a group, it can delete any message there.\n    * - If the bot has `can_delete_messages` permission in a supergroup, it can delete any message there.\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n    * @param  {Number} messageId  Unique identifier of the target message\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#deletemessage\n    */\n\n  }, {\n    key: 'deleteMessage',\n    value: function deleteMessage(chatId, messageId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_id = messageId;\n      return this._request('deleteMessage', { form: form });\n    }\n\n    /**\n     * Use this method to delete multiple messages simultaneously. If some of the specified messages can't be found, they are skipped.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n     * @param  {Array<Number|String>} messageIds  Identifiers of 1-100 messages to delete. See deleteMessage for limitations on which messages can be deleted\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise<Boolean>} True on success\n     * @see https://core.telegram.org/bots/api#deletemessages\n     */\n\n  }, {\n    key: 'deleteMessages',\n    value: function deleteMessages(chatId, messageIds) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_ids = stringify(messageIds);\n      return this._request('deleteMessages', { form: form });\n    }\n  }]);\n\n  return TelegramBot;\n}(EventEmitter);\n\nmodule.exports = TelegramBot;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi90ZWxlZ3JhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixxR0FBcUcscUJBQXFCLG1CQUFtQjs7QUFFN0ksbUNBQW1DLGlDQUFpQyxlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSwyQ0FBMkMsVUFBVSxzQkFBc0IsZUFBZSwyQkFBMkIsMEJBQTBCLGNBQWMsMkNBQTJDLGdDQUFnQyxPQUFPLG1GQUFtRjs7QUFFcnBCLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVqakIsc0RBQXNELGtEQUFrRCw4REFBOEQsMEJBQTBCLDRDQUE0Qyx1QkFBdUIsb0JBQW9CLE9BQU8sNENBQTRDLDRCQUE0QixxQkFBcUIsT0FBTyx1QkFBdUIsNEJBQTRCLG9CQUFvQjs7QUFFemMsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRXBNLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLGtEQUFrRCxhQUFhLHlGQUF5Rjs7QUFFeEosMkNBQTJDLCtEQUErRCx1R0FBdUcseUVBQXlFLGVBQWUsMEVBQTBFLEdBQUc7O0FBRXRYO0FBQ0Esc0hBQXlDLElBQUk7O0FBRTdDLGFBQWEsbUJBQU8sQ0FBQywwRUFBVTtBQUMvQix5QkFBeUIsbUJBQU8sQ0FBQyw0RkFBbUI7QUFDcEQseUJBQXlCLG1CQUFPLENBQUMsNEZBQW1CO0FBQ3BELFlBQVksbUJBQU8sQ0FBQyx5RkFBTztBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyxrRUFBZTtBQUMxQyxlQUFlLG1CQUFPLENBQUMsMERBQVc7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLHlGQUEwQjtBQUNo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QUFZO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLHNCQUFzQjtBQUN0QyxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG9saXN0LXdlYi8uL25vZGVfbW9kdWxlcy9ub2RlLXRlbGVncmFtLWJvdC1hcGkvbGliL3RlbGVncmFtLmpzP2JiMjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIHNoaW1zXG5yZXF1aXJlKCdhcnJheS5wcm90b3R5cGUuZmluZGluZGV4Jykuc2hpbSgpOyAvLyBmb3IgTm9kZS5qcyB2MC54XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIFRlbGVncmFtQm90V2ViSG9vayA9IHJlcXVpcmUoJy4vdGVsZWdyYW1XZWJIb29rJyk7XG52YXIgVGVsZWdyYW1Cb3RQb2xsaW5nID0gcmVxdWlyZSgnLi90ZWxlZ3JhbVBvbGxpbmcnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ25vZGUtdGVsZWdyYW0tYm90LWFwaScpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcbnZhciBmaWxlVHlwZSA9IHJlcXVpcmUoJ2ZpbGUtdHlwZScpO1xudmFyIHJlcXVlc3QgPSByZXF1aXJlKCdAY3lwcmVzcy9yZXF1ZXN0LXByb21pc2UnKTtcbnZhciBzdHJlYW1lZFJlcXVlc3QgPSByZXF1aXJlKCdAY3lwcmVzcy9yZXF1ZXN0Jyk7XG52YXIgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIG1pbWUgPSByZXF1aXJlKCdtaW1lJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBVUkwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcHVtcCA9IHJlcXVpcmUoJ3B1bXAnKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCcuL3V0aWxzJykuZGVwcmVjYXRlO1xuXG52YXIgX21lc3NhZ2VUeXBlcyA9IFsndGV4dCcsICdhbmltYXRpb24nLCAnYXVkaW8nLCAnY2hhbm5lbF9jaGF0X2NyZWF0ZWQnLCAnY29udGFjdCcsICdkZWxldGVfY2hhdF9waG90bycsICdkaWNlJywgJ2RvY3VtZW50JywgJ2dhbWUnLCAnZ3JvdXBfY2hhdF9jcmVhdGVkJywgJ2ludm9pY2UnLCAnbGVmdF9jaGF0X21lbWJlcicsICdsb2NhdGlvbicsICdtaWdyYXRlX2Zyb21fY2hhdF9pZCcsICdtaWdyYXRlX3RvX2NoYXRfaWQnLCAnbmV3X2NoYXRfbWVtYmVycycsICduZXdfY2hhdF9waG90bycsICduZXdfY2hhdF90aXRsZScsICdwYXNzcG9ydF9kYXRhJywgJ3Bob3RvJywgJ3Bpbm5lZF9tZXNzYWdlJywgJ3BvbGwnLCAnc3RpY2tlcicsICdzdWNjZXNzZnVsX3BheW1lbnQnLCAnc3VwZXJncm91cF9jaGF0X2NyZWF0ZWQnLCAndmlkZW8nLCAndmlkZW9fbm90ZScsICd2b2ljZScsICd2aWRlb19jaGF0X3N0YXJ0ZWQnLCAndmlkZW9fY2hhdF9lbmRlZCcsICd2aWRlb19jaGF0X3BhcnRpY2lwYW50c19pbnZpdGVkJywgJ3ZpZGVvX2NoYXRfc2NoZWR1bGVkJywgJ21lc3NhZ2VfYXV0b19kZWxldGVfdGltZXJfY2hhbmdlZCcsICdjaGF0X2ludml0ZV9saW5rJywgJ2NoYXRfbWVtYmVyX3VwZGF0ZWQnLCAnd2ViX2FwcF9kYXRhJywgJ21lc3NhZ2VfcmVhY3Rpb24nXTtcblxudmFyIF9kZXByZWNhdGVkTWVzc2FnZVR5cGVzID0gWyduZXdfY2hhdF9wYXJ0aWNpcGFudCcsICdsZWZ0X2NoYXRfcGFydGljaXBhbnQnXTtcblxuLyoqXG4gKiBKU09OLXNlcmlhbGl6ZSBkYXRhLiBJZiB0aGUgcHJvdmlkZWQgZGF0YSBpcyBhbHJlYWR5IGEgU3RyaW5nLFxuICogcmV0dXJuIGl0IGFzIGlzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgeyp9IGRhdGFcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cblxudmFyIFRlbGVncmFtQm90ID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKFRlbGVncmFtQm90LCBfRXZlbnRFbWl0dGVyKTtcblxuICBfY3JlYXRlQ2xhc3MoVGVsZWdyYW1Cb3QsIFt7XG4gICAga2V5OiAnb24nLFxuXG5cbiAgICAvKipcbiAgICAgKiBBZGQgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgW2V2ZW50XShodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNldmVudHMpLlxuICAgICAqIFRoaXMgaXMgdGhlIHVzdWFsIGBlbWl0dGVyLm9uKClgIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjZXZlbnRzfEF2YWlsYWJsZSBldmVudHN9XG4gICAgICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19lbWl0dGVyX29uX2V2ZW50bmFtZV9saXN0ZW5lclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgIGlmIChfZGVwcmVjYXRlZE1lc3NhZ2VUeXBlcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHVybCA9ICdodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNldmVudHMnO1xuICAgICAgICBkZXByZWNhdGUoJ0V2ZW50cyAnICsgX2RlcHJlY2F0ZWRNZXNzYWdlVHlwZXMuam9pbignLCcpICsgJyBhcmUgZGVwcmVjYXRlZC4gU2VlIHRoZSB1cGRhdGVkIGxpc3Qgb2YgZXZlbnRzOiAnICsgdXJsKTtcbiAgICAgIH1cbiAgICAgIF9nZXQoVGVsZWdyYW1Cb3QucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGVsZWdyYW1Cb3QucHJvdG90eXBlKSwgJ29uJywgdGhpcykuY2FsbCh0aGlzLCBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJvdGggcmVxdWVzdCBtZXRob2QgdG8gb2J0YWluIG1lc3NhZ2VzIGFyZSBpbXBsZW1lbnRlZC4gVG8gdXNlIHN0YW5kYXJkIHBvbGxpbmcsIHNldCBgcG9sbGluZzogdHJ1ZWBcbiAgICAgKiBvbiBgb3B0aW9uc2AuIE5vdGljZSB0aGF0IFt3ZWJIb29rXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHdlYmhvb2spIHdpbGwgbmVlZCBhIFNTTCBjZXJ0aWZpY2F0ZS5cbiAgICAgKiBFbWl0cyBgbWVzc2FnZWAgd2hlbiBhIG1lc3NhZ2UgYXJyaXZlcy5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBUZWxlZ3JhbUJvdFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBCb3QgVG9rZW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gW29wdGlvbnMucG9sbGluZz1mYWxzZV0gU2V0IHRydWUgdG8gZW5hYmxlIHBvbGxpbmcgb3Igc2V0IG9wdGlvbnMuXG4gICAgICogIElmIGEgV2ViSG9vayBoYXMgYmVlbiBzZXQsIGl0IHdpbGwgYmUgZGVsZXRlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW29wdGlvbnMucG9sbGluZy50aW1lb3V0PTEwXSAqRGVwcmVjYXRlZC4gVXNlIGBvcHRpb25zLnBvbGxpbmcucGFyYW1zYCBpbnN0ZWFkKi5cbiAgICAgKiAgVGltZW91dCBpbiBzZWNvbmRzIGZvciBsb25nIHBvbGxpbmcuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50ZXN0RW52aXJvbm1lbnQ9ZmFsc2VdIFNldCB0cnVlIHRvICB3b3JrIHdpdGggdGVzdCBlbnZpcm9tZW50LlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIHRoZSB0ZXN0IGVudmlyb25tZW50LCB5b3UgbWF5IHVzZSBIVFRQIGxpbmtzIHdpdGhvdXQgVExTIHRvIHRlc3QgeW91ciBXZWIgQXBwLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW29wdGlvbnMucG9sbGluZy5pbnRlcnZhbD0zMDBdIEludGVydmFsIGJldHdlZW4gcmVxdWVzdHMgaW4gbWlsaXNlY29uZHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBvbGxpbmcuYXV0b1N0YXJ0PXRydWVdIFN0YXJ0IHBvbGxpbmcgaW1tZWRpYXRlbHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9sbGluZy5wYXJhbXNdIFBhcmFtZXRlcnMgdG8gYmUgdXNlZCBpbiBwb2xsaW5nIEFQSSByZXF1ZXN0cy5cbiAgICAgKiAgU2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0dXBkYXRlcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnBvbGxpbmcucGFyYW1zLnRpbWVvdXQ9MTBdIFRpbWVvdXQgaW4gc2Vjb25kcyBmb3IgbG9uZyBwb2xsaW5nLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IFtvcHRpb25zLndlYkhvb2s9ZmFsc2VdIFNldCB0cnVlIHRvIGVuYWJsZSBXZWJIb29rIG9yIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndlYkhvb2suaG9zdD1cIjAuMC4wLjBcIl0gSG9zdCB0byBiaW5kIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndlYkhvb2sucG9ydD04NDQzXSBQb3J0IHRvIGJpbmQgdG9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2ViSG9vay5rZXldIFBhdGggdG8gZmlsZSB3aXRoIFBFTSBwcml2YXRlIGtleSBmb3Igd2ViSG9vayBzZXJ2ZXIuXG4gICAgICogIFRoZSBmaWxlIGlzIHJlYWQgKipzeW5jaHJvbm91c2x5KiohXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndlYkhvb2suY2VydF0gUGF0aCB0byBmaWxlIHdpdGggUEVNIGNlcnRpZmljYXRlIChwdWJsaWMpIGZvciB3ZWJIb29rIHNlcnZlci5cbiAgICAgKiAgVGhlIGZpbGUgaXMgcmVhZCAqKnN5bmNocm9ub3VzbHkqKiFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2ViSG9vay5wZnhdIFBhdGggdG8gZmlsZSB3aXRoIFBGWCBwcml2YXRlIGtleSBhbmQgY2VydGlmaWNhdGUgY2hhaW4gZm9yIHdlYkhvb2sgc2VydmVyLlxuICAgICAqICBUaGUgZmlsZSBpcyByZWFkICoqc3luY2hyb25vdXNseSoqIVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2ViSG9vay5hdXRvT3Blbj10cnVlXSBPcGVuIHdlYkhvb2sgaW1tZWRpYXRlbHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud2ViSG9vay5odHRwc10gT3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gYGh0dHBzLmNyZWF0ZVNlcnZlcigpYC5cbiAgICAgKiAgTm90ZSB0aGF0IGBvcHRpb25zLndlYkhvb2sua2V5YCwgYG9wdGlvbnMud2ViSG9vay5jZXJ0YCBhbmQgYG9wdGlvbnMud2ViSG9vay5wZnhgLCBpZiBwcm92aWRlZCwgd2lsbCBiZVxuICAgICAqICB1c2VkIHRvIG92ZXJyaWRlIGBrZXlgLCBgY2VydGAgYW5kIGBwZnhgIGluIHRoaXMgb2JqZWN0LCByZXNwZWN0aXZlbHkuXG4gICAgICogIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHBzLmh0bWwjaHR0cHNfaHR0cHNfY3JlYXRlc2VydmVyX29wdGlvbnNfcmVxdWVzdGxpc3RlbmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53ZWJIb29rLmhlYWx0aEVuZHBvaW50PVwiL2hlYWx0aHpcIl0gQW4gZW5kcG9pbnQgZm9yIGhlYWx0aCBjaGVja3MgdGhhdCBhbHdheXMgcmVzcG9uZHMgd2l0aCAyMDAgT0tcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9ubHlGaXJzdE1hdGNoPWZhbHNlXSBTZXQgdG8gdHJ1ZSB0byBzdG9wIGFmdGVyIGZpcnN0IG1hdGNoLiBPdGhlcndpc2UsIGFsbCByZWdleHBzIGFyZSBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5yZXF1ZXN0XSBPcHRpb25zIHdoaWNoIHdpbGwgYmUgYWRkZWQgZm9yIGFsbCByZXF1ZXN0cyB0byB0ZWxlZ3JhbSBhcGkuXG4gICAgICogIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVxdWVzdC9yZXF1ZXN0I3JlcXVlc3RvcHRpb25zLWNhbGxiYWNrIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5iYXNlQXBpVXJsPVwiaHR0cHM6Ly9hcGkudGVsZWdyYW0ub3JnXCJdIEFQSSBCYXNlIFVSbDsgdXNlZnVsIGZvciBwcm94eWluZyBhbmQgdGVzdGluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmlsZXBhdGg9dHJ1ZV0gQWxsb3cgcGFzc2luZyBmaWxlLXBhdGhzIGFzIGFyZ3VtZW50cyB3aGVuIHNlbmRpbmcgZmlsZXMsXG4gICAgICogIHN1Y2ggYXMgcGhvdG9zIHVzaW5nIGBUZWxlZ3JhbUJvdCNzZW5kUGhvdG8oKWAuIFNlZSBbdXNhZ2UgaW5mb3JtYXRpb25dW3VzYWdlLXNlbmRpbmctZmlsZXMtcGVyZm9ybWFuY2VdXG4gICAgICogIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoaXMgb3B0aW9uIGFuZCBpdHMgY29uc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmFkUmVqZWN0aW9uPWZhbHNlXSBTZXQgdG8gYHRydWVgXG4gICAgICogICoqaWYgYW5kIG9ubHkgaWYqKiB0aGUgTm9kZS5qcyB2ZXJzaW9uIHlvdSdyZSB1c2luZyB0ZXJtaW5hdGVzIHRoZVxuICAgICAqICBwcm9jZXNzIG9uIHVuaGFuZGxlZCByZWplY3Rpb25zLiBUaGlzIG9wdGlvbiBpcyBvbmx5IGZvclxuICAgICAqICAqZm9yd2FyZC1jb21wYXRpYmlsaXR5IHB1cnBvc2VzKi5cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGlcbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6ICdlcnJvcnMnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRpZmZlcmVudCBlcnJvcnMgdGhlIGxpYnJhcnkgdXNlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZXMgb2YgbWVzc2FnZSB1cGRhdGVzIHRoZSBsaWJyYXJ5IGhhbmRsZXMuXG4gICAgICogQHR5cGUge1N0cmluZ1tdfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtZXNzYWdlVHlwZXMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9tZXNzYWdlVHlwZXM7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gVGVsZWdyYW1Cb3QodG9rZW4pIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVsZWdyYW1Cb3QpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRlbGVncmFtQm90Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGVsZWdyYW1Cb3QpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLnRva2VuID0gdG9rZW47XG4gICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgX3RoaXMub3B0aW9ucy5wb2xsaW5nID0gdHlwZW9mIG9wdGlvbnMucG9sbGluZyA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IG9wdGlvbnMucG9sbGluZztcbiAgICBfdGhpcy5vcHRpb25zLndlYkhvb2sgPSB0eXBlb2Ygb3B0aW9ucy53ZWJIb29rID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogb3B0aW9ucy53ZWJIb29rO1xuICAgIF90aGlzLm9wdGlvbnMuYmFzZUFwaVVybCA9IG9wdGlvbnMuYmFzZUFwaVVybCB8fCAnaHR0cHM6Ly9hcGkudGVsZWdyYW0ub3JnJztcbiAgICBfdGhpcy5vcHRpb25zLmZpbGVwYXRoID0gdHlwZW9mIG9wdGlvbnMuZmlsZXBhdGggPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuZmlsZXBhdGg7XG4gICAgX3RoaXMub3B0aW9ucy5iYWRSZWplY3Rpb24gPSB0eXBlb2Ygb3B0aW9ucy5iYWRSZWplY3Rpb24gPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiBvcHRpb25zLmJhZFJlamVjdGlvbjtcbiAgICBfdGhpcy5fdGV4dFJlZ2V4cENhbGxiYWNrcyA9IFtdO1xuICAgIF90aGlzLl9yZXBseUxpc3RlbmVySWQgPSAwO1xuICAgIF90aGlzLl9yZXBseUxpc3RlbmVycyA9IFtdO1xuICAgIF90aGlzLl9wb2xsaW5nID0gbnVsbDtcbiAgICBfdGhpcy5fd2ViSG9vayA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5wb2xsaW5nKSB7XG4gICAgICB2YXIgYXV0b1N0YXJ0ID0gb3B0aW9ucy5wb2xsaW5nLmF1dG9TdGFydDtcbiAgICAgIGlmICh0eXBlb2YgYXV0b1N0YXJ0ID09PSAndW5kZWZpbmVkJyB8fCBhdXRvU3RhcnQgPT09IHRydWUpIHtcbiAgICAgICAgX3RoaXMuc3RhcnRQb2xsaW5nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMud2ViSG9vaykge1xuICAgICAgdmFyIGF1dG9PcGVuID0gb3B0aW9ucy53ZWJIb29rLmF1dG9PcGVuO1xuICAgICAgaWYgKHR5cGVvZiBhdXRvT3BlbiA9PT0gJ3VuZGVmaW5lZCcgfHwgYXV0b09wZW4gPT09IHRydWUpIHtcbiAgICAgICAgX3RoaXMub3BlbldlYkhvb2soKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB1cmwgd2l0aCBib3QgdG9rZW4gYW5kIHByb3ZpZGVkIHBhdGgvbWV0aG9kIHlvdSB3YW50IHRvIGJlIGdvdC9leGVjdXRlZCBieSBib3RcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdXJsXG4gICAqIEBwcml2YXRlXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtYWtpbmctcmVxdWVzdHNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVGVsZWdyYW1Cb3QsIFt7XG4gICAga2V5OiAnX2J1aWxkVVJMJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2J1aWxkVVJMKF9wYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJhc2VBcGlVcmwgKyAnL2JvdCcgKyB0aGlzLnRva2VuICsgKHRoaXMub3B0aW9ucy50ZXN0RW52aXJvbm1lbnQgPyAnL3Rlc3QnIDogJycpICsgJy8nICsgX3BhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRml4ICdyZXBseV9tYXJrdXAnIHBhcmFtZXRlciBieSBtYWtpbmcgaXQgSlNPTi1zZXJpYWxpemVkLCBhc1xuICAgICAqIHJlcXVpcmVkIGJ5IHRoZSBUZWxlZ3JhbSBCb3QgQVBJXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3Q7IGVpdGhlciAnZm9ybScgb3IgJ3FzJ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRtZXNzYWdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19maXhSZXBseU1hcmt1cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maXhSZXBseU1hcmt1cChvYmopIHtcbiAgICAgIHZhciByZXBseU1hcmt1cCA9IG9iai5yZXBseV9tYXJrdXA7XG4gICAgICBpZiAocmVwbHlNYXJrdXAgJiYgdHlwZW9mIHJlcGx5TWFya3VwICE9PSAnc3RyaW5nJykge1xuICAgICAgICBvYmoucmVwbHlfbWFya3VwID0gc3RyaW5naWZ5KHJlcGx5TWFya3VwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXggJ2VudGl0aWVzJyBvciAnY2FwdGlvbl9lbnRpdGllcycgb3IgJ2V4cGxhbmF0aW9uX2VudGl0aWVzJyBwYXJhbWV0ZXIgYnkgbWFraW5nIGl0IEpTT04tc2VyaWFsaXplZCwgYXNcbiAgICAgKiByZXF1aXJlZCBieSB0aGUgVGVsZWdyYW0gQm90IEFQSVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0O1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRtZXNzYWdlXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NvcHltZXNzYWdlXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRwb2xsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19maXhFbnRpdGllc0ZpZWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeEVudGl0aWVzRmllbGQob2JqKSB7XG4gICAgICB2YXIgZW50aXRpZXMgPSBvYmouZW50aXRpZXM7XG4gICAgICB2YXIgY2FwdGlvbkVudGl0aWVzID0gb2JqLmNhcHRpb25fZW50aXRpZXM7XG4gICAgICB2YXIgZXhwbGFuYXRpb25FbnRpdGllcyA9IG9iai5leHBsYW5hdGlvbl9lbnRpdGllcztcbiAgICAgIGlmIChlbnRpdGllcyAmJiB0eXBlb2YgZW50aXRpZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9iai5lbnRpdGllcyA9IHN0cmluZ2lmeShlbnRpdGllcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXB0aW9uRW50aXRpZXMgJiYgdHlwZW9mIGNhcHRpb25FbnRpdGllcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqLmNhcHRpb25fZW50aXRpZXMgPSBzdHJpbmdpZnkoY2FwdGlvbkVudGl0aWVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cGxhbmF0aW9uRW50aXRpZXMgJiYgdHlwZW9mIGV4cGxhbmF0aW9uRW50aXRpZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9iai5leHBsYW5hdGlvbl9lbnRpdGllcyA9IHN0cmluZ2lmeShleHBsYW5hdGlvbkVudGl0aWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZml4QWRkRmlsZVRodW1ibmFpbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maXhBZGRGaWxlVGh1bWJuYWlsKG9wdGlvbnMsIG9wdHMpIHtcbiAgICAgIGlmIChvcHRpb25zLnRodW1iKSB7XG4gICAgICAgIGlmIChvcHRzLmZvcm1EYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dGFjaE5hbWUgPSAncGhvdG8nO1xuXG4gICAgICAgIHZhciBfZm9ybWF0U2VuZERhdGEyID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoYXR0YWNoTmFtZSwgb3B0aW9ucy50aHVtYi5yZXBsYWNlKCdhdHRhY2g6Ly8nLCAnJykpLFxuICAgICAgICAgICAgX2Zvcm1hdFNlbmREYXRhMyA9IF9zbGljZWRUb0FycmF5KF9mb3JtYXRTZW5kRGF0YTIsIDEpLFxuICAgICAgICAgICAgZm9ybURhdGEgPSBfZm9ybWF0U2VuZERhdGEzWzBdO1xuXG4gICAgICAgIGlmIChmb3JtRGF0YSkge1xuICAgICAgICAgIG9wdHMuZm9ybURhdGFbYXR0YWNoTmFtZV0gPSBmb3JtRGF0YVthdHRhY2hOYW1lXTtcbiAgICAgICAgICBvcHRzLnFzLnRodW1ibmFpbCA9ICdhdHRhY2g6Ly8nICsgYXR0YWNoTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpeCAncmVwbHlfcGFyYW1ldGVycycgcGFyYW1ldGVyIGJ5IG1ha2luZyBpdCBKU09OLXNlcmlhbGl6ZWQsIGFzXG4gICAgICogcmVxdWlyZWQgYnkgdGhlIFRlbGVncmFtIEJvdCBBUElcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdDsgZWl0aGVyICdmb3JtJyBvciAncXMnXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZG1lc3NhZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZpeFJlcGx5UGFyYW1ldGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maXhSZXBseVBhcmFtZXRlcnMob2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCdyZXBseV9wYXJhbWV0ZXJzJykgJiYgdHlwZW9mIG9iai5yZXBseV9wYXJhbWV0ZXJzICE9PSAnc3RyaW5nJykge1xuICAgICAgICBvYmoucmVwbHlfcGFyYW1ldGVycyA9IHN0cmluZ2lmeShvYmoucmVwbHlfcGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSByZXF1ZXN0IGFnYWluc3QgdGhlIEFQSVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gX3BhdGggQVBJIGVuZHBvaW50XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19yZXF1ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVlc3QoX3BhdGgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgaWYgKCF0aGlzLnRva2VuKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3JzLkZhdGFsRXJyb3IoJ1RlbGVncmFtIEJvdCBUb2tlbiBub3QgcHJvdmlkZWQhJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlcXVlc3QpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLm9wdGlvbnMucmVxdWVzdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZvcm0pIHtcbiAgICAgICAgdGhpcy5fZml4UmVwbHlNYXJrdXAob3B0aW9ucy5mb3JtKTtcbiAgICAgICAgdGhpcy5fZml4RW50aXRpZXNGaWVsZChvcHRpb25zLmZvcm0pO1xuICAgICAgICB0aGlzLl9maXhSZXBseVBhcmFtZXRlcnMob3B0aW9ucy5mb3JtKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnFzKSB7XG4gICAgICAgIHRoaXMuX2ZpeFJlcGx5TWFya3VwKG9wdGlvbnMucXMpO1xuICAgICAgICB0aGlzLl9maXhSZXBseVBhcmFtZXRlcnMob3B0aW9ucy5xcyk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgb3B0aW9ucy51cmwgPSB0aGlzLl9idWlsZFVSTChfcGF0aCk7XG4gICAgICBvcHRpb25zLnNpbXBsZSA9IGZhbHNlO1xuICAgICAgb3B0aW9ucy5yZXNvbHZlV2l0aEZ1bGxSZXNwb25zZSA9IHRydWU7XG4gICAgICBvcHRpb25zLmZvcmV2ZXIgPSB0cnVlO1xuICAgICAgZGVidWcoJ0hUVFAgcmVxdWVzdDogJWonLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiByZXF1ZXN0KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgdmFyIGRhdGEgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IHJlc3AuYm9keSA9IEpTT04ucGFyc2UocmVzcC5ib2R5KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5QYXJzZUVycm9yKCdFcnJvciBwYXJzaW5nIHJlc3BvbnNlOiAnICsgcmVzcC5ib2R5LCByZXNwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLm9rKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5UZWxlZ3JhbUVycm9yKGRhdGEuZXJyb3JfY29kZSArICcgJyArIGRhdGEuZGVzY3JpcHRpb24sIHJlc3ApO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIFRPRE86IHdoeSBjYW4ndCB3ZSBkbyBgZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnMuQmFzZUVycm9yYD9cbiAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlKSB0aHJvdyBlcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5GYXRhbEVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBkYXRhIHRvIGJlIHVwbG9hZGVkOyBoYW5kbGVzIGZpbGUgcGF0aHMsIHN0cmVhbXMgYW5kIGJ1ZmZlcnNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IGRhdGFcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGZpbGVPcHRpb25zIEZpbGUgb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW2ZpbGVPcHRpb25zLmZpbGVuYW1lXSBGaWxlIG5hbWVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtmaWxlT3B0aW9ucy5jb250ZW50VHlwZV0gQ29udGVudCB0eXBlIChpLmUuIE1JTUUpXG4gICAgICogQHJldHVybiB7QXJyYXl9IGZvcm1hdHRlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZm9ybWF0dGVkWzBdIGZvcm1EYXRhXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWRbMV0gZmlsZUlkXG4gICAgICogQHRocm93cyBFcnJvciBpZiBCdWZmZXIgZmlsZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICogQHNlZSBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2ZpbGUtdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19mb3JtYXRTZW5kRGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mb3JtYXRTZW5kRGF0YSh0eXBlLCBkYXRhKSB7XG4gICAgICB2YXIgZmlsZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICB2YXIgZGVwcmVjYXRpb25NZXNzYWdlID0gJ1NlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzJyArICcgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHNlbmRpbmcgZmlsZXMgaGFzIGJlZW4gaW1wcm92ZWQgYW5kJyArICcgb24gaG93IHRvIGRpc2FibGUgdGhpcyBkZXByZWNhdGlvbiBtZXNzYWdlIGFsdG9nZXRoZXIuJztcbiAgICAgIHZhciBmaWxlZGF0YSA9IGRhdGE7XG4gICAgICB2YXIgZmlsZW5hbWUgPSBmaWxlT3B0aW9ucy5maWxlbmFtZTtcbiAgICAgIHZhciBjb250ZW50VHlwZSA9IGZpbGVPcHRpb25zLmNvbnRlbnRUeXBlO1xuXG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIHN0cmVhbS5TdHJlYW0pIHtcbiAgICAgICAgaWYgKCFmaWxlbmFtZSAmJiBkYXRhLnBhdGgpIHtcbiAgICAgICAgICAvLyBXaWxsIGJlICdudWxsJyBpZiBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICAgICAgICAgIC8vIEZvciBleGFtcGxlLCAnZGF0YS5wYXRoJyA9PT0gJy8/aWQ9MTIzJyBmcm9tICdyZXF1ZXN0KFwiaHR0cHM6Ly9leGFtcGxlLmNvbS8/aWQ9MTIzXCIpJ1xuICAgICAgICAgIHZhciB1cmwgPSBVUkwucGFyc2UocGF0aC5iYXNlbmFtZShkYXRhLnBhdGgudG9TdHJpbmcoKSkpO1xuICAgICAgICAgIGlmICh1cmwucGF0aG5hbWUpIHtcbiAgICAgICAgICAgIGZpbGVuYW1lID0gcXMudW5lc2NhcGUodXJsLnBhdGhuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIGlmICghZmlsZW5hbWUgJiYgIXByb2Nlc3MuZW52Lk5UQkFfRklYXzM1MCkge1xuICAgICAgICAgIGRlcHJlY2F0ZSgnQnVmZmVycyB3aWxsIGhhdmUgdGhlaXIgZmlsZW5hbWVzIGRlZmF1bHQgdG8gXCJmaWxlbmFtZVwiIGluc3RlYWQgb2YgXCJkYXRhXCIuICcgKyBkZXByZWNhdGlvbk1lc3NhZ2UpO1xuICAgICAgICAgIGZpbGVuYW1lID0gJ2RhdGEnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgICB2YXIgZmlsZXR5cGUgPSBmaWxlVHlwZShkYXRhKTtcbiAgICAgICAgICBpZiAoZmlsZXR5cGUpIHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gZmlsZXR5cGUubWltZTtcbiAgICAgICAgICAgIHZhciBleHQgPSBmaWxldHlwZS5leHQ7XG4gICAgICAgICAgICBpZiAoZXh0ICYmICFwcm9jZXNzLmVudi5OVEJBX0ZJWF8zNTApIHtcbiAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZSArICcuJyArIGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFwcm9jZXNzLmVudi5OVEJBX0ZJWF8zNTApIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZSgnQW4gZXJyb3Igd2lsbCBubyBsb25nZXIgYmUgdGhyb3duIGlmIGZpbGUtdHlwZSBvZiBidWZmZXIgY291bGQgbm90IGJlIGRldGVjdGVkLiAnICsgZGVwcmVjYXRpb25NZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRmF0YWxFcnJvcignVW5zdXBwb3J0ZWQgQnVmZmVyIGZpbGUtdHlwZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsZXBhdGggJiYgZnMuZXhpc3RzU3luYyhkYXRhKSkge1xuICAgICAgICAgIGZpbGVkYXRhID0gZnMuY3JlYXRlUmVhZFN0cmVhbShkYXRhKTtcbiAgICAgICAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbbnVsbCwgZGF0YV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgZGF0YV07XG4gICAgICB9XG5cbiAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUgfHwgJ2ZpbGVuYW1lJztcbiAgICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgfHwgbWltZS5sb29rdXAoZmlsZW5hbWUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5UQkFfRklYXzM1MCkge1xuICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwcmVjYXRlKCdJbiB0aGUgZnV0dXJlLCBjb250ZW50LXR5cGUgb2YgZmlsZXMgeW91IHNlbmQgd2lsbCBkZWZhdWx0IHRvIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIuICcgKyBkZXByZWNhdGlvbk1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBBZGQgbWlzc2luZyBmaWxlIGV4dGVuc2lvbi5cblxuICAgICAgcmV0dXJuIFtfZGVmaW5lUHJvcGVydHkoe30sIHR5cGUsIHtcbiAgICAgICAgdmFsdWU6IGZpbGVkYXRhLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZVxuICAgICAgICB9XG4gICAgICB9KSwgbnVsbF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgcG9sbGluZy5cbiAgICAgKiBSZWplY3RzIHJldHVybmVkIHByb21pc2UgaWYgYSBXZWJIb29rIGlzIGJlaW5nIHVzZWQgYnkgdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnJlc3RhcnQ9dHJ1ZV0gQ29uc2VjdXRpdmUgY2FsbHMgdG8gdGhpcyBtZXRob2QgY2F1c2VzIHBvbGxpbmcgdG8gYmUgcmVzdGFydGVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3RhcnRQb2xsaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRQb2xsaW5nKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAodGhpcy5oYXNPcGVuV2ViSG9vaygpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3JzLkZhdGFsRXJyb3IoJ1BvbGxpbmcgYW5kIFdlYkhvb2sgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZScpKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMucmVzdGFydCA9IHR5cGVvZiBvcHRpb25zLnJlc3RhcnQgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMucmVzdGFydDtcbiAgICAgIGlmICghdGhpcy5fcG9sbGluZykge1xuICAgICAgICB0aGlzLl9wb2xsaW5nID0gbmV3IFRlbGVncmFtQm90UG9sbGluZyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9wb2xsaW5nLnN0YXJ0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIGBUZWxlZ3JhbUJvdCNzdGFydFBvbGxpbmcoKWAuIFRoaXMgaXMgKipkZXByZWNhdGVkKiouXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luaXRQb2xsaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFBvbGxpbmcoKSB7XG4gICAgICBkZXByZWNhdGUoJ1RlbGVncmFtQm90I2luaXRQb2xsaW5nKCkgaXMgZGVwcmVjYXRlZC4gVXNlIFRlbGVncmFtQm90I3N0YXJ0UG9sbGluZygpIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyBwb2xsaW5nIGFmdGVyIHRoZSBsYXN0IHBvbGxpbmcgcmVxdWVzdCByZXNvbHZlcy5cbiAgICAgKiBNdWx0aXBsZSBpbnZvY2F0aW9ucyBkbyBub3RoaW5nIGlmIHBvbGxpbmcgaXMgYWxyZWFkeSBzdG9wcGVkLlxuICAgICAqIFJldHVybmluZyB0aGUgcHJvbWlzZSBvZiB0aGUgbGFzdCBwb2xsaW5nIHJlcXVlc3QgaXMgKipkZXByZWNhdGVkKiouXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmNhbmNlbF0gQ2FuY2VsIGN1cnJlbnQgcmVxdWVzdFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMucmVhc29uXSBSZWFzb24gZm9yIHN0b3BwaW5nIHBvbGxpbmdcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzdG9wUG9sbGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BQb2xsaW5nKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5fcG9sbGluZykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcG9sbGluZy5zdG9wKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBsaW5rIGZvciBmaWxlLlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgbGluayBmb3IgZmlsZSBmb3Igc3Vic2VxdWVudCB1c2UuXG4gICAgICogQXR0ZW50aW9uOiBsaW5rIHdpbGwgYmUgdmFsaWQgZm9yIDEgaG91ci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGEgc3VnYXIgZXh0ZW5zaW9uIG9mIHRoZSAoZ2V0RmlsZSlbI2dldGZpbGVmaWxlaWRdIG1ldGhvZCxcbiAgICAgKiB3aGljaCByZXR1cm5zIGp1c3QgcGF0aCB0byBmaWxlIG9uIHJlbW90ZSBzZXJ2ZXIgKHlvdSB3aWxsIGhhdmUgdG8gbWFudWFsbHkgYnVpbGQgZnVsbCB1cmkgYWZ0ZXIgdGhhdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVJZCAgRmlsZSBpZGVudGlmaWVyIHRvIGdldCBpbmZvIGFib3V0XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB3aGljaCB3aWxsIGhhdmUgICpmaWxlVVJJKiBpbiByZXNvbHZlIGNhbGxiYWNrXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGZpbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0RmlsZUxpbmsnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWxlTGluayhmaWxlSWQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLmdldEZpbGUoZmlsZUlkLCBmb3JtKS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIub3B0aW9ucy5iYXNlQXBpVXJsICsgJy9maWxlL2JvdCcgKyBfdGhpczIudG9rZW4gKyAnLycgKyByZXNwLmZpbGVfcGF0aDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHJlYWRhYmxlIHN0cmVhbSBmb3IgZmlsZS5cbiAgICAgKlxuICAgICAqIGBmaWxlU3RyZWFtLnBhdGhgIGlzIHRoZSBzcGVjaWZpZWQgZmlsZSBJRCBpLmUuIGBmaWxlSWRgLlxuICAgICAqIGBmaWxlU3RyZWFtYCBlbWl0cyBldmVudCBgaW5mb2AgcGFzc2luZyBhIHNpbmdsZSBhcmd1bWVudCBpLmUuXG4gICAgICogYGluZm9gIHdpdGggdGhlIGludGVyZmFjZSBgeyB1cmkgfWAgd2hlcmUgYHVyaWAgaXMgdGhlIFVSSSBvZiB0aGVcbiAgICAgKiBmaWxlIG9uIFRlbGVncmFtIHNlcnZlcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhIHN1Z2FyIGV4dGVuc2lvbiBvZiB0aGUgW2dldEZpbGVMaW5rXSgjVGVsZWdyYW1Cb3QrZ2V0RmlsZUxpbmspIG1ldGhvZCxcbiAgICAgKiB3aGljaCByZXR1cm5zIHRoZSBmdWxsIFVSSSB0byB0aGUgZmlsZSBvbiByZW1vdGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBmaWxlSWQgRmlsZSBpZGVudGlmaWVyIHRvIGdldCBpbmZvIGFib3V0XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7c3RyZWFtLlJlYWRhYmxlfSBmaWxlU3RyZWFtXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEZpbGVTdHJlYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWxlU3RyZWFtKGZpbGVJZCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgdmFyIGZpbGVTdHJlYW0gPSBuZXcgc3RyZWFtLlBhc3NUaHJvdWdoKCk7XG4gICAgICBmaWxlU3RyZWFtLnBhdGggPSBmaWxlSWQ7XG4gICAgICB0aGlzLmdldEZpbGVMaW5rKGZpbGVJZCwgZm9ybSkudGhlbihmdW5jdGlvbiAoZmlsZVVSSSkge1xuICAgICAgICBmaWxlU3RyZWFtLmVtaXQoJ2luZm8nLCB7XG4gICAgICAgICAgdXJpOiBmaWxlVVJJXG4gICAgICAgIH0pO1xuICAgICAgICBwdW1wKHN0cmVhbWVkUmVxdWVzdChPYmplY3QuYXNzaWduKHsgdXJpOiBmaWxlVVJJIH0sIF90aGlzMy5vcHRpb25zLnJlcXVlc3QpKSwgZmlsZVN0cmVhbSk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgZmlsZVN0cmVhbS5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbGVTdHJlYW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGZpbGUgaW4gdGhlIHNwZWNpZmllZCBmb2xkZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhIHN1Z2FyIGV4dGVuc2lvbiBvZiB0aGUgW2dldEZpbGVTdHJlYW1dKCNUZWxlZ3JhbUJvdCtnZXRGaWxlU3RyZWFtKSBtZXRob2QsXG4gICAgICogd2hpY2ggcmV0dXJucyBhIHJlYWRhYmxlIGZpbGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBmaWxlSWQgIEZpbGUgaWRlbnRpZmllciB0byBnZXQgaW5mbyBhYm91dFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZG93bmxvYWREaXIgQWJzb2x1dGUgcGF0aCB0byB0aGUgZm9sZGVyIGluIHdoaWNoIGZpbGUgd2lsbCBiZSBzYXZlZFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UsIHdoaWNoIHdpbGwgaGF2ZSAqZmlsZVBhdGgqIG9mIGRvd25sb2FkZWQgZmlsZSBpbiByZXNvbHZlIGNhbGxiYWNrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rvd25sb2FkRmlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShmaWxlSWQsIGRvd25sb2FkRGlyKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHZhciByZXNvbHZlID0gdm9pZCAwO1xuICAgICAgdmFyIHJlamVjdCA9IHZvaWQgMDtcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmVzb2x2ZSA9IGE7XG4gICAgICAgIHJlamVjdCA9IGI7XG4gICAgICB9KTtcbiAgICAgIHZhciBmaWxlU3RyZWFtID0gdGhpcy5nZXRGaWxlU3RyZWFtKGZpbGVJZCwgZm9ybSk7XG4gICAgICBmaWxlU3RyZWFtLm9uKCdpbmZvJywgZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gaW5mby51cmkuc2xpY2UoaW5mby51cmkubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgICAvLyBUT0RPOiBFbnN1cmUgZmlsZU5hbWUgZG9lc24ndCBjb250YWlucyBzbGFzaGVzXG4gICAgICAgIHZhciBmaWxlUGF0aCA9IHBhdGguam9pbihkb3dubG9hZERpciwgZmlsZU5hbWUpO1xuICAgICAgICBwdW1wKGZpbGVTdHJlYW0sIGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZpbGVQYXRoKSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZVBhdGgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZmlsZVN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIFJlZ0V4cCB0byB0ZXN0IGFnYWluc3QgYW4gaW5jb21taW5nIHRleHQgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gIHtSZWdFeHB9ICAgcmVnZXhwUmV4ZWN1dGVkIHdpdGggYGV4ZWNgLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgQ2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCAyIHBhcmFtZXRlcnMsXG4gICAgICogdGhlIGBtc2dgIGFuZCB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBgcmVnZXhwLmV4ZWNgIG9uIG1lc3NhZ2UgdGV4dC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25UZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25UZXh0KHJlZ2V4cCwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX3RleHRSZWdleHBDYWxsYmFja3MucHVzaCh7IHJlZ2V4cDogcmVnZXhwLCBjYWxsYmFjazogY2FsbGJhY2sgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgcmVnaXN0ZXJlZCB3aXRoIGBvblRleHQoKWAuXG4gICAgICogQHBhcmFtICB7UmVnRXhwfSByZWdleHAgUmVnRXhwIHVzZWQgcHJldmlvdXNseSBpbiBgb25UZXh0KClgXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBkZWxldGVkTGlzdGVuZXIgVGhlIHJlbW92ZWQgcmVwbHkgbGlzdGVuZXIgaWZcbiAgICAgKiAgIGZvdW5kLiBUaGlzIG9iamVjdCBoYXMgYHJlZ2V4cGAgYW5kIGBjYWxsYmFja2BcbiAgICAgKiAgIHByb3BlcnRpZXMuIElmIG5vdCBmb3VuZCwgcmV0dXJucyBgbnVsbGAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZVRleHRMaXN0ZW5lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVRleHRMaXN0ZW5lcihyZWdleHApIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX3RleHRSZWdleHBDYWxsYmFja3MuZmluZEluZGV4KGZ1bmN0aW9uICh0ZXh0TGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0ZXh0TGlzdGVuZXIucmVnZXhwKSA9PT0gU3RyaW5nKHJlZ2V4cCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdGV4dFJlZ2V4cENhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgd2l0aCBgb25UZXh0KClgLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhclRleHRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclRleHRMaXN0ZW5lcnMoKSB7XG4gICAgICB0aGlzLl90ZXh0UmVnZXhwQ2FsbGJhY2tzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSByZXBseSB0byB3YWl0IGZvciBhIG1lc3NhZ2UgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVGhlIGNoYXQgaWQgd2hlcmUgdGhlIG1lc3NhZ2UgY2FtZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBtZXNzYWdlSWQgVGhlIG1lc3NhZ2UgaWQgdG8gYmUgcmVwbGllZC5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVwbHlcbiAgICAgKiAgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGlkIFRoZSBJRCBvZiB0aGUgaW5zZXJ0ZWQgcmVwbHkgbGlzdGVuZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uUmVwbHlUb01lc3NhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlcGx5VG9NZXNzYWdlKGNoYXRJZCwgbWVzc2FnZUlkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGlkID0gKyt0aGlzLl9yZXBseUxpc3RlbmVySWQ7XG4gICAgICB0aGlzLl9yZXBseUxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBjaGF0SWQ6IGNoYXRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHJlcGx5IHRoYXQgaGFzIGJlZW4gcHJldi4gcmVnaXN0ZXJlZCBmb3IgYSBtZXNzYWdlIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSAgIHtOdW1iZXJ9IHJlcGx5TGlzdGVuZXJJZCBUaGUgSUQgb2YgdGhlIHJlcGx5IGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm4gIHtPYmplY3R9IGRlbGV0ZWRMaXN0ZW5lciBUaGUgcmVtb3ZlZCByZXBseSBsaXN0ZW5lciBpZlxuICAgICAqICAgZm91bmQuIFRoaXMgb2JqZWN0IGhhcyBgaWRgLCBgY2hhdElkYCwgYG1lc3NhZ2VJZGAgYW5kIGBjYWxsYmFja2BcbiAgICAgKiAgIHByb3BlcnRpZXMuIElmIG5vdCBmb3VuZCwgcmV0dXJucyBgbnVsbGAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZVJlcGx5TGlzdGVuZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVSZXBseUxpc3RlbmVyKHJlcGx5TGlzdGVuZXJJZCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fcmVwbHlMaXN0ZW5lcnMuZmluZEluZGV4KGZ1bmN0aW9uIChyZXBseUxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiByZXBseUxpc3RlbmVyLmlkID09PSByZXBseUxpc3RlbmVySWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVwbHlMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCByZXBsaWVzIHRoYXQgaGF2ZSBiZWVuIHByZXYuIHJlZ2lzdGVyZWQgZm9yIGEgbWVzc2FnZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gIHtBcnJheX0gZGVsZXRlZExpc3RlbmVycyBBbiBhcnJheSBvZiByZW1vdmVkIGxpc3RlbmVycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xlYXJSZXBseUxpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyUmVwbHlMaXN0ZW5lcnMoKSB7XG4gICAgICB0aGlzLl9yZXBseUxpc3RlbmVycyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHBvbGxpbmcuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc1BvbGxpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BvbGxpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9sbGluZyA/IHRoaXMuX3BvbGxpbmcuaXNQb2xsaW5nKCkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHdlYmhvb2suXG4gICAgICogTXVsdGlwbGUgaW52b2NhdGlvbnMgZG8gbm90aGluZyBpZiB3ZWJob29rIGlzIGFscmVhZHkgb3Blbi5cbiAgICAgKiBSZWplY3RzIHJldHVybmVkIHByb21pc2UgaWYgUG9sbGluZyBpcyBiZWluZyB1c2VkIGJ5IHRoaXMgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvcGVuV2ViSG9vaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5XZWJIb29rKCkge1xuICAgICAgaWYgKHRoaXMuaXNQb2xsaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnMuRmF0YWxFcnJvcignV2ViSG9vayBhbmQgUG9sbGluZyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlJykpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl93ZWJIb29rKSB7XG4gICAgICAgIHRoaXMuX3dlYkhvb2sgPSBuZXcgVGVsZWdyYW1Cb3RXZWJIb29rKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3dlYkhvb2sub3BlbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIHdlYmhvb2sgYWZ0ZXIgY2xvc2luZyBhbGwgY3VycmVudCBjb25uZWN0aW9ucy5cbiAgICAgKiBNdWx0aXBsZSBpbnZvY2F0aW9ucyBkbyBub3RoaW5nIGlmIHdlYmhvb2sgaXMgYWxyZWFkeSBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Nsb3NlV2ViSG9vaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlV2ViSG9vaygpIHtcbiAgICAgIGlmICghdGhpcy5fd2ViSG9vaykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fd2ViSG9vay5jbG9zZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHVzaW5nIHdlYmhvb2sgYW5kIGl0IGlzIG9wZW4gaS5lLiBhY2NlcHRzIGNvbm5lY3Rpb25zLlxuICAgICAqIE90aGVyd2lzZSwgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYXNPcGVuV2ViSG9vaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc09wZW5XZWJIb29rKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dlYkhvb2sgPyB0aGlzLl93ZWJIb29rLmlzT3BlbigpIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbiB1cGRhdGU7IGVtaXR0aW5nIHRoZSBwcm9wZXIgZXZlbnRzIGFuZCBleGVjdXRpbmcgcmVnZXhwXG4gICAgICogY2FsbGJhY2tzLiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgc2hvdWxkIHlvdSBiZSB1c2luZyBhIGRpZmZlcmVudFxuICAgICAqIHdheSB0byBmZXRjaCB1cGRhdGVzLCBvdGhlciB0aGFuIHRob3NlIHByb3ZpZGVkIGJ5IFRlbGVncmFtQm90LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB1cGRhdGVcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXBkYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVXBkYXRlKHVwZGF0ZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSAlaicsIHVwZGF0ZSk7XG4gICAgICB2YXIgbWVzc2FnZSA9IHVwZGF0ZS5tZXNzYWdlO1xuICAgICAgdmFyIGVkaXRlZE1lc3NhZ2UgPSB1cGRhdGUuZWRpdGVkX21lc3NhZ2U7XG4gICAgICB2YXIgY2hhbm5lbFBvc3QgPSB1cGRhdGUuY2hhbm5lbF9wb3N0O1xuICAgICAgdmFyIGVkaXRlZENoYW5uZWxQb3N0ID0gdXBkYXRlLmVkaXRlZF9jaGFubmVsX3Bvc3Q7XG4gICAgICB2YXIgYnVzaW5lc3NDb25uZWN0aW9uID0gdXBkYXRlLmJ1c2luZXNzX2Nvbm5lY3Rpb247XG4gICAgICB2YXIgYnVzaW5lc3NzTWVzc2FnZSA9IHVwZGF0ZS5idXNpbmVzc19tZXNzYWdlO1xuICAgICAgdmFyIGVkaXRlZEJ1c2luZXNzTWVzc2FnZSA9IHVwZGF0ZS5lZGl0ZWRfYnVzaW5lc3NfbWVzc2FnZTtcbiAgICAgIHZhciBkZWxldGVkQnVzaW5lc3NNZXNzYWdlID0gdXBkYXRlLmRlbGV0ZWRfYnVzaW5lc3NfbWVzc2FnZXM7XG4gICAgICB2YXIgbWVzc2FnZVJlYWN0aW9uID0gdXBkYXRlLm1lc3NhZ2VfcmVhY3Rpb247XG4gICAgICB2YXIgbWVzc2FnZVJlYWN0aW9uQ291bnQgPSB1cGRhdGUubWVzc2FnZV9yZWFjdGlvbl9jb3VudDtcbiAgICAgIHZhciBpbmxpbmVRdWVyeSA9IHVwZGF0ZS5pbmxpbmVfcXVlcnk7XG4gICAgICB2YXIgY2hvc2VuSW5saW5lUmVzdWx0ID0gdXBkYXRlLmNob3Nlbl9pbmxpbmVfcmVzdWx0O1xuICAgICAgdmFyIGNhbGxiYWNrUXVlcnkgPSB1cGRhdGUuY2FsbGJhY2tfcXVlcnk7XG4gICAgICB2YXIgc2hpcHBpbmdRdWVyeSA9IHVwZGF0ZS5zaGlwcGluZ19xdWVyeTtcbiAgICAgIHZhciBwcmVDaGVja291dFF1ZXJ5ID0gdXBkYXRlLnByZV9jaGVja291dF9xdWVyeTtcbiAgICAgIHZhciBwb2xsID0gdXBkYXRlLnBvbGw7XG4gICAgICB2YXIgcG9sbEFuc3dlciA9IHVwZGF0ZS5wb2xsX2Fuc3dlcjtcbiAgICAgIHZhciBteUNoYXRNZW1iZXIgPSB1cGRhdGUubXlfY2hhdF9tZW1iZXI7XG4gICAgICB2YXIgY2hhdE1lbWJlciA9IHVwZGF0ZS5jaGF0X21lbWJlcjtcbiAgICAgIHZhciBjaGF0Sm9pblJlcXVlc3QgPSB1cGRhdGUuY2hhdF9qb2luX3JlcXVlc3Q7XG4gICAgICB2YXIgY2hhdEJvb3N0ID0gdXBkYXRlLmNoYXRfYm9vc3Q7XG4gICAgICB2YXIgcmVtb3ZlZENoYXRCb29zdCA9IHVwZGF0ZS5yZW1vdmVkX2NoYXRfYm9vc3Q7XG5cbiAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBtZXNzYWdlICVqJywgbWVzc2FnZSk7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IHt9O1xuICAgICAgICBtZXRhZGF0YS50eXBlID0gVGVsZWdyYW1Cb3QubWVzc2FnZVR5cGVzLmZpbmQoZnVuY3Rpb24gKG1lc3NhZ2VUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2VbbWVzc2FnZVR5cGVdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSwgbWV0YWRhdGEpO1xuICAgICAgICBpZiAobWV0YWRhdGEudHlwZSkge1xuICAgICAgICAgIGRlYnVnKCdFbWl0dGluZyAlczogJWonLCBtZXRhZGF0YS50eXBlLCBtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmVtaXQobWV0YWRhdGEudHlwZSwgbWVzc2FnZSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRleHQpIHtcbiAgICAgICAgICBkZWJ1ZygnVGV4dCBtZXNzYWdlJyk7XG4gICAgICAgICAgdGhpcy5fdGV4dFJlZ2V4cENhbGxiYWNrcy5zb21lKGZ1bmN0aW9uIChyZWcpIHtcbiAgICAgICAgICAgIGRlYnVnKCdNYXRjaGluZyAlcyB3aXRoICVzJywgbWVzc2FnZS50ZXh0LCByZWcucmVnZXhwKTtcblxuICAgICAgICAgICAgaWYgKCEocmVnLnJlZ2V4cCBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgICAgcmVnLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmVnLnJlZ2V4cCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWcucmVnZXhwLmV4ZWMobWVzc2FnZS50ZXh0KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlc2V0IGluZGV4IHNvIHdlIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlZ2V4IGVhY2ggdGltZVxuICAgICAgICAgICAgcmVnLnJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgZGVidWcoJ01hdGNoZXMgJXMnLCByZWcucmVnZXhwKTtcbiAgICAgICAgICAgIHJlZy5jYWxsYmFjayhtZXNzYWdlLCByZXN1bHQpO1xuICAgICAgICAgICAgLy8gcmV0dXJuaW5nIHRydXRoeSB2YWx1ZSBleGl0cyAuc29tZVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5vcHRpb25zLm9ubHlGaXJzdE1hdGNoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnJlcGx5X3RvX21lc3NhZ2UpIHtcbiAgICAgICAgICAvLyBPbmx5IGNhbGxiYWNrcyB3YWl0aW5nIGZvciB0aGlzIG1lc3NhZ2VcbiAgICAgICAgICB0aGlzLl9yZXBseUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXBseSkge1xuICAgICAgICAgICAgLy8gTWVzc2FnZSBmcm9tIHRoZSBzYW1lIGNoYXRcbiAgICAgICAgICAgIGlmIChyZXBseS5jaGF0SWQgPT09IG1lc3NhZ2UuY2hhdC5pZCkge1xuICAgICAgICAgICAgICAvLyBSZXNwb25kaW5nIHRvIHRoYXQgbWVzc2FnZVxuICAgICAgICAgICAgICBpZiAocmVwbHkubWVzc2FnZUlkID09PSBtZXNzYWdlLnJlcGx5X3RvX21lc3NhZ2UubWVzc2FnZV9pZCkge1xuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIHByb21pc2VcbiAgICAgICAgICAgICAgICByZXBseS5jYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVkaXRlZE1lc3NhZ2UpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIGVkaXRlZF9tZXNzYWdlICVqJywgZWRpdGVkTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX21lc3NhZ2UnLCBlZGl0ZWRNZXNzYWdlKTtcbiAgICAgICAgaWYgKGVkaXRlZE1lc3NhZ2UudGV4dCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX21lc3NhZ2VfdGV4dCcsIGVkaXRlZE1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGl0ZWRNZXNzYWdlLmNhcHRpb24pIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2VkaXRlZF9tZXNzYWdlX2NhcHRpb24nLCBlZGl0ZWRNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFubmVsUG9zdCkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgY2hhbm5lbF9wb3N0ICVqJywgY2hhbm5lbFBvc3QpO1xuICAgICAgICB0aGlzLmVtaXQoJ2NoYW5uZWxfcG9zdCcsIGNoYW5uZWxQb3N0KTtcbiAgICAgIH0gZWxzZSBpZiAoZWRpdGVkQ2hhbm5lbFBvc3QpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIGVkaXRlZF9jaGFubmVsX3Bvc3QgJWonLCBlZGl0ZWRDaGFubmVsUG9zdCk7XG4gICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX2NoYW5uZWxfcG9zdCcsIGVkaXRlZENoYW5uZWxQb3N0KTtcbiAgICAgICAgaWYgKGVkaXRlZENoYW5uZWxQb3N0LnRleHQpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2VkaXRlZF9jaGFubmVsX3Bvc3RfdGV4dCcsIGVkaXRlZENoYW5uZWxQb3N0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRpdGVkQ2hhbm5lbFBvc3QuY2FwdGlvbikge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX2NoYW5uZWxfcG9zdF9jYXB0aW9uJywgZWRpdGVkQ2hhbm5lbFBvc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJ1c2luZXNzQ29ubmVjdGlvbikge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgYnVzaW5lc3NfY29ubmVjdGlvbiAlaicsIGJ1c2luZXNzQ29ubmVjdGlvbik7XG4gICAgICAgIHRoaXMuZW1pdCgnYnVzaW5lc3NfY29ubmVjdGlvbicsIGJ1c2luZXNzQ29ubmVjdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKGJ1c2luZXNzc01lc3NhZ2UpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIGJ1c2luZXNzX21lc3NhZ2UgJWonLCBidXNpbmVzc3NNZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdidXNpbmVzc19tZXNzYWdlJywgYnVzaW5lc3NzTWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKGVkaXRlZEJ1c2luZXNzTWVzc2FnZSkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgZWRpdGVkX2J1c2luZXNzX21lc3NhZ2UgJWonLCBlZGl0ZWRCdXNpbmVzc01lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoJ2VkaXRlZF9idXNpbmVzc19tZXNzYWdlJywgZWRpdGVkQnVzaW5lc3NNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsZXRlZEJ1c2luZXNzTWVzc2FnZSkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgZGVsZXRlZF9idXNpbmVzc19tZXNzYWdlcyAlaicsIGRlbGV0ZWRCdXNpbmVzc01lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoJ2RlbGV0ZWRfYnVzaW5lc3NfbWVzc2FnZXMnLCBkZWxldGVkQnVzaW5lc3NNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZVJlYWN0aW9uKSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBtZXNzYWdlX3JlYWN0aW9uICVqJywgbWVzc2FnZVJlYWN0aW9uKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlX3JlYWN0aW9uJywgbWVzc2FnZVJlYWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZVJlYWN0aW9uQ291bnQpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIG1lc3NhZ2VfcmVhY3Rpb25fY291bnQgJWonLCBtZXNzYWdlUmVhY3Rpb25Db3VudCk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZV9yZWFjdGlvbl9jb3VudCcsIG1lc3NhZ2VSZWFjdGlvbkNvdW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5saW5lUXVlcnkpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIGlubGluZV9xdWVyeSAlaicsIGlubGluZVF1ZXJ5KTtcbiAgICAgICAgdGhpcy5lbWl0KCdpbmxpbmVfcXVlcnknLCBpbmxpbmVRdWVyeSk7XG4gICAgICB9IGVsc2UgaWYgKGNob3NlbklubGluZVJlc3VsdCkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgY2hvc2VuX2lubGluZV9yZXN1bHQgJWonLCBjaG9zZW5JbmxpbmVSZXN1bHQpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nob3Nlbl9pbmxpbmVfcmVzdWx0JywgY2hvc2VuSW5saW5lUmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2tRdWVyeSkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgY2FsbGJhY2tfcXVlcnkgJWonLCBjYWxsYmFja1F1ZXJ5KTtcbiAgICAgICAgdGhpcy5lbWl0KCdjYWxsYmFja19xdWVyeScsIGNhbGxiYWNrUXVlcnkpO1xuICAgICAgfSBlbHNlIGlmIChzaGlwcGluZ1F1ZXJ5KSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBzaGlwcGluZ19xdWVyeSAlaicsIHNoaXBwaW5nUXVlcnkpO1xuICAgICAgICB0aGlzLmVtaXQoJ3NoaXBwaW5nX3F1ZXJ5Jywgc2hpcHBpbmdRdWVyeSk7XG4gICAgICB9IGVsc2UgaWYgKHByZUNoZWNrb3V0UXVlcnkpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIHByZV9jaGVja291dF9xdWVyeSAlaicsIHByZUNoZWNrb3V0UXVlcnkpO1xuICAgICAgICB0aGlzLmVtaXQoJ3ByZV9jaGVja291dF9xdWVyeScsIHByZUNoZWNrb3V0UXVlcnkpO1xuICAgICAgfSBlbHNlIGlmIChwb2xsKSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBwb2xsICVqJywgcG9sbCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9sbCcsIHBvbGwpO1xuICAgICAgfSBlbHNlIGlmIChwb2xsQW5zd2VyKSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBwb2xsX2Fuc3dlciAlaicsIHBvbGxBbnN3ZXIpO1xuICAgICAgICB0aGlzLmVtaXQoJ3BvbGxfYW5zd2VyJywgcG9sbEFuc3dlcik7XG4gICAgICB9IGVsc2UgaWYgKGNoYXRNZW1iZXIpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIGNoYXRfbWVtYmVyICVqJywgY2hhdE1lbWJlcik7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hhdF9tZW1iZXInLCBjaGF0TWVtYmVyKTtcbiAgICAgIH0gZWxzZSBpZiAobXlDaGF0TWVtYmVyKSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBteV9jaGF0X21lbWJlciAlaicsIG15Q2hhdE1lbWJlcik7XG4gICAgICAgIHRoaXMuZW1pdCgnbXlfY2hhdF9tZW1iZXInLCBteUNoYXRNZW1iZXIpO1xuICAgICAgfSBlbHNlIGlmIChjaGF0Sm9pblJlcXVlc3QpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIG15X2NoYXRfbWVtYmVyICVqJywgY2hhdEpvaW5SZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGF0X2pvaW5fcmVxdWVzdCcsIGNoYXRKb2luUmVxdWVzdCk7XG4gICAgICB9IGVsc2UgaWYgKGNoYXRCb29zdCkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgY2hhdF9ib29zdCAlaicsIGNoYXRCb29zdCk7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hhdF9ib29zdCcsIGNoYXRCb29zdCk7XG4gICAgICB9IGVsc2UgaWYgKHJlbW92ZWRDaGF0Qm9vc3QpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIHJlbW92ZWRfY2hhdF9ib29zdCAlaicsIHJlbW92ZWRDaGF0Qm9vc3QpO1xuICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZWRfY2hhdF9ib29zdCcsIHJlbW92ZWRDaGF0Qm9vc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBTdGFydCBUZWxlZ3JhbSBCb3QgQVBJIG1ldGhvZHMgKi9cblxuICAgIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlY2VpdmUgaW5jb21pbmcgdXBkYXRlcyB1c2luZyBsb25nIHBvbGxpbmcuXG4gICAgKiBUaGlzIG1ldGhvZCBoYXMgYW4gW29sZGVyLCBjb21wYXRpYmxlIHNpZ25hdHVyZV1bZ2V0VXBkYXRlcy12MC4yNS4wXVxuICAgICogdGhhdCBpcyBiZWluZyBkZXByZWNhdGVkLlxuICAgICpcbiAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXR1cGRhdGVzXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VXBkYXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVwZGF0ZXMoKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIC8qIFRoZSBvbGRlciBtZXRob2Qgc2lnbmF0dXJlIHdhcyBnZXRVcGRhdGVzKHRpbWVvdXQsIGxpbWl0LCBvZmZzZXQpLlxuICAgICAgICogV2UgbmVlZCB0byBlbnN1cmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICAgICAqIGNvbnNpc3RlbmN5IG9mIHRoZSBtZXRob2Qgc2lnbmF0dXJlcyB0aHJvdWdob3V0IHRoZSBsaWJyYXJ5ICovXG4gICAgICBpZiAoKHR5cGVvZiBmb3JtID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihmb3JtKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgICAgZGVwcmVjYXRlKCdUaGUgbWV0aG9kIHNpZ25hdHVyZSBnZXRVcGRhdGVzKHRpbWVvdXQsIGxpbWl0LCBvZmZzZXQpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjAuMjUuMCcpO1xuICAgICAgICBmb3JtID0ge1xuICAgICAgICAgIHRpbWVvdXQ6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBsaW1pdDogYXJndW1lbnRzWzFdLFxuICAgICAgICAgIG9mZnNldDogYXJndW1lbnRzWzJdXG4gICAgICAgIH07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0VXBkYXRlcycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGFuIHVybCB0byByZWNlaXZlIGluY29taW5nIHVwZGF0ZXMgdmlhIGFuIG91dGdvaW5nIHdlYkhvb2suXG4gICAgICogVGhpcyBtZXRob2QgaGFzIGFuIFtvbGRlciwgY29tcGF0aWJsZSBzaWduYXR1cmVdW3NldFdlYkhvb2stdjAuMjUuMF1cbiAgICAgKiB0aGF0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybCBVUkwgd2hlcmUgVGVsZWdyYW0gd2lsbCBtYWtlIEhUVFAgUG9zdC4gTGVhdmUgZW1wdHkgdG9cbiAgICAgKiBkZWxldGUgd2ViSG9vay5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbX0gW29wdGlvbnMuY2VydGlmaWNhdGVdIFBFTSBjZXJ0aWZpY2F0ZSBrZXkgKHB1YmxpYykuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5zZWNyZXRfdG9rZW5dIE9wdGlvbmFsIHNlY3JldCB0b2tlbiB0byBiZSBzZW50IGluIGEgaGVhZGVyIGBYLVRlbGVncmFtLUJvdC1BcGktU2VjcmV0LVRva2VuYCBpbiBldmVyeSB3ZWJob29rIHJlcXVlc3QuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXR3ZWJob29rXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFdlYkhvb2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRXZWJIb29rKHVybCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgLyogVGhlIG9sZGVyIG1ldGhvZCBzaWduYXR1cmUgd2FzIHNldFdlYkhvb2sodXJsLCBjZXJ0KS5cbiAgICAgICAqIFdlIG5lZWQgdG8gZW5zdXJlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdoaWxlIG1haW50YWluaW5nXG4gICAgICAgKiBjb25zaXN0ZW5jeSBvZiB0aGUgbWV0aG9kIHNpZ25hdHVyZXMgdGhyb3VnaG91dCB0aGUgbGlicmFyeSAqL1xuICAgICAgdmFyIGNlcnQgPSB2b2lkIDA7XG4gICAgICAvLyBOb3RlOiAnb3B0aW9ucycgY291bGQgYmUgYW4gb2JqZWN0LCBpZiBhIHN0cmVhbSB3YXMgcHJvdmlkZWQgKGluIHBsYWNlIG9mICdjZXJ0JylcbiAgICAgIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyBpbnN0YW5jZW9mIHN0cmVhbS5TdHJlYW0pIHtcbiAgICAgICAgZGVwcmVjYXRlKCdUaGUgbWV0aG9kIHNpZ25hdHVyZSBzZXRXZWJIb29rKHVybCwgY2VydCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2MC4yNS4wJyk7XG4gICAgICAgIGNlcnQgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlcnQgPSBvcHRpb25zLmNlcnRpZmljYXRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgcXM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgICBvcHRzLnFzLnVybCA9IHVybDtcblxuICAgICAgaWYgKGNlcnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgnY2VydGlmaWNhdGUnLCBjZXJ0LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICAgIG9wdHMucXMuY2VydGlmaWNhdGUgPSBzZW5kRGF0YVsxXTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRXZWJIb29rJywgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlbW92ZSB3ZWJob29rIGludGVncmF0aW9uIGlmIHlvdSBkZWNpZGUgdG9cbiAgICAgKiBzd2l0Y2ggYmFjayB0byBnZXRVcGRhdGVzLiBSZXR1cm5zIFRydWUgb24gc3VjY2Vzcy5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGV3ZWJob29rXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVdlYkhvb2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVXZWJIb29rKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlV2ViaG9vaycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGN1cnJlbnQgd2ViaG9vayBzdGF0dXMuXG4gICAgICogT24gc3VjY2VzcywgcmV0dXJucyBhIFtXZWJob29rSW5mb10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN3ZWJob29raW5mbykgb2JqZWN0LlxuICAgICAqIElmIHRoZSBib3QgaXMgdXNpbmcgZ2V0VXBkYXRlcywgd2lsbCByZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogdXJsIGZpZWxkIGVtcHR5LlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHdlYmhvb2tpbmZvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFdlYkhvb2tJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2ViSG9va0luZm8oKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRXZWJob29rSW5mbycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSBtZXRob2QgZm9yIHRlc3RpbmcgeW91ciBib3QncyBhdXRoZW50aWNhdGlvbiB0b2tlbi4gUmVxdWlyZXMgbm8gcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IHRoZSBib3QgaW4gZm9ybSBvZiBhIFtVc2VyXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VzZXIpIG9iamVjdC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0bWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZSgpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldE1lJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGxvZyBvdXQgeW91ciBib3QgZnJvbSB0aGUgY2xvdWQgQm90IEFQSSBzZXJ2ZXIgYmVmb3JlIGxhdW5jaGluZyB0aGUgYm90IGxvY2FsbHkuXG4gICAgICogWW91IG11c3QgbG9nIG91dCB0aGUgYm90IGJlZm9yZSBydW5uaW5nIGl0IGxvY2FsbHksIG90aGVyd2lzZSB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYm90IHdpbGwgcmVjZWl2ZSB1cGRhdGVzLlxuICAgICAqIEFmdGVyIGEgc3VjY2Vzc2Z1bCBjYWxsLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBsb2cgaW4gYWdhaW4gdXNpbmcgdGhlIHNhbWUgdG9rZW4gZm9yIDEwIG1pbnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2xvZ291dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsb2dPdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dPdXQoKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdsb2dPdXQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2xvc2UgdGhlIGJvdCBpbnN0YW5jZSBiZWZvcmUgbW92aW5nIGl0IGZyb20gb25lIGxvY2FsIHNlcnZlciB0byBhbm90aGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGVycm9yIDQyOSBpbiB0aGUgZmlyc3QgMTAgbWludXRlcyBhZnRlciB0aGUgYm90IGlzIGxhdW5jaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjbG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjbG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY2xvc2UnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCB0ZXh0IG1lc3NhZ2UuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgVGV4dCBvZiB0aGUgbWVzc2FnZSB0byBiZSBzZW50XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRtZXNzYWdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbmRNZXNzYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZE1lc3NhZ2UoY2hhdElkLCB0ZXh0KSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0udGV4dCA9IHRleHQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZE1lc3NhZ2UnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yd2FyZCBtZXNzYWdlcyBvZiBhbnkga2luZC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gZnJvbUNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNoYXQgd2hlcmUgdGhlXG4gICAgICogb3JpZ2luYWwgbWVzc2FnZSB3YXMgc2VudCAob3IgY2hhbm5lbCB1c2VybmFtZSBpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBtZXNzYWdlSWQgIFVuaXF1ZSBtZXNzYWdlIGlkZW50aWZpZXIgaW4gdGhlIGNoYXQgc3BlY2lmaWVkIGluIGZyb21DaGF0SWRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNmb3J3YXJkbWVzc2FnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmb3J3YXJkTWVzc2FnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcndhcmRNZXNzYWdlKGNoYXRJZCwgZnJvbUNoYXRJZCwgbWVzc2FnZUlkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0uZnJvbV9jaGF0X2lkID0gZnJvbUNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV9pZCA9IG1lc3NhZ2VJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdmb3J3YXJkTWVzc2FnZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZm9yd2FyZCBtdWx0aXBsZSBtZXNzYWdlcyBvZiBhbnkga2luZC5cbiAgICAgKiBJZiBzb21lIG9mIHRoZSBzcGVjaWZpZWQgbWVzc2FnZXMgY2FuJ3QgYmUgZm91bmQgb3IgZm9yd2FyZGVkLCB0aGV5IGFyZSBza2lwcGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGZyb21DaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IHdoZXJlIHRoZVxuICAgICAqIG9yaWdpbmFsIG1lc3NhZ2Ugd2FzIHNlbnQgKG9yIGNoYW5uZWwgdXNlcm5hbWUgaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7QXJyYXk8TnVtYmVyfFN0cmluZz59IG1lc3NhZ2VJZHMgSWRlbnRpZmllcnMgb2YgMS0xMDAgbWVzc2FnZXMgaW4gdGhlIGNoYXQgZnJvbV9jaGF0X2lkIHRvIGZvcndhcmQuXG4gICAgICogVGhlIGlkZW50aWZpZXJzIG11c3QgYmUgc3BlY2lmaWVkIGluIGEgc3RyaWN0bHkgaW5jcmVhc2luZyBvcmRlci5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBbiBhcnJheSBvZiBNZXNzYWdlSWQgb2YgdGhlIHNlbnQgbWVzc2FnZXMgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNmb3J3YXJkbWVzc2FnZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZm9yd2FyZE1lc3NhZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yd2FyZE1lc3NhZ2VzKGNoYXRJZCwgZnJvbUNoYXRJZCwgbWVzc2FnZUlkcykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLmZyb21fY2hhdF9pZCA9IGZyb21DaGF0SWQ7XG4gICAgICBmb3JtLm1lc3NhZ2VfaWRzID0gbWVzc2FnZUlkcztcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdmb3J3YXJkTWVzc2FnZXMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29weSBtZXNzYWdlcyBvZiBhbnkga2luZC4gKipTZXJ2aWNlIG1lc3NhZ2VzIGFuZCBpbnZvaWNlIG1lc3NhZ2VzIGNhbid0IGJlIGNvcGllZC4qKlxuICAgICAqIFRoZSBtZXRob2QgaXMgYW5hbG9nb3VzIHRvIHRoZSBtZXRob2QgZm9yd2FyZE1lc3NhZ2VzLCBidXQgdGhlIGNvcGllZCBtZXNzYWdlIGRvZXNuJ3RcbiAgICAgKiBoYXZlIGEgbGluayB0byB0aGUgb3JpZ2luYWwgbWVzc2FnZS5cbiAgICAgKiBSZXR1cm5zIHRoZSBNZXNzYWdlSWQgb2YgdGhlIHNlbnQgbWVzc2FnZSBvbiBzdWNjZXNzLlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgICAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGZyb21DaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IHdoZXJlIHRoZVxuICAgICAqIG9yaWdpbmFsIG1lc3NhZ2Ugd2FzIHNlbnRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBtZXNzYWdlSWQgIFVuaXF1ZSBtZXNzYWdlIGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgW01lc3NhZ2VJZF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlaWQpIG9mIHRoZSBzZW50IG1lc3NhZ2Ugb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjb3B5bWVzc2FnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjb3B5TWVzc2FnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlNZXNzYWdlKGNoYXRJZCwgZnJvbUNoYXRJZCwgbWVzc2FnZUlkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0uZnJvbV9jaGF0X2lkID0gZnJvbUNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV9pZCA9IG1lc3NhZ2VJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjb3B5TWVzc2FnZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY29weSBtZXNzYWdlcyBvZiBhbnkga2luZC4gSWYgc29tZSBvZiB0aGUgc3BlY2lmaWVkIG1lc3NhZ2VzIGNhbid0IGJlIGZvdW5kIG9yIGNvcGllZCwgdGhleSBhcmUgc2tpcHBlZC5cbiAgICAgKiBTZXJ2aWNlIG1lc3NhZ2VzLCBnaXZlYXdheSBtZXNzYWdlcywgZ2l2ZWF3YXkgd2lubmVycyBtZXNzYWdlcywgYW5kIGludm9pY2UgbWVzc2FnZXMgY2FuJ3QgYmUgY29waWVkLlxuICAgICAqIFJldHVybnMgdGhlIE1lc3NhZ2VJZCBvZiB0aGUgc2VudCBtZXNzYWdlIG9uIHN1Y2Nlc3MuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBmcm9tQ2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCB3aGVyZSB0aGVcbiAgICAgKiBvcmlnaW5hbCBtZXNzYWdlIHdhcyBzZW50XG4gICAgICogQHBhcmFtICB7QXJyYXl9IG1lc3NhZ2VJZHMgIElkZW50aWZpZXJzIG9mIDEtMTAwIG1lc3NhZ2VzIGluIHRoZSBjaGF0IGZyb21fY2hhdF9pZCB0byBjb3B5LlxuICAgICAqIFRoZSBpZGVudGlmaWVycyBtdXN0IGJlIHNwZWNpZmllZCBpbiBhIHN0cmljdGx5IGluY3JlYXNpbmcgb3JkZXIuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gQW4gYXJyYXkgb2YgTWVzc2FnZUlkIG9mIHRoZSBzZW50IG1lc3NhZ2VzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NvcHltZXNzYWdlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjb3B5TWVzc2FnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5TWVzc2FnZXMoY2hhdElkLCBmcm9tQ2hhdElkLCBtZXNzYWdlSWRzKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0uZnJvbV9jaGF0X2lkID0gZnJvbUNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV9pZHMgPSBzdHJpbmdpZnkobWVzc2FnZUlkcyk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY29weU1lc3NhZ2VzJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgcGhvdG9cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHBob3RvIEEgZmlsZSBwYXRoIG9yIGEgU3RyZWFtLiBDYW5cbiAgICAgKiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kcGhvdG9cbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZFBob3RvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZFBob3RvKGNoYXRJZCwgcGhvdG8pIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBmaWxlT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdwaG90bycsIHBob3RvLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgICAgb3B0cy5xcy5waG90byA9IHNlbmREYXRhWzFdO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kUGhvdG8nLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFNlbmQgYXVkaW9cbiAgICAqXG4gICAgKiAqKllvdXIgYXVkaW8gbXVzdCBiZSBpbiB0aGUgLk1QMyBvciAuTTRBIGZvcm1hdC4qKlxuICAgICpcbiAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBhdWRpbyBBIGZpbGUgcGF0aCwgU3RyZWFtIG9yIEJ1ZmZlci5cbiAgICAqIENhbiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWQuXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kYXVkaW9cbiAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbmRBdWRpbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmRBdWRpbyhjaGF0SWQsIGF1ZGlvKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICB2YXIgZmlsZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgcXM6IG9wdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ2F1ZGlvJywgYXVkaW8sIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzLmF1ZGlvID0gc2VuZERhdGFbMV07XG4gICAgICAgIHRoaXMuX2ZpeEFkZEZpbGVUaHVtYm5haWwob3B0aW9ucywgb3B0cyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZEF1ZGlvJywgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBTZW5kIERvY3VtZW50XG4gICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gZG9jIEEgZmlsZSBwYXRoLCBTdHJlYW0gb3IgQnVmZmVyLlxuICAgICogQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kRG9jdW1lbnRcbiAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbmREb2N1bWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmREb2N1bWVudChjaGF0SWQsIGRvYykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ2RvY3VtZW50JywgZG9jLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgICAgb3B0cy5xcy5kb2N1bWVudCA9IHNlbmREYXRhWzFdO1xuICAgICAgICB0aGlzLl9maXhBZGRGaWxlVGh1bWJuYWlsKG9wdGlvbnMsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmREb2N1bWVudCcsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIHZpZGVvIGZpbGVzLCAqKlRlbGVncmFtIGNsaWVudHMgc3VwcG9ydCBtcDQgdmlkZW9zKiogKG90aGVyIGZvcm1hdHMgbWF5IGJlIHNlbnQgYXMgRG9jdW1lbnQpLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSB2aWRlbyBBIGZpbGUgcGF0aCBvciBTdHJlYW0uXG4gICAgICogQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kdmlkZW9cbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZFZpZGVvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZFZpZGVvKGNoYXRJZCwgdmlkZW8pIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBmaWxlT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCd2aWRlbycsIHZpZGVvLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgICAgb3B0cy5xcy52aWRlbyA9IHNlbmREYXRhWzFdO1xuICAgICAgICB0aGlzLl9maXhBZGRGaWxlVGh1bWJuYWlsKG9wdGlvbnMsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kVmlkZW8nLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBhbmltYXRpb24gZmlsZXMgKEdJRiBvciBILjI2NC9NUEVHLTQgQVZDIHZpZGVvIHdpdGhvdXQgc291bmQpLlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gYW5pbWF0aW9uIEEgZmlsZSBwYXRoLCBTdHJlYW0gb3IgQnVmZmVyLlxuICAgICAqIENhbiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGFuaW1hdGlvblxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kQW5pbWF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZEFuaW1hdGlvbihjaGF0SWQsIGFuaW1hdGlvbikge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ2FuaW1hdGlvbicsIGFuaW1hdGlvbiwgZmlsZU9wdGlvbnMpO1xuICAgICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICAgIG9wdHMucXMuYW5pbWF0aW9uID0gc2VuZERhdGFbMV07XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRBbmltYXRpb24nLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIHZvaWNlXG4gICAgICpcbiAgICAgKiAqKllvdXIgYXVkaW8gbXVzdCBiZSBpbiBhbiAuT0dHIGZpbGUgZW5jb2RlZCB3aXRoIE9QVVMqKiwgb3IgaW4gLk1QMyBmb3JtYXQsIG9yIGluIC5NNEEgZm9ybWF0IChvdGhlciBmb3JtYXRzIG1heSBiZSBzZW50IGFzIEF1ZGlvIG9yIERvY3VtZW50KVxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gdm9pY2UgQSBmaWxlIHBhdGgsIFN0cmVhbSBvciBCdWZmZXIuXG4gICAgICogQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kdm9pY2VcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZFZvaWNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZFZvaWNlKGNoYXRJZCwgdm9pY2UpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBmaWxlT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCd2b2ljZScsIHZvaWNlLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgICAgb3B0cy5xcy52b2ljZSA9IHNlbmREYXRhWzFdO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kVm9pY2UnLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCB2aWRlbyBtZXNzYWdlc1xuICAgICAqIFRlbGVncmFtIGNsaWVudHMgc3VwcG9ydCAqKnJvdW5kZWQgc3F1YXJlIE1QRUc0IHZpZGVvcyoqIG9mIHVwIHRvIDEgbWludXRlIGxvbmcuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSB2aWRlb05vdGUgQSBmaWxlIHBhdGggb3IgU3RyZWFtLlxuICAgICAqIENhbiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAgKiBAaW5mbyBUaGUgbGVuZ3RoIHBhcmFtZXRlciBpcyBhY3R1YWxseSBvcHRpb25hbC4gSG93ZXZlciwgdGhlIEFQSSAoYXQgdGltZSBvZiB3cml0aW5nKSByZXF1aXJlcyB5b3UgdG8gYWx3YXlzIHByb3ZpZGUgaXQgdW50aWwgaXQgaXMgZml4ZWQuXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmR2aWRlb25vdGVcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kVmlkZW9Ob3RlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZFZpZGVvTm90ZShjaGF0SWQsIHZpZGVvTm90ZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3ZpZGVvX25vdGUnLCB2aWRlb05vdGUsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzLnZpZGVvX25vdGUgPSBzZW5kRGF0YVsxXTtcbiAgICAgICAgdGhpcy5fZml4QWRkRmlsZVRodW1ibmFpbChvcHRpb25zLCBvcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZFZpZGVvTm90ZScsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGEgZ3JvdXAgb2YgcGhvdG9zIG9yIHZpZGVvcyBhcyBhbiBhbGJ1bS5cbiAgICAgKlxuICAgICAqICoqRG9jdW1lbnRzIGFuZCBhdWRpbyBmaWxlcyBjYW4gYmUgb25seSBncm91cGVkIGluIGFuIGFsYnVtIHdpdGggbWVzc2FnZXMgb2YgdGhlIHNhbWUgdHlwZSoqXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2lzaCB0byBbc3BlY2lmeSBmaWxlIG9wdGlvbnNdKGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXMpLFxuICAgICAqIGFkZCBhIGBmaWxlT3B0aW9uc2AgcHJvcGVydHkgdG8gdGhlIHRhcmdldCBpbnB1dCBpbiBgbWVkaWFgLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBtZWRpYSBBIEpTT04tc2VyaWFsaXplZCBhcnJheSBkZXNjcmliaW5nIHBob3RvcyBhbmQgdmlkZW9zIHRvIGJlIHNlbnQsIG11c3QgaW5jbHVkZSAy4oCTMTAgaXRlbXNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBhbiBhcnJheSBvZiB0aGUgc2VudCBbTWVzc2FnZXNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSlcbiAgICAgKiBpcyByZXR1cm5lZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZG1lZGlhZ3JvdXBcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZE1lZGlhR3JvdXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kTWVkaWFHcm91cChjaGF0SWQsIG1lZGlhKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcblxuICAgICAgb3B0cy5mb3JtRGF0YSA9IHt9O1xuICAgICAgdmFyIGlucHV0TWVkaWEgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbWVkaWFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGlucHV0ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIGlucHV0KTtcbiAgICAgICAgICBkZWxldGUgcGF5bG9hZC5tZWRpYTtcbiAgICAgICAgICBkZWxldGUgcGF5bG9hZC5maWxlT3B0aW9ucztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGF0dGFjaE5hbWUgPSBTdHJpbmcoaW5kZXgpO1xuXG4gICAgICAgICAgICB2YXIgX2Zvcm1hdFNlbmREYXRhNCA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKGF0dGFjaE5hbWUsIGlucHV0Lm1lZGlhLCBpbnB1dC5maWxlT3B0aW9ucyksXG4gICAgICAgICAgICAgICAgX2Zvcm1hdFNlbmREYXRhNSA9IF9zbGljZWRUb0FycmF5KF9mb3JtYXRTZW5kRGF0YTQsIDIpLFxuICAgICAgICAgICAgICAgIGZvcm1EYXRhID0gX2Zvcm1hdFNlbmREYXRhNVswXSxcbiAgICAgICAgICAgICAgICBmaWxlSWQgPSBfZm9ybWF0U2VuZERhdGE1WzFdO1xuXG4gICAgICAgICAgICBpZiAoZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgb3B0cy5mb3JtRGF0YVthdHRhY2hOYW1lXSA9IGZvcm1EYXRhW2F0dGFjaE5hbWVdO1xuICAgICAgICAgICAgICBwYXlsb2FkLm1lZGlhID0gJ2F0dGFjaDovLycgKyBhdHRhY2hOYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGF5bG9hZC5tZWRpYSA9IGZpbGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXRNZWRpYS5wdXNoKHBheWxvYWQpO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvcHRzLnFzLm1lZGlhID0gc3RyaW5naWZ5KGlucHV0TWVkaWEpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZE1lZGlhR3JvdXAnLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGxvY2F0aW9uLlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIHBvaW50IG9uIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtGbG9hdH0gbGF0aXR1ZGUgTGF0aXR1ZGUgb2YgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gIHtGbG9hdH0gbG9uZ2l0dWRlIExvbmdpdHVkZSBvZiBsb2NhdGlvblxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kbG9jYXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZExvY2F0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZExvY2F0aW9uKGNoYXRJZCwgbGF0aXR1ZGUsIGxvbmdpdHVkZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgICBmb3JtLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kTG9jYXRpb24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgbGl2ZSBsb2NhdGlvbiBtZXNzYWdlcyBzZW50IGJ5XG4gICAgICogdGhlIGJvdCBvciB2aWEgdGhlIGJvdCAoZm9yIGlubGluZSBib3RzKS5cbiAgICAgKlxuICAgICAqICBBIGxvY2F0aW9uICoqY2FuIGJlIGVkaXRlZCB1bnRpbCBpdHMgbGl2ZV9wZXJpb2QgZXhwaXJlcyBvciBlZGl0aW5nIGlzIGV4cGxpY2l0bHkgZGlzYWJsZWQgYnkgYSBjYWxsIHRvIFtzdG9wTWVzc2FnZUxpdmVMb2NhdGlvbl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzdG9wbWVzc2FnZWxpdmVsb2NhdGlvbikqKlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHlvdSBtdXN0IHByb3ZpZGUgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yXG4gICAgICogaW5saW5lX21lc3NhZ2VfaWQgaW4geW91ciByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RmxvYXR9IGxhdGl0dWRlIExhdGl0dWRlIG9mIGxvY2F0aW9uXG4gICAgICogQHBhcmFtICB7RmxvYXR9IGxvbmdpdHVkZSBMb25naXR1ZGUgb2YgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnMgKHByb3ZpZGUgZWl0aGVyIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCBoZXJlKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBlZGl0ZWQgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBlZGl0ZWQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0bWVzc2FnZWxpdmVsb2NhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlZGl0TWVzc2FnZUxpdmVMb2NhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRNZXNzYWdlTGl2ZUxvY2F0aW9uKGxhdGl0dWRlLCBsb25naXR1ZGUpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgICAgZm9ybS5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VMaXZlTG9jYXRpb24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHN0b3AgdXBkYXRpbmcgYSBsaXZlIGxvY2F0aW9uIG1lc3NhZ2Ugc2VudCBieVxuICAgICAqIHRoZSBib3Qgb3IgdmlhIHRoZSBib3QgKGZvciBpbmxpbmUgYm90cykgYmVmb3JlIGxpdmVfcGVyaW9kIGV4cGlyZXMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgeW91IG11c3QgcHJvdmlkZSBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3JcbiAgICAgKiBpbmxpbmVfbWVzc2FnZV9pZCBpbiB5b3VyIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnMgKHByb3ZpZGUgZWl0aGVyIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCBoZXJlKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBlZGl0ZWQgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBlZGl0ZWQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzdG9wbWVzc2FnZWxpdmVsb2NhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzdG9wTWVzc2FnZUxpdmVMb2NhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BNZXNzYWdlTGl2ZUxvY2F0aW9uKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc3RvcE1lc3NhZ2VMaXZlTG9jYXRpb24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCB2ZW51ZS5cbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBpbmZvcm1hdGlvbiBhYm91dCBhIHZlbnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7RmxvYXR9IGxhdGl0dWRlIExhdGl0dWRlIG9mIGxvY2F0aW9uXG4gICAgICogQHBhcmFtICB7RmxvYXR9IGxvbmdpdHVkZSBMb25naXR1ZGUgb2YgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlIE5hbWUgb2YgdGhlIHZlbnVlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBhZGRyZXNzIEFkZHJlc3Mgb2YgdGhlIHZlbnVlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kdmVudWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZFZlbnVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZFZlbnVlKGNoYXRJZCwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgdGl0bGUsIGFkZHJlc3MpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgICAgZm9ybS5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgICBmb3JtLnRpdGxlID0gdGl0bGU7XG4gICAgICBmb3JtLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRWZW51ZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGNvbnRhY3QuXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgcGhvbmUgY29udGFjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBob25lTnVtYmVyIENvbnRhY3QncyBwaG9uZSBudW1iZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpcnN0TmFtZSBDb250YWN0J3MgZmlyc3QgbmFtZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kY29udGFjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kQ29udGFjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmRDb250YWN0KGNoYXRJZCwgcGhvbmVOdW1iZXIsIGZpcnN0TmFtZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnBob25lX251bWJlciA9IHBob25lTnVtYmVyO1xuICAgICAgZm9ybS5maXJzdF9uYW1lID0gZmlyc3ROYW1lO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRDb250YWN0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgcG9sbC5cbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBhIG5hdGl2ZSBwb2xsLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGdyb3VwL2NoYW5uZWxcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHF1ZXN0aW9uIFBvbGwgcXVlc3Rpb24sIDEtMzAwIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcG9sbE9wdGlvbnMgUG9sbCBvcHRpb25zLCBiZXR3ZWVuIDItMTAgb3B0aW9ucyAob25seSAxLTEwMCBjaGFyYWN0ZXJzIGVhY2gpXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRwb2xsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbmRQb2xsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZFBvbGwoY2hhdElkLCBxdWVzdGlvbiwgcG9sbE9wdGlvbnMpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5xdWVzdGlvbiA9IHF1ZXN0aW9uO1xuICAgICAgZm9ybS5vcHRpb25zID0gc3RyaW5naWZ5KHBvbGxPcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kUG9sbCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIERpY2VcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBhbiBhbmltYXRlZCBlbW9qaSB0aGF0IHdpbGwgZGlzcGxheSBhIHJhbmRvbSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRkaWNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbmREaWNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZERpY2UoY2hhdElkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdkaWNlJyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZERpY2UnLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGNoYXQgYWN0aW9uLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHdoZW4geW91IG5lZWQgdG8gdGVsbCB0aGUgdXNlciB0aGF0IHNvbWV0aGluZyBpcyBoYXBwZW5pbmcgb24gdGhlIGJvdCdzIHNpZGUuXG4gICAgICogKipUaGUgc3RhdHVzIGlzIHNldCBmb3IgNSBzZWNvbmRzIG9yIGxlc3MqKiAod2hlbiBhIG1lc3NhZ2UgYXJyaXZlcyBmcm9tIHlvdXIgYm90LCBUZWxlZ3JhbSBjbGllbnRzIGNsZWFyIGl0cyB0eXBpbmcgc3RhdHVzKS5cbiAgICAgKlxuICAgICAqICBBY3Rpb24gYHR5cGluZ2AgZm9yIFt0ZXh0IG1lc3NhZ2VzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRtZXNzYWdlKSxcbiAgICAgKiBgdXBsb2FkX3Bob3RvYCBmb3IgW3Bob3Rvc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kcGhvdG8pLCBgcmVjb3JkX3ZpZGVvYCBvciBgdXBsb2FkX3ZpZGVvYCBmb3IgW3ZpZGVvc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kdmlkZW8pLFxuICAgICAqIGByZWNvcmRfdm9pY2VgIG9yIGB1cGxvYWRfdm9pY2VgIGZvciBbdm9pY2Ugbm90ZXNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHZvaWNlKSwgYHVwbG9hZF9kb2N1bWVudGAgZm9yIFtnZW5lcmFsIGZpbGVzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRkb2N1bWVudCksXG4gICAgICogYGNob29zZV9zdGlja2VyYCBmb3IgW3N0aWNrZXJzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRzdGlja2VyKSwgYGZpbmRfbG9jYXRpb25gIGZvciBbbG9jYXRpb24gZGF0YV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kbG9jYXRpb24pLFxuICAgICAqIGByZWNvcmRfdmlkZW9fbm90ZWAgb3IgYHVwbG9hZF92aWRlb19ub3RlYCBmb3IgW3ZpZGVvIG5vdGVzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmR2aWRlb25vdGUpLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFjdGlvbiBUeXBlIG9mIGFjdGlvbiB0byBicm9hZGNhc3QuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRjaGF0YWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbmRDaGF0QWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZENoYXRBY3Rpb24oY2hhdElkLCBhY3Rpb24pIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5hY3Rpb24gPSBhY3Rpb247XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZENoYXRBY3Rpb24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgY2hvc2VuIHJlYWN0aW9ucyBvbiBhIG1lc3NhZ2UuXG4gICAgICogLSBTZXJ2aWNlIG1lc3NhZ2VzIGNhbid0IGJlIHJlYWN0ZWQgdG8uXG4gICAgICogLSBBdXRvbWF0aWNhbGx5IGZvcndhcmRlZCBtZXNzYWdlcyBmcm9tIGEgY2hhbm5lbCB0byBpdHMgZGlzY3Vzc2lvbiBncm91cCBoYXZlIHRoZSBzYW1lIGF2YWlsYWJsZSByZWFjdGlvbnMgYXMgbWVzc2FnZXMgaW4gdGhlIGNoYW5uZWwuXG4gICAgICogLSBJbiBhbGJ1bXMsIGJvdHMgbXVzdCByZWFjdCB0byB0aGUgZmlyc3QgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgQGNoYW5uZWx1c2VybmFtZSlcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1lc3NhZ2VJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCBtZXNzYWdlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxCb29sZWFuPn0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldG1lc3NhZ2VyZWFjdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRNZXNzYWdlUmVhY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNZXNzYWdlUmVhY3Rpb24oY2hhdElkLCBtZXNzYWdlSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX2lkID0gbWVzc2FnZUlkO1xuICAgICAgaWYgKGZvcm0ucmVhY3Rpb24pIHtcbiAgICAgICAgZm9ybS5yZWFjdGlvbiA9IHN0cmluZ2lmeShmb3JtLnJlYWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRNZXNzYWdlUmVhY3Rpb24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBhIGxpc3Qgb2YgcHJvZmlsZSBwaWN0dXJlcyBmb3IgYSB1c2VyLlxuICAgICAqIFJldHVybnMgYSBbVXNlclByb2ZpbGVQaG90b3NdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXNlcnByb2ZpbGVwaG90b3MpIG9iamVjdC5cbiAgICAgKiBUaGlzIG1ldGhvZCBoYXMgYW4gW29sZGVyLCBjb21wYXRpYmxlIHNpZ25hdHVyZV1bZ2V0VXNlclByb2ZpbGVQaG90b3MtdjAuMjUuMF1cbiAgICAgKiB0aGF0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFJldHVybnMgYSBbVXNlclByb2ZpbGVQaG90b3NdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXNlcnByb2ZpbGVwaG90b3MpIG9iamVjdFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXR1c2VycHJvZmlsZXBob3Rvc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRVc2VyUHJvZmlsZVBob3RvcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVzZXJQcm9maWxlUGhvdG9zKHVzZXJJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAvKiBUaGUgb2xkZXIgbWV0aG9kIHNpZ25hdHVyZSB3YXMgZ2V0VXNlclByb2ZpbGVQaG90b3ModXNlcklkLCBvZmZzZXQsIGxpbWl0KS5cbiAgICAgICAqIFdlIG5lZWQgdG8gZW5zdXJlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdoaWxlIG1haW50YWluaW5nXG4gICAgICAgKiBjb25zaXN0ZW5jeSBvZiB0aGUgbWV0aG9kIHNpZ25hdHVyZXMgdGhyb3VnaG91dCB0aGUgbGlicmFyeSAqL1xuICAgICAgaWYgKCh0eXBlb2YgZm9ybSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZm9ybSkpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgICAgIGRlcHJlY2F0ZSgnVGhlIG1ldGhvZCBzaWduYXR1cmUgZ2V0VXNlclByb2ZpbGVQaG90b3ModXNlcklkLCBvZmZzZXQsIGxpbWl0KSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYwLjI1LjAnKTtcbiAgICAgICAgZm9ybSA9IHtcbiAgICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICBsaW1pdDogYXJndW1lbnRzWzJdXG4gICAgICAgIH07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgfVxuICAgICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldFVzZXJQcm9maWxlUGhvdG9zJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlLlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgYmFzaWMgaW5mbyBhYm91dCBhIGZpbGUgYW5kIHByZXBhcmUgaXQgZm9yIGRvd25sb2FkaW5nLlxuICAgICAqXG4gICAgICogQXR0ZW50aW9uOiAqKmxpbmsgd2lsbCBiZSB2YWxpZCBmb3IgMSBob3VyLioqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVJZCAgRmlsZSBpZGVudGlmaWVyIHRvIGdldCBpbmZvIGFib3V0XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgYSBbRmlsZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNmaWxlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0ZmlsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRGaWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsZShmaWxlSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5maWxlX2lkID0gZmlsZUlkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldEZpbGUnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBiYW4gYSB1c2VyIGluIGEgZ3JvdXAsIGEgc3VwZXJncm91cCBvciBhIGNoYW5uZWwuXG4gICAgICAqIEluIHRoZSBjYXNlIG9mIHN1cGVyZ3JvdXBzIGFuZCBjaGFubmVscywgdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0b1xuICAgICAgKiByZXR1cm4gdG8gdGhlIGNoYXQgb24gdGhlaXIgb3duIHVzaW5nIGludml0ZSBsaW5rcywgZXRjLiwgdW5sZXNzIHVuYmFubmVkIGZpcnN0Li5cbiAgICAgICpcbiAgICAgICogVGhlICoqYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgZ3JvdXAsIHN1cGVyZ3JvdXAgb3IgYSBjaGFubmVsKiogZm9yIHRoaXMgdG8gd29yay5cbiAgICAgICpcbiAgICAgICpcbiAgICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNiYW5jaGF0bWVtYmVyXG4gICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdiYW5DaGF0TWVtYmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFuQ2hhdE1lbWJlcihjaGF0SWQsIHVzZXJJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYmFuQ2hhdE1lbWJlcicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byB1bmJhbiBhIHByZXZpb3VzbHkga2lja2VkIHVzZXIgaW4gYSBzdXBlcmdyb3VwLlxuICAgICogVGhlIHVzZXIgd2lsbCBub3QgcmV0dXJuIHRvIHRoZSBncm91cCBhdXRvbWF0aWNhbGx5LCBidXQgd2lsbCBiZVxuICAgICogYWJsZSB0byBqb2luIHZpYSBsaW5rLCBldGMuXG4gICAgKlxuICAgICogVGhlICoqYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvcioqIGluIHRoZSBzdXBlcmdyb3VwIG9yIGNoYW5uZWwgZm9yIHRoaXMgdG8gd29yay5cbiAgICAqXG4gICAgKiAqKkJ5IGRlZmF1bHQqKiwgdGhpcyBtZXRob2QgZ3VhcmFudGVlcyB0aGF0IGFmdGVyIHRoZSBjYWxsIHRoZSB1c2VyIGlzIG5vdCBhIG1lbWJlciBvZiB0aGUgY2hhdCwgYnV0IHdpbGwgYmUgYWJsZSB0byBqb2luIGl0LlxuICAgICogU28gKippZiB0aGUgdXNlciBpcyBhIG1lbWJlciBvZiB0aGUgY2hhdCB0aGV5IHdpbGwgYWxzbyBiZSByZW1vdmVkIGZyb20gdGhlIGNoYXQqKi4gSWYgeW91IGRvbid0IHdhbnQgdGhpcywgdXNlIHRoZSBwYXJhbWV0ZXIgKm9ubHlfaWZfYmFubmVkKlxuICAgICpcbiAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdW5iYW5jaGF0bWVtYmVyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5iYW5DaGF0TWVtYmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iYW5DaGF0TWVtYmVyKGNoYXRJZCwgdXNlcklkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bmJhbkNoYXRNZW1iZXInLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVzdHJpY3QgYSB1c2VyIGluIGEgc3VwZXJncm91cC5cbiAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIHN1cGVyZ3JvdXAqKiBmb3IgdGhpcyB0byB3b3JrXG4gICAgKiBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbiByaWdodHMuIFBhc3MgVHJ1ZSBmb3IgYWxsIGJvb2xlYW4gcGFyYW1ldGVyc1xuICAgICogdG8gbGlmdCByZXN0cmljdGlvbnMgZnJvbSBhIHVzZXIuIFJldHVybnMgVHJ1ZSBvbiBzdWNjZXNzLlxuICAgICpcbiAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Jlc3RyaWN0Y2hhdG1lbWJlclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc3RyaWN0Q2hhdE1lbWJlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3RyaWN0Q2hhdE1lbWJlcihjaGF0SWQsIHVzZXJJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncmVzdHJpY3RDaGF0TWVtYmVyJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBwcm9tb3RlIG9yIGRlbW90ZSBhIHVzZXIgaW4gYSBzdXBlcmdyb3VwIG9yIGEgY2hhbm5lbC5cbiAgICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yKiogaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29ya1xuICAgICAqIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy4gUGFzcyBGYWxzZSBmb3IgYWxsIGJvb2xlYW4gcGFyYW1ldGVycyB0byBkZW1vdGUgYSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Byb21vdGVjaGF0bWVtYmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb21vdGVDaGF0TWVtYmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvbW90ZUNoYXRNZW1iZXIoY2hhdElkLCB1c2VySWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3Byb21vdGVDaGF0TWVtYmVyJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBjdXN0b20gdGl0bGUgZm9yIGFuIGFkbWluaXN0cmF0b3IgaW4gYSBzdXBlcmdyb3VwIHByb21vdGVkIGJ5IHRoZSBib3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGN1c3RvbVRpdGxlIE5ldyBjdXN0b20gdGl0bGUgZm9yIHRoZSBhZG1pbmlzdHJhdG9yOyAwLTE2IGNoYXJhY3RlcnMsIGVtb2ppIGFyZSBub3QgYWxsb3dlZFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRjaGF0YWRtaW5pc3RyYXRvcmN1c3RvbXRpdGxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldENoYXRBZG1pbmlzdHJhdG9yQ3VzdG9tVGl0bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGF0QWRtaW5pc3RyYXRvckN1c3RvbVRpdGxlKGNoYXRJZCwgdXNlcklkLCBjdXN0b21UaXRsZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICBmb3JtLmN1c3RvbV90aXRsZSA9IGN1c3RvbVRpdGxlO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldENoYXRBZG1pbmlzdHJhdG9yQ3VzdG9tVGl0bGUnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGJhbiBhIGNoYW5uZWwgY2hhdCBpbiBhIHN1cGVyZ3JvdXAgb3IgYSBjaGFubmVsLlxuICAgICAqXG4gICAgICogVW50aWwgdGhlIGNoYXQgaXMgW3VuYmFubmVkXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VuYmFuY2hhdHNlbmRlcmNoYXQpLCB0aGUgb3duZXIgb2YgdGhlIGJhbm5lZCBjaGF0IHdvbid0IGJlIGFibGUgdG8gc2VuZCBtZXNzYWdlcyBvbiBiZWhhbGYgb2YgYW55IG9mIHRoZWlyIGNoYW5uZWxzLlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIHN1cGVyZ3JvdXAgb3IgY2hhbm5lbCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW5pc3RyYXRvciByaWdodHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNlbmRlckNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNiYW5jaGF0c2VuZGVyY2hhdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdiYW5DaGF0U2VuZGVyQ2hhdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhbkNoYXRTZW5kZXJDaGF0KGNoYXRJZCwgc2VuZGVyQ2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0uc2VuZGVyX2NoYXRfaWQgPSBzZW5kZXJDaGF0SWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYmFuQ2hhdFNlbmRlckNoYXQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gdW5iYW4gYSBwcmV2aW91c2x5IGJhbm5lZCBjaGFubmVsIGNoYXQgaW4gYSBzdXBlcmdyb3VwIG9yIGNoYW5uZWwuXG4gICAgKlxuICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvcioqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICAgKlxuICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAqIEBwYXJhbSAge051bWJlcn0gc2VuZGVyQ2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bmJhbmNoYXRzZW5kZXJjaGF0XG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5iYW5DaGF0U2VuZGVyQ2hhdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmFuQ2hhdFNlbmRlckNoYXQoY2hhdElkLCBzZW5kZXJDaGF0SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5zZW5kZXJfY2hhdF9pZCA9IHNlbmRlckNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bmJhbkNoYXRTZW5kZXJDaGF0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgZGVmYXVsdCBjaGF0IHBlcm1pc3Npb25zIGZvciBhbGwgbWVtYmVycy5cbiAgICAgKlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGdyb3VwIG9yIGEgc3VwZXJncm91cCoqIGZvciB0aGlzIHRvXG4gICAgICogd29yayBhbmQgKiptdXN0IGhhdmUgdGhlIGBjYW5fcmVzdHJpY3RfbWVtYmVyc2AgYWRtaW4gcmlnaHRzLioqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY2hhdFBlcm1pc3Npb25zIE5ldyBkZWZhdWx0IGNoYXQgcGVybWlzc2lvbnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y2hhdHBlcm1pc3Npb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldENoYXRQZXJtaXNzaW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENoYXRQZXJtaXNzaW9ucyhjaGF0SWQsIGNoYXRQZXJtaXNzaW9ucykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnBlcm1pc3Npb25zID0gc3RyaW5naWZ5KGNoYXRQZXJtaXNzaW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0Q2hhdFBlcm1pc3Npb25zJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSBhIG5ldyBwcmltYXJ5IGludml0ZSBsaW5rIGZvciBhIGNoYXQuICoqQW55IHByZXZpb3VzbHkgZ2VuZXJhdGVkIHByaW1hcnkgbGluayBpcyByZXZva2VkKiouXG4gICAgICpcbiAgICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gRXhwb3J0ZWQgaW52aXRlIGxpbmsgYXMgU3RyaW5nIG9uIHN1Y2Nlc3MuXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2V4cG9ydGNoYXRpbnZpdGVsaW5rXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2V4cG9ydENoYXRJbnZpdGVMaW5rJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0Q2hhdEludml0ZUxpbmsoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdleHBvcnRDaGF0SW52aXRlTGluaycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFuIGFkZGl0aW9uYWwgaW52aXRlIGxpbmsgZm9yIGEgY2hhdC5cbiAgICAgKlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy5cbiAgICAgKlxuICAgICAqIFRoZSBsaW5rIGdlbmVyYXRlZCB3aXRoIHRoaXMgbWV0aG9kIGNhbiBiZSByZXZva2VkIHVzaW5nIHRoZSBtZXRob2QgW3Jldm9rZUNoYXRJbnZpdGVMaW5rXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Jldm9rZWNoYXRpbnZpdGVsaW5rKVxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgaW52aXRlIGxpbmsgYXMgW0NoYXRJbnZpdGVMaW5rXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRpbnZpdGVsaW5rKSBvYmplY3RcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY3JlYXRlY2hhdGludml0ZWxpbmtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlQ2hhdEludml0ZUxpbmsnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDaGF0SW52aXRlTGluayhjaGF0SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2NyZWF0ZUNoYXRJbnZpdGVMaW5rJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBlZGl0IGEgbm9uLXByaW1hcnkgaW52aXRlIGxpbmsgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgICAqXG4gICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGludml0ZUxpbmsgVGV4dCB3aXRoIHRoZSBpbnZpdGUgbGluayB0byBlZGl0XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIGVkaXRlZCBpbnZpdGUgbGluayBhcyBhIFtDaGF0SW52aXRlTGlua10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjaGF0aW52aXRlbGluaykgb2JqZWN0XG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2VkaXRjaGF0aW52aXRlbGlua1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlZGl0Q2hhdEludml0ZUxpbmsnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0Q2hhdEludml0ZUxpbmsoY2hhdElkLCBpbnZpdGVMaW5rKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0uaW52aXRlX2xpbmsgPSBpbnZpdGVMaW5rO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRDaGF0SW52aXRlTGluaycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmV2b2tlIGFuIGludml0ZSBsaW5rIGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICAgKiBOb3RlOiBJZiB0aGUgcHJpbWFyeSBsaW5rIGlzIHJldm9rZWQsIGEgbmV3IGxpbmsgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWRcbiAgICAgKlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBpbnZpdGVMaW5rIFRoZSBpbnZpdGUgbGluayB0byByZXZva2VcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcmV2b2tlZCBpbnZpdGUgbGluayBhcyBbQ2hhdEludml0ZUxpbmtdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY2hhdGludml0ZWxpbmspIG9iamVjdFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNyZXZva2VjaGF0aW52aXRlbGlua1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXZva2VDaGF0SW52aXRlTGluaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldm9rZUNoYXRJbnZpdGVMaW5rKGNoYXRJZCwgaW52aXRlTGluaykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLmludml0ZV9saW5rID0gaW52aXRlTGluaztcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdyZXZva2VDaGF0SW52aXRlTGluaycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gYXBwcm92ZSBhIGNoYXQgam9pbiByZXF1ZXN0LlxuICAgICAqXG4gICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kICoqbXVzdCBoYXZlIHRoZSBgY2FuX2ludml0ZV91c2Vyc2AgYWRtaW5pc3RyYXRvciByaWdodC4qKlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2FwcHJvdmVjaGF0am9pbnJlcXVlc3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXBwcm92ZUNoYXRKb2luUmVxdWVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcHJvdmVDaGF0Sm9pblJlcXVlc3QoY2hhdElkLCB1c2VySWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2FwcHJvdmVDaGF0Sm9pblJlcXVlc3QnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGRlY2xpbmUgYSBjaGF0IGpvaW4gcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCAqKm11c3QgaGF2ZSB0aGUgYGNhbl9pbnZpdGVfdXNlcnNgIGFkbWluaXN0cmF0b3IgcmlnaHQqKi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWNsaW5lY2hhdGpvaW5yZXF1ZXN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlY2xpbmVDaGF0Sm9pblJlcXVlc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNsaW5lQ2hhdEpvaW5SZXF1ZXN0KGNoYXRJZCwgdXNlcklkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWNsaW5lQ2hhdEpvaW5SZXF1ZXN0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBuZXcgcHJvZmlsZSBwaG90byBmb3IgdGhlIGNoYXQuICoqUGhvdG9zIGNhbid0IGJlIGNoYW5nZWQgZm9yIHByaXZhdGUgY2hhdHMqKi5cbiAgICAgKlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge3N0cmVhbS5TdHJlYW18QnVmZmVyfSBwaG90byBBIGZpbGUgcGF0aCBvciBhIFN0cmVhbS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRjaGF0cGhvdG9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0Q2hhdFBob3RvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2hhdFBob3RvKGNoYXRJZCwgcGhvdG8pIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBmaWxlT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdwaG90bycsIHBob3RvLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgICAgb3B0cy5xcy5waG90byA9IHNlbmREYXRhWzFdO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0UGhvdG8nLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgYSBjaGF0IHBob3RvLiAqKlBob3RvcyBjYW4ndCBiZSBjaGFuZ2VkIGZvciBwcml2YXRlIGNoYXRzKiouXG4gICAgKlxuICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAgICpcbiAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGVjaGF0cGhvdG9cbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVDaGF0UGhvdG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVDaGF0UGhvdG8oY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVDaGF0UGhvdG8nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgdGl0bGUgb2YgYSBjaGF0LiAqKlRpdGxlcyBjYW4ndCBiZSBjaGFuZ2VkIGZvciBwcml2YXRlIGNoYXRzKiouXG4gICAgICpcbiAgICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbiByaWdodHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlIE5ldyBjaGF0IHRpdGxlLCAxLTI1NSBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGNoYXR0aXRsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDaGF0VGl0bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGF0VGl0bGUoY2hhdElkLCB0aXRsZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnRpdGxlID0gdGl0bGU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0Q2hhdFRpdGxlJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGRlc2NyaXB0aW9uIG9mIGEgZ3JvdXAsIGEgc3VwZXJncm91cCBvciBhIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbiByaWdodHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRlc2NyaXB0aW9uIE5ldyBjaGF0IHRpdGxlLCAwLTI1NSBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGNoYXRkZXNjcmlwdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDaGF0RGVzY3JpcHRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGF0RGVzY3JpcHRpb24oY2hhdElkLCBkZXNjcmlwdGlvbikge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0Q2hhdERlc2NyaXB0aW9uJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBwaW4gYSBtZXNzYWdlIGluIGEgc3VwZXJncm91cC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjaGF0IGlzIG5vdCBhIHByaXZhdGUgY2hhdCwgdGhlICoqYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYGNhbl9waW5fbWVzc2FnZXNgIGFkbWluaXN0cmF0b3JcbiAgICAgKiByaWdodCBpbiBhIHN1cGVyZ3JvdXAgb3IgYGNhbl9lZGl0X21lc3NhZ2VzYCBhZG1pbmlzdHJhdG9yIHJpZ2h0IGluIGEgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbWVzc2FnZUlkIElkZW50aWZpZXIgb2YgYSBtZXNzYWdlIHRvIHBpblxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNwaW5jaGF0bWVzc2FnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwaW5DaGF0TWVzc2FnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBpbkNoYXRNZXNzYWdlKGNoYXRJZCwgbWVzc2FnZUlkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV9pZCA9IG1lc3NhZ2VJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdwaW5DaGF0TWVzc2FnZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVtb3ZlIGEgbWVzc2FnZSBmcm9tIHRoZSBsaXN0IG9mIHBpbm5lZCBtZXNzYWdlcyBpbiBhIGNoYXRcbiAgICAgKlxuICAgICAqIElmIHRoZSBjaGF0IGlzIG5vdCBhIHByaXZhdGUgY2hhdCwgdGhlICoqYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYGNhbl9waW5fbWVzc2FnZXNgIGFkbWluaXN0cmF0b3JcbiAgICAgKiByaWdodCBpbiBhIHN1cGVyZ3JvdXAgb3IgYGNhbl9lZGl0X21lc3NhZ2VzYCBhZG1pbmlzdHJhdG9yIHJpZ2h0IGluIGEgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bnBpbmNoYXRtZXNzYWdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VucGluQ2hhdE1lc3NhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnBpbkNoYXRNZXNzYWdlKGNoYXRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgndW5waW5DaGF0TWVzc2FnZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjbGVhciB0aGUgbGlzdCBvZiBwaW5uZWQgbWVzc2FnZXMgaW4gYSBjaGF0LlxuICAgICpcbiAgICAqIElmIHRoZSBjaGF0IGlzIG5vdCBhIHByaXZhdGUgY2hhdCwgdGhlICoqYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYGNhbl9waW5fbWVzc2FnZXNgIGFkbWluaXN0cmF0b3JcbiAgICAqIHJpZ2h0IGluIGEgc3VwZXJncm91cCBvciBgY2FuX2VkaXRfbWVzc2FnZXNgIGFkbWluaXN0cmF0b3IgcmlnaHQgaW4gYSBjaGFubmVsLlxuICAgICpcbiAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bnBpbmFsbGNoYXRtZXNzYWdlc1xuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VucGluQWxsQ2hhdE1lc3NhZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5waW5BbGxDaGF0TWVzc2FnZXMoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bnBpbkFsbENoYXRNZXNzYWdlcycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgZm9yIHlvdXIgYm90IHRvIGxlYXZlIGEgZ3JvdXAsIHN1cGVyZ3JvdXAgb3IgY2hhbm5lbFxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2xlYXZlY2hhdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsZWF2ZUNoYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWF2ZUNoYXQoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdsZWF2ZUNoYXQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB1cCB0byBkYXRlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGF0XG4gICAgICogKGN1cnJlbnQgbmFtZSBvZiB0aGUgdXNlciBmb3Igb25lLW9uLW9uZSBjb252ZXJzYXRpb25zLCBjdXJyZW50XG4gICAgICogdXNlcm5hbWUgb2YgYSB1c2VyLCBncm91cCBvciBjaGFubmVsLCBldGMuKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKSBvciBjaGFubmVsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gW0NoYXRGdWxsSW5mb10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjaGF0ZnVsbGluZm8pIG9iamVjdCBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q2hhdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYXQoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRDaGF0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgYSBsaXN0IG9mIGFkbWluaXN0cmF0b3JzIGluIGEgY2hhdFxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXBcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCByZXR1cm5zIGFuIEFycmF5IG9mIFtDaGF0TWVtYmVyXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRtZW1iZXIpIG9iamVjdHMgdGhhdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBhbGwgY2hhdCBhZG1pbmlzdHJhdG9ycyBleGNlcHQgb3RoZXIgYm90cy5cbiAgICAgKiBJZiB0aGUgY2hhdCBpcyBhIGdyb3VwIG9yIGEgc3VwZXJncm91cCBhbmQgbm8gYWRtaW5pc3RyYXRvcnMgd2VyZSBhcHBvaW50ZWQsIG9ubHkgdGhlIGNyZWF0b3Igd2lsbCBiZSByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0YWRtaW5pc3RyYXRvcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q2hhdEFkbWluaXN0cmF0b3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhdEFkbWluaXN0cmF0b3JzKGNoYXRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0Q2hhdEFkbWluaXN0cmF0b3JzJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB0aGUgbnVtYmVyIG9mIG1lbWJlcnMgaW4gYSBjaGF0LlxuICAgICpcbiAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IEludCBvbiBzdWNjZXNzXG4gICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Y2hhdG1lbWJlcmNvdW50XG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q2hhdE1lbWJlckNvdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhdE1lbWJlckNvdW50KGNoYXRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0Q2hhdE1lbWJlckNvdW50JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgaW5mb3JtYXRpb24gYWJvdXQgYSBtZW1iZXIgb2YgYSBjaGF0LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXBcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gW0NoYXRNZW1iZXJdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY2hhdG1lbWJlcikgb2JqZWN0IG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Y2hhdG1lbWJlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDaGF0TWVtYmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhdE1lbWJlcihjaGF0SWQsIHVzZXJJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0Q2hhdE1lbWJlcicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2V0IGEgbmV3IGdyb3VwIHN0aWNrZXIgc2V0IGZvciBhIHN1cGVyZ3JvdXAuXG4gICAgICpcbiAgICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgdGhlIGZpZWxkIGBjYW5fc2V0X3N0aWNrZXJfc2V0YCBvcHRpb25hbGx5IHJldHVybmVkIGluIFtnZXRDaGF0XShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXQpIHJlcXVlc3RzIHRvIGNoZWNrIGlmIHRoZSBib3QgY2FuIHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXJTZXROYW1lIE5hbWUgb2YgdGhlIHN0aWNrZXIgc2V0IHRvIGJlIHNldCBhcyB0aGUgZ3JvdXAgc3RpY2tlciBzZXRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y2hhdHN0aWNrZXJzZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0Q2hhdFN0aWNrZXJTZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGF0U3RpY2tlclNldChjaGF0SWQsIHN0aWNrZXJTZXROYW1lKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0uc3RpY2tlcl9zZXRfbmFtZSA9IHN0aWNrZXJTZXROYW1lO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldENoYXRTdGlja2VyU2V0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgYSBncm91cCBzdGlja2VyIHNldCBmcm9tIGEgc3VwZXJncm91cC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGUgZmllbGQgYGNhbl9zZXRfc3RpY2tlcl9zZXRgIG9wdGlvbmFsbHkgcmV0dXJuZWQgaW4gW2dldENoYXRdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Y2hhdCkgcmVxdWVzdHMgdG8gY2hlY2sgaWYgdGhlIGJvdCBjYW4gdXNlIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGVjaGF0c3RpY2tlcnNldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVDaGF0U3RpY2tlclNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUNoYXRTdGlja2VyU2V0KGNoYXRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlQ2hhdFN0aWNrZXJTZXQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBjdXN0b20gZW1vamkgc3RpY2tlcnMsIHdoaWNoIGNhbiBiZSB1c2VkIGFzIGEgZm9ydW0gdG9waWMgaWNvbiBieSBhbnkgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBcnJheSBvZiBbU3RpY2tlcl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzdGlja2VyKSBvYmplY3RzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGZvcnVtdG9waWNpY29uc3RpY2tlcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ydW1Ub3BpY0ljb25TdGlja2VycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcnVtVG9waWNJY29uU3RpY2tlcnMoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRGb3J1bVRvcGljSWNvblN0aWNrZXJzJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYSB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAgICAqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3JlYXRlZCB0b3BpYyBhcyBhIFtGb3J1bVRvcGljXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2ZvcnVtdG9waWMpIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgVG9waWMgbmFtZSwgMS0xMjggY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjcmVhdGVmb3J1bXRvcGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZUZvcnVtVG9waWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVGb3J1bVRvcGljKGNoYXRJZCwgbmFtZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2NyZWF0ZUZvcnVtVG9waWMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgbmFtZSBhbmQgaWNvbiBvZiBhIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSBjYW5fbWFuYWdlX3RvcGljcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cywgdW5sZXNzIGl0IGlzIHRoZSBjcmVhdG9yIG9mIHRoZSB0b3BpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtZXNzYWdlVGhyZWFkSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgbWVzc2FnZSB0aHJlYWQgb2YgdGhlIGZvcnVtIHRvcGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdGZvcnVtdG9waWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZWRpdEZvcnVtVG9waWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0Rm9ydW1Ub3BpYyhjaGF0SWQsIG1lc3NhZ2VUaHJlYWRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLm1lc3NhZ2VfdGhyZWFkX2lkID0gbWVzc2FnZVRocmVhZElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRGb3J1bVRvcGljJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjbG9zZSBhbiBvcGVuIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMsIHVubGVzcyBpdCBpcyB0aGUgY3JlYXRvciBvZiB0aGUgdG9waWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZVRocmVhZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IG1lc3NhZ2UgdGhyZWFkIG9mIHRoZSBmb3J1bSB0b3BpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Nsb3NlZm9ydW10b3BpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjbG9zZUZvcnVtVG9waWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZUZvcnVtVG9waWMoY2hhdElkLCBtZXNzYWdlVGhyZWFkSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX3RocmVhZF9pZCA9IG1lc3NhZ2VUaHJlYWRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjbG9zZUZvcnVtVG9waWMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlb3BlbiBhIGNsb3NlZCB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLCB1bmxlc3MgaXQgaXMgdGhlIGNyZWF0b3Igb2YgdGhlIHRvcGljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1lc3NhZ2VUaHJlYWRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBtZXNzYWdlIHRocmVhZCBvZiB0aGUgZm9ydW0gdG9waWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNyZW9wZW5mb3J1bXRvcGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlb3BlbkZvcnVtVG9waWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW9wZW5Gb3J1bVRvcGljKGNoYXRJZCwgbWVzc2FnZVRocmVhZElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV90aHJlYWRfaWQgPSBtZXNzYWdlVGhyZWFkSWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncmVvcGVuRm9ydW1Ub3BpYycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIGEgZm9ydW0gdG9waWMgYWxvbmcgd2l0aCBhbGwgaXRzIG1lc3NhZ2VzIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX2RlbGV0ZV9tZXNzYWdlcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtZXNzYWdlVGhyZWFkSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgbWVzc2FnZSB0aHJlYWQgb2YgdGhlIGZvcnVtIHRvcGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRlZm9ydW10b3BpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVGb3J1bVRvcGljJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlRm9ydW1Ub3BpYyhjaGF0SWQsIG1lc3NhZ2VUaHJlYWRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLm1lc3NhZ2VfdGhyZWFkX2lkID0gbWVzc2FnZVRocmVhZElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZUZvcnVtVG9waWMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNsZWFyIHRoZSBsaXN0IG9mIHBpbm5lZCBtZXNzYWdlcyBpbiBhIGZvcnVtIHRvcGljLlxuICAgICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX3Bpbl9tZXNzYWdlcyBhZG1pbmlzdHJhdG9yIHJpZ2h0IGluIHRoZSBzdXBlcmdyb3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1lc3NhZ2VUaHJlYWRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBtZXNzYWdlIHRocmVhZCBvZiB0aGUgZm9ydW0gdG9waWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bnBpbmFsbGZvcnVtdG9waWNtZXNzYWdlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bnBpbkFsbEZvcnVtVG9waWNNZXNzYWdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucGluQWxsRm9ydW1Ub3BpY01lc3NhZ2VzKGNoYXRJZCwgbWVzc2FnZVRocmVhZElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV90aHJlYWRfaWQgPSBtZXNzYWdlVGhyZWFkSWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgndW5waW5BbGxGb3J1bVRvcGljTWVzc2FnZXMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCB0aGUgbmFtZSBvZiB0aGUgJ0dlbmVyYWwnIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fbWFuYWdlX3RvcGljcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICAqIFRoZSB0b3BpYyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdW5oaWRkZW4gaWYgaXQgd2FzIGhpZGRlbi5cbiAgICAqXG4gICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5ldyB0b3BpYyBuYW1lLCAxLTEyOCBjaGFyYWN0ZXJzXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdGdlbmVyYWxmb3J1bXRvcGljXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZWRpdEdlbmVyYWxGb3J1bVRvcGljJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdEdlbmVyYWxGb3J1bVRvcGljKGNoYXRJZCwgbmFtZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRHZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjbG9zZSBhbiBvcGVuICdHZW5lcmFsJyB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICAgKiBUaGUgdG9waWMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVuaGlkZGVuIGlmIGl0IHdhcyBoaWRkZW4uXG4gICAgKlxuICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY2xvc2VnZW5lcmFsZm9ydW10b3BpY1xuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Nsb3NlR2VuZXJhbEZvcnVtVG9waWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZUdlbmVyYWxGb3J1bVRvcGljKGNoYXRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY2xvc2VHZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZW9wZW4gYSBjbG9zZWQgJ0dlbmVyYWwnIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fbWFuYWdlX3RvcGljcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICAqIFRoZSB0b3BpYyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdW5oaWRkZW4gaWYgaXQgd2FzIGhpZGRlbi5cbiAgICAqXG4gICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNyZW9wZW5nZW5lcmFsZm9ydW10b3BpY1xuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlb3BlbkdlbmVyYWxGb3J1bVRvcGljJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVvcGVuR2VuZXJhbEZvcnVtVG9waWMoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdyZW9wZW5HZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBoaWRlIHRoZSAnR2VuZXJhbCcgdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAgICogVGhlIHRvcGljIHdpbGwgYmUgYXV0b21hdGljYWxseSBjbG9zZWQgaWYgaXQgd2FzIG9wZW4uXG4gICAgKlxuICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjaGlkZWdlbmVyYWxmb3J1bXRvcGljXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGlkZUdlbmVyYWxGb3J1bVRvcGljJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZUdlbmVyYWxGb3J1bVRvcGljKGNoYXRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnaGlkZUdlbmVyYWxGb3J1bVRvcGljJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byB1bmhpZGUgdGhlICdHZW5lcmFsJyB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bmhpZGVnZW5lcmFsZm9ydW10b3BpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bmhpZGVHZW5lcmFsRm9ydW1Ub3BpYycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuaGlkZUdlbmVyYWxGb3J1bVRvcGljKGNoYXRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgndW5oaWRlR2VuZXJhbEZvcnVtVG9waWMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNsZWFyIHRoZSBsaXN0IG9mIHBpbm5lZCBtZXNzYWdlcyBpbiBhIEdlbmVyYWwgZm9ydW0gdG9waWMuXG4gICAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fcGluX21lc3NhZ2VzIGFkbWluaXN0cmF0b3IgcmlnaHQgaW4gdGhlIHN1cGVyZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bnBpbmFsbGdlbmVyYWxmb3J1bXRvcGljbWVzc2FnZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5waW5BbGxHZW5lcmFsRm9ydW1Ub3BpY01lc3NhZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5waW5BbGxHZW5lcmFsRm9ydW1Ub3BpY01lc3NhZ2VzKGNoYXRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgndW5oaWRlR2VuZXJhbEZvcnVtVG9waWMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgYW5zd2VycyB0byBjYWxsYmFjayBxdWVyaWVzIHNlbnQgZnJvbVxuICAgICAqIFtpbmxpbmUga2V5Ym9hcmRzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMjaW5saW5lLWtleWJvYXJkcy1hbmQtb24tdGhlLWZseS11cGRhdGluZykuXG4gICAgICpcbiAgICAgKiBUaGUgYW5zd2VyIHdpbGwgYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIGFzIGEgbm90aWZpY2F0aW9uIGF0IHRoZSB0b3Agb2YgdGhlIGNoYXQgc2NyZWVuIG9yIGFzIGFuIGFsZXJ0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaGFzICoqb2xkZXIsIGNvbXBhdGlibGUgc2lnbmF0dXJlcyAoWzFdW2Fuc3dlckNhbGxiYWNrUXVlcnktdjAuMjcuMV0pKFsyXVthbnN3ZXJDYWxsYmFja1F1ZXJ5LXYwLjI5LjBdKSoqXG4gICAgICogdGhhdCBhcmUgYmVpbmcgZGVwcmVjYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gY2FsbGJhY2tRdWVyeUlkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcXVlcnkgdG8gYmUgYW5zd2VyZWRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYW5zd2VyY2FsbGJhY2txdWVyeVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhbnN3ZXJDYWxsYmFja1F1ZXJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5zd2VyQ2FsbGJhY2tRdWVyeShjYWxsYmFja1F1ZXJ5SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgLyogVGhlIG9sZGVyIG1ldGhvZCBzaWduYXR1cmUgKGluL2JlZm9yZSB2MC4yNy4xKSB3YXMgYW5zd2VyQ2FsbGJhY2tRdWVyeShjYWxsYmFja1F1ZXJ5SWQsIHRleHQsIHNob3dBbGVydCkuXG4gICAgICAgKiBXZSBuZWVkIHRvIGVuc3VyZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aGlsZSBtYWludGFpbmluZ1xuICAgICAgICogY29uc2lzdGVuY3kgb2YgdGhlIG1ldGhvZCBzaWduYXR1cmVzIHRocm91Z2hvdXQgdGhlIGxpYnJhcnkgKi9cbiAgICAgIGlmICgodHlwZW9mIGZvcm0gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGZvcm0pKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgICBkZXByZWNhdGUoJ1RoZSBtZXRob2Qgc2lnbmF0dXJlIGFuc3dlckNhbGxiYWNrUXVlcnkoY2FsbGJhY2tRdWVyeUlkLCB0ZXh0LCBzaG93QWxlcnQpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjAuMjcuMScpO1xuICAgICAgICBmb3JtID0ge1xuICAgICAgICAgIGNhbGxiYWNrX3F1ZXJ5X2lkOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgdGV4dDogYXJndW1lbnRzWzFdLFxuICAgICAgICAgIHNob3dfYWxlcnQ6IGFyZ3VtZW50c1syXVxuICAgICAgICB9O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgIH1cbiAgICAgIC8qIFRoZSBvbGRlciBtZXRob2Qgc2lnbmF0dXJlIChpbi9iZWZvcmUgdjAuMjkuMCkgd2FzIGFuc3dlckNhbGxiYWNrUXVlcnkoW29wdGlvbnNdKS5cbiAgICAgICAqIFdlIG5lZWQgdG8gZW5zdXJlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdoaWxlIG1haW50YWluaW5nXG4gICAgICAgKiBjb25zaXN0ZW5jeSBvZiB0aGUgbWV0aG9kIHNpZ25hdHVyZXMgdGhyb3VnaG91dCB0aGUgbGlicmFyeS4gKi9cbiAgICAgIGlmICgodHlwZW9mIGNhbGxiYWNrUXVlcnlJZCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2FsbGJhY2tRdWVyeUlkKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgICAgZGVwcmVjYXRlKCdUaGUgbWV0aG9kIHNpZ25hdHVyZSBhbnN3ZXJDYWxsYmFja1F1ZXJ5KFtvcHRpb25zXSkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2MC4yOS4wJyk7XG4gICAgICAgIGZvcm0gPSBjYWxsYmFja1F1ZXJ5SWQ7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybS5jYWxsYmFja19xdWVyeV9pZCA9IGNhbGxiYWNrUXVlcnlJZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdhbnN3ZXJDYWxsYmFja1F1ZXJ5JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGxpc3Qgb2YgYm9vc3RzIGFkZGVkIHRvIGEgY2hhdCBieSBhIHVzZS5cbiAgICAgKiBSZXF1aXJlcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cyBpbiB0aGUgY2hhdFxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGdyb3VwL2NoYW5uZWxcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJfaWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgcmV0dXJucyBhIFtVc2VyQ2hhdEJvb3N0c10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1c2VyY2hhdGJvb3N0cykgb2JqZWN0XG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHVzZXJjaGF0Ym9vc3RzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFVzZXJDaGF0Qm9vc3RzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VXNlckNoYXRCb29zdHMoY2hhdElkLCBwb2xsSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX2lkID0gcG9sbElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldFVzZXJDaGF0Qm9vc3RzJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbm5lY3Rpb24gb2YgdGhlIGJvdCB3aXRoIGEgYnVzaW5lc3MgYWNjb3VudFxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gYnVzaW5lc3NDb25uZWN0aW9uSWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAvY2hhbm5lbFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHJldHVybnMgW0J1c2luZXNzQ29ubmVjdGlvbl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNidXNpbmVzc2Nvbm5lY3Rpb24pIG9iamVjdFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRidXNpbmVzc2Nvbm5lY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0QnVzaW5lc3NDb25uZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QnVzaW5lc3NDb25uZWN0aW9uKGJ1c2luZXNzQ29ubmVjdGlvbklkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uYnVzaW5lc3NfY29ubmVjdGlvbl9pZCA9IGJ1c2luZXNzQ29ubmVjdGlvbklkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldEJ1c2luZXNzQ29ubmVjdGlvbicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBsaXN0IG9mIHRoZSBib3QncyBjb21tYW5kcy5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMjY29tbWFuZHMgZm9yIG1vcmUgZGV0YWlscyBhYm91dCBib3QgY29tbWFuZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBjb21tYW5kcyAgTGlzdCBvZiBib3QgY29tbWFuZHMgdG8gYmUgc2V0IGFzIHRoZSBsaXN0IG9mIHRoZSBbYm90J3MgY29tbWFuZHNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYm90Y29tbWFuZCkuIEF0IG1vc3QgMTAwIGNvbW1hbmRzIGNhbiBiZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldG15Y29tbWFuZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0TXlDb21tYW5kcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE15Q29tbWFuZHMoY29tbWFuZHMpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5jb21tYW5kcyA9IHN0cmluZ2lmeShjb21tYW5kcyk7XG5cbiAgICAgIGlmIChmb3JtLnNjb3BlKSB7XG4gICAgICAgIGZvcm0uc2NvcGUgPSBzdHJpbmdpZnkoZm9ybS5zY29wZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRNeUNvbW1hbmRzJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgdGhlIGxpc3Qgb2YgdGhlIGJvdCdzIGNvbW1hbmRzIGZvciB0aGUgZ2l2ZW4gc2NvcGUgYW5kIHVzZXIgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiAgQWZ0ZXIgZGVsZXRpb24sIFtoaWdoZXIgbGV2ZWwgY29tbWFuZHNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGV0ZXJtaW5pbmctbGlzdC1vZi1jb21tYW5kcykgd2lsbCBiZSBzaG93biB0byBhZmZlY3RlZCB1c2Vycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGVteWNvbW1hbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZU15Q29tbWFuZHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVNeUNvbW1hbmRzKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlTXlDb21tYW5kcycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBjdXJyZW50IGxpc3Qgb2YgdGhlIGJvdCdzIGNvbW1hbmRzIGZvciB0aGUgZ2l2ZW4gc2NvcGUgYW5kIHVzZXIgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBcnJheSBvZiBbQm90Q29tbWFuZF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNib3Rjb21tYW5kKSBvbiBzdWNjZXNzLiBJZiBjb21tYW5kcyBhcmVuJ3Qgc2V0LCBhbiBlbXB0eSBsaXN0IGlzIHJldHVybmVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRteWNvbW1hbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE15Q29tbWFuZHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNeUNvbW1hbmRzKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAoZm9ybS5zY29wZSkge1xuICAgICAgICBmb3JtLnNjb3BlID0gc3RyaW5naWZ5KGZvcm0uc2NvcGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldE15Q29tbWFuZHMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgYm90J3MgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRteW5hbWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0TXlOYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TXlOYW1lKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0TXlOYW1lJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgYm90IG5hbWUgZm9yIHRoZSBnaXZlbiB1c2VyIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gW0JvdE5hbWVdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYm90bmFtZSkgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRteW5hbWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TXlOYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXlOYW1lKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0TXlOYW1lJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGJvdCdzIGRlc2NyaXB0aW9uLCB3aGljaCBpcyBzaG93biBpbiB0aGUgY2hhdCB3aXRoIHRoZSBib3QgaWYgdGhlIGNoYXQgaXMgZW1wdHkuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIFRydWUgb24gc3VjY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRteWRlc2NyaXB0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldE15RGVzY3JpcHRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNeURlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0TXlEZXNjcmlwdGlvbicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBjdXJyZW50IGJvdCBkZXNjcmlwdGlvbiBmb3IgdGhlIGdpdmVuIHVzZXIgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIFtCb3REZXNjcmlwdGlvbl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNib3RkZXNjcmlwdGlvbikgb24gc3VjY2Vzcy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0bXlkZXNjcmlwdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNeURlc2NyaXB0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXlEZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldE15RGVzY3JpcHRpb24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgYm90J3Mgc2hvcnQgZGVzY3JpcHRpb24sIHdoaWNoIGlzIHNob3duIG9uIHRoZSBib3QncyBwcm9maWxlIHBhZ2VcbiAgICAgKiBhbmQgaXMgc2VudCB0b2dldGhlciB3aXRoIHRoZSBsaW5rIHdoZW4gdXNlcnMgc2hhcmUgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgVHJ1ZSBvbiBzdWNjZXNzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRteXNob3J0ZGVzY3JpcHRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0TXlTaG9ydERlc2NyaXB0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TXlTaG9ydERlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0TXlTaG9ydERlc2NyaXB0aW9uJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgYm90IHNob3J0IGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gdXNlciBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgW0JvdFNob3J0RGVzY3JpcHRpb25dKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYm90c2hvcnRkZXNjcmlwdGlvbikgb24gc3VjY2Vzcy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0bXlzaG9ydGRlc2NyaXB0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE15U2hvcnREZXNjcmlwdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE15U2hvcnREZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldE15U2hvcnREZXNjcmlwdGlvbicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBib3QncyBtZW51IGJ1dHRvbiBpbiBhIHByaXZhdGUgY2hhdCwgb3IgdGhlIGRlZmF1bHQgbWVudSBidXR0b24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y2hhdG1lbnVidXR0b25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0Q2hhdE1lbnVCdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGF0TWVudUJ1dHRvbigpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldENoYXRNZW51QnV0dG9uJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGJvdCdzIG1lbnUgYnV0dG9uIGluIGEgcHJpdmF0ZSBjaGF0LCBvciB0aGUgZGVmYXVsdCBtZW51IGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFtNZW51QnV0dG9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lbnVidXR0b24pIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Y2hhdG1lbnVidXR0b25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q2hhdE1lbnVCdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGF0TWVudUJ1dHRvbigpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldENoYXRNZW51QnV0dG9uJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGRlZmF1bHQgYWRtaW5pc3RyYXRvciByaWdodHMgcmVxdWVzdGVkIGJ5IHRoZSBib3Qgd2hlbiBpdCdzIGFkZGVkIGFzIGFuIGFkbWluaXN0cmF0b3IgdG8gZ3JvdXBzIG9yIGNoYW5uZWxzLlxuICAgICAqXG4gICAgICogVGhlc2UgcmlnaHRzIHdpbGwgYmUgc3VnZ2VzdGVkIHRvIHVzZXJzLCBidXQgdGhleSBhcmUgYXJlIGZyZWUgdG8gbW9kaWZ5IHRoZSBsaXN0IGJlZm9yZSBhZGRpbmcgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0bWVudWJ1dHRvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRNeURlZmF1bHRBZG1pbmlzdHJhdG9yUmlnaHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TXlEZWZhdWx0QWRtaW5pc3RyYXRvclJpZ2h0cygpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldE15RGVmYXVsdEFkbWluaXN0cmF0b3JSaWdodHMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB0aGUgY3VycmVudCBkZWZhdWx0IGFkbWluaXN0cmF0b3IgcmlnaHRzIG9mIHRoZSBib3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBbQ2hhdEFkbWluaXN0cmF0b3JSaWdodHNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY2hhdGFkbWluaXN0cmF0b3JyaWdodHMpIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0bXlkZWZhdWx0YWRtaW5pc3RyYXRvcnJpZ2h0c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNeURlZmF1bHRBZG1pbmlzdHJhdG9yUmlnaHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXlEZWZhdWx0QWRtaW5pc3RyYXRvclJpZ2h0cygpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldE15RGVmYXVsdEFkbWluaXN0cmF0b3JSaWdodHMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgdGV4dCBvciBbZ2FtZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnYW1lcykgbWVzc2FnZXMgc2VudCBieSB0aGUgYm90IG9yIHZpYSB0aGUgYm90IChmb3IgaW5saW5lIGJvdHMpLlxuICAgICAqXG4gICAgICogTm90ZTogdGhhdCAqKnlvdSBtdXN0IHByb3ZpZGUgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkKiogaW4geW91ciByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0ICBOZXcgdGV4dCBvZiB0aGUgbWVzc2FnZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9ucyAocHJvdmlkZSBlaXRoZXIgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkIGhlcmUpXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgaWYgdGhlIGVkaXRlZCBtZXNzYWdlIGlzIG5vdCBhbiBpbmxpbmUgbWVzc2FnZSwgdGhlIGVkaXRlZCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIFRydWUgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdG1lc3NhZ2V0ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VkaXRNZXNzYWdlVGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRNZXNzYWdlVGV4dCh0ZXh0KSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0udGV4dCA9IHRleHQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VUZXh0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBlZGl0IGNhcHRpb25zIG9mIG1lc3NhZ2VzIHNlbnQgYnkgdGhlIGJvdCBvciB2aWEgdGhlIGJvdCAoZm9yIGlubGluZSBib3RzKS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFlvdSAqKm11c3QgcHJvdmlkZSBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3IgaW5saW5lX21lc3NhZ2VfaWQqKiBpbiB5b3VyIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNhcHRpb24gIE5ldyBjYXB0aW9uIG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zIChwcm92aWRlIGVpdGhlciBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3IgaW5saW5lX21lc3NhZ2VfaWQgaGVyZSlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBpZiB0aGUgZWRpdGVkIG1lc3NhZ2UgaXMgbm90IGFuIGlubGluZSBtZXNzYWdlLCB0aGUgZWRpdGVkIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkLCBvdGhlcndpc2UgVHJ1ZSBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0bWVzc2FnZWNhcHRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZWRpdE1lc3NhZ2VDYXB0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE1lc3NhZ2VDYXB0aW9uKGNhcHRpb24pIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5jYXB0aW9uID0gY2FwdGlvbjtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdlZGl0TWVzc2FnZUNhcHRpb24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgYW5pbWF0aW9uLCBhdWRpbywgZG9jdW1lbnQsIHBob3RvLCBvciB2aWRlbyBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIElmIGEgbWVzc2FnZSBpcyBhIHBhcnQgb2YgYSBtZXNzYWdlIGFsYnVtLCB0aGVuIGl0IGNhbiBiZSBlZGl0ZWQgb25seSB0byBhIHBob3RvIG9yIGEgdmlkZW8uXG4gICAgICpcbiAgICAgKiBPdGhlcndpc2UsIG1lc3NhZ2UgdHlwZSBjYW4gYmUgY2hhbmdlZCBhcmJpdHJhcmlseS4gV2hlbiBpbmxpbmUgbWVzc2FnZSBpcyBlZGl0ZWQsIG5ldyBmaWxlIGNhbid0IGJlIHVwbG9hZGVkLlxuICAgICAqIFVzZSBwcmV2aW91c2x5IHVwbG9hZGVkIGZpbGUgdmlhIGl0cyBmaWxlX2lkIG9yIHNwZWNpZnkgYSBVUkwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBZb3UgKiptdXN0IHByb3ZpZGUgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkKiogaW4geW91ciByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBtZWRpYSAgQSBKU09OLXNlcmlhbGl6ZWQgb2JqZWN0IGZvciBhIG5ldyBtZWRpYSBjb250ZW50IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zIChwcm92aWRlIGVpdGhlciBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3IgaW5saW5lX21lc3NhZ2VfaWQgaGVyZSlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBpZiB0aGUgZWRpdGVkIG1lc3NhZ2UgaXMgbm90IGFuIGlubGluZSBtZXNzYWdlLCB0aGUgZWRpdGVkIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkLCBvdGhlcndpc2UgVHJ1ZSBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0bWVzc2FnZW1lZGlhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VkaXRNZXNzYWdlTWVkaWEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0TWVzc2FnZU1lZGlhKG1lZGlhKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHZhciByZWdleEF0dGFjaCA9IC9hdHRhY2g6XFwvXFwvLisvO1xuXG4gICAgICBpZiAodHlwZW9mIG1lZGlhLm1lZGlhID09PSAnc3RyaW5nJyAmJiByZWdleEF0dGFjaC50ZXN0KG1lZGlhLm1lZGlhKSkge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICBxczogZm9ybVxuICAgICAgICB9O1xuXG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSB7fTtcblxuICAgICAgICB2YXIgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIG1lZGlhKTtcbiAgICAgICAgZGVsZXRlIHBheWxvYWQubWVkaWE7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgYXR0YWNoTmFtZSA9IFN0cmluZygwKTtcblxuICAgICAgICAgIHZhciBfZm9ybWF0U2VuZERhdGE2ID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoYXR0YWNoTmFtZSwgbWVkaWEubWVkaWEucmVwbGFjZSgnYXR0YWNoOi8vJywgJycpLCBtZWRpYS5maWxlT3B0aW9ucyksXG4gICAgICAgICAgICAgIF9mb3JtYXRTZW5kRGF0YTcgPSBfc2xpY2VkVG9BcnJheShfZm9ybWF0U2VuZERhdGE2LCAxKSxcbiAgICAgICAgICAgICAgZm9ybURhdGEgPSBfZm9ybWF0U2VuZERhdGE3WzBdO1xuXG4gICAgICAgICAgaWYgKGZvcm1EYXRhKSB7XG4gICAgICAgICAgICBvcHRzLmZvcm1EYXRhW2F0dGFjaE5hbWVdID0gZm9ybURhdGFbYXR0YWNoTmFtZV07XG4gICAgICAgICAgICBwYXlsb2FkLm1lZGlhID0gJ2F0dGFjaDovLycgKyBhdHRhY2hOYW1lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkZhdGFsRXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIHRoZSByZXBsYWNlbWVudCBhY3Rpb24gZm9yIHlvdXIgJyArIG1lZGlhLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cy5xcy5tZWRpYSA9IHN0cmluZ2lmeShwYXlsb2FkKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VNZWRpYScsIG9wdHMpO1xuICAgICAgfVxuXG4gICAgICBmb3JtLm1lZGlhID0gc3RyaW5naWZ5KG1lZGlhKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRNZXNzYWdlTWVkaWEnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgb25seSB0aGUgcmVwbHkgbWFya3VwIG9mIG1lc3NhZ2VzIHNlbnQgYnkgdGhlIGJvdCBvciB2aWEgdGhlIGJvdCAoZm9yIGlubGluZSBib3RzKS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFlvdSAqKm11c3QgcHJvdmlkZSBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3IgaW5saW5lX21lc3NhZ2VfaWQqKiBpbiB5b3VyIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlcGx5TWFya3VwICBBIEpTT04tc2VyaWFsaXplZCBvYmplY3QgZm9yIGFuIGlubGluZSBrZXlib2FyZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnMgKHByb3ZpZGUgZWl0aGVyIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCBoZXJlKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBlZGl0ZWQgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBlZGl0ZWQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2VkaXRtZXNzYWdldGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlZGl0TWVzc2FnZVJlcGx5TWFya3VwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE1lc3NhZ2VSZXBseU1hcmt1cChyZXBseU1hcmt1cCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLnJlcGx5X21hcmt1cCA9IHJlcGx5TWFya3VwO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRNZXNzYWdlUmVwbHlNYXJrdXAnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHN0b3AgYSBwb2xsIHdoaWNoIHdhcyBzZW50IGJ5IHRoZSBib3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAvY2hhbm5lbFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gcG9sbElkIElkZW50aWZpZXIgb2YgdGhlIG9yaWdpbmFsIG1lc3NhZ2Ugd2l0aCB0aGUgcG9sbFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzdG9wcGVkIFtQb2xsXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3BvbGwpIGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3N0b3Bwb2xsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3BQb2xsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcFBvbGwoY2hhdElkLCBwb2xsSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX2lkID0gcG9sbElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3N0b3BQb2xsJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIHN0YXRpYyAuV0VCUCwgW2FuaW1hdGVkXShodHRwczovL3RlbGVncmFtLm9yZy9ibG9nL2FuaW1hdGVkLXN0aWNrZXJzKSAuVEdTLFxuICAgICAqIG9yIFt2aWRlb10oaHR0cHM6Ly90ZWxlZ3JhbS5vcmcvYmxvZy92aWRlby1zdGlja2Vycy1iZXR0ZXItcmVhY3Rpb25zKSAuV0VCTSBzdGlja2Vycy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHN0aWNrZXIgQSBmaWxlIHBhdGgsIFN0cmVhbSBvciBCdWZmZXIuXG4gICAgICogQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC4gU3RpY2tlcnMgYXJlIFdlYlAgZm9ybWF0IGZpbGVzLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHN0aWNrZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZFN0aWNrZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kU3RpY2tlcihjaGF0SWQsIHN0aWNrZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBmaWxlT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdzdGlja2VyJywgc3RpY2tlciwgZmlsZU9wdGlvbnMpO1xuICAgICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICAgIG9wdHMucXMuc3RpY2tlciA9IHNlbmREYXRhWzFdO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kU3RpY2tlcicsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgYSBzdGlja2VyIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBzdGlja2VyIHNldFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGEgW1N0aWNrZXJTZXRdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc3RpY2tlcnNldCkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHN0aWNrZXJzZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0U3RpY2tlclNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0aWNrZXJTZXQobmFtZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldFN0aWNrZXJTZXQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dCBjdXN0b20gZW1vamkgc3RpY2tlcnMgYnkgdGhlaXIgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY3VzdG9tX2Vtb2ppX2lkcyBMaXN0IG9mIGN1c3RvbSBlbW9qaSBpZGVudGlmaWVycy4gQXQgbW9zdCAyMDAgY3VzdG9tIGVtb2ppIGlkZW50aWZpZXJzIGNhbiBiZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gQXJyYXkgb2YgW1N0aWNrZXJdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc3RpY2tlcikgb2JqZWN0cy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Y3VzdG9tZW1vamlzdGlja2Vyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDdXN0b21FbW9qaVN0aWNrZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VzdG9tRW1vamlTdGlja2VycyhjdXN0b21FbW9qaUlkcykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmN1c3RvbV9lbW9qaV9pZHMgPSBzdHJpbmdpZnkoY3VzdG9tRW1vamlJZHMpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldEN1c3RvbUVtb2ppU3RpY2tlcnMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHVwbG9hZCBhIGZpbGUgd2l0aCBhIHN0aWNrZXIgZm9yIGxhdGVyIHVzZSBpbiAqY3JlYXRlTmV3U3RpY2tlclNldCogYW5kICphZGRTdGlja2VyVG9TZXQqIG1ldGhvZHMgKGNhbiBiZSB1c2VkIG11bHRpcGxlXG4gICAgICogdGltZXMpLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgVXNlciBpZGVudGlmaWVyIG9mIHN0aWNrZXIgZmlsZSBvd25lclxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gc3RpY2tlciBBIGZpbGUgcGF0aCBvciBhIFN0cmVhbSB3aXRoIHRoZSBzdGlja2VyIGluIC5XRUJQLCAuUE5HLCAuVEdTLCBvciAuV0VCTSBmb3JtYXQuIENhbiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0aWNrZXJGb3JtYXQgQWxsb3cgdmFsdWVzOiAgYHN0YXRpY2AsIGBhbmltYXRlZGAgb3IgYHZpZGVvYFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgYSBbRmlsZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNmaWxlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXBsb2Fkc3RpY2tlcmZpbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBsb2FkU3RpY2tlckZpbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGxvYWRTdGlja2VyRmlsZSh1c2VySWQsIHN0aWNrZXIpIHtcbiAgICAgIHZhciBzdGlja2VyRm9ybWF0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnc3RhdGljJztcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgIHZhciBmaWxlT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG9wdHMucXMudXNlcl9pZCA9IHVzZXJJZDtcbiAgICAgIG9wdHMucXMuc3RpY2tlcl9mb3JtYXQgPSBzdGlja2VyRm9ybWF0O1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgnc3RpY2tlcicsIHN0aWNrZXIsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzLnN0aWNrZXIgPSBzZW5kRGF0YVsxXTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgndXBsb2FkU3RpY2tlckZpbGUnLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIG5ldyBzdGlja2VyIHNldCBvd25lZCBieSBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBUaGUgYm90IHdpbGwgYmUgYWJsZSB0byBlZGl0IHRoZSBjcmVhdGVkIHN0aWNrZXIgc2V0LlxuICAgICAqXG4gICAgICogWW91IG11c3QgdXNlIGV4YWN0bHkgb25lIG9mIHRoZSBmaWVsZHMgKnBuZ19zdGlja2VyKiwgKnRnc19zdGlja2VyKiwgb3IgKndlYm1fc3RpY2tlcipcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkIFVzZXIgaWRlbnRpZmllciBvZiBjcmVhdGVkIHN0aWNrZXIgc2V0IG93bmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFNob3J0IG5hbWUgb2Ygc3RpY2tlciBzZXQsIHRvIGJlIHVzZWQgaW4gYHQubWUvYWRkc3RpY2tlcnMvYCBVUkxzIChlLmcuLCAgICpcImFuaW1hbHNcIiopLiBDYW4gY29udGFpbiBvbmx5IGVuZ2xpc2ggbGV0dGVycywgZGlnaXRzIGFuZCB1bmRlcnNjb3Jlcy5cbiAgICAgKiAgTXVzdCBiZWdpbiB3aXRoIGEgbGV0dGVyLCBjYW4ndCBjb250YWluIGNvbnNlY3V0aXZlIHVuZGVyc2NvcmVzIGFuZCBtdXN0IGVuZCBpbiBgXCJfYnlfPGJvdF91c2VybmFtZT5cImAuIGA8Ym90X3VzZXJuYW1lPmAgaXMgY2FzZSBpbnNlbnNpdGl2ZS4gMS02NCBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGUgU3RpY2tlciBzZXQgdGl0bGUsIDEtNjQgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gcG5nU3RpY2tlciBQbmcgaW1hZ2Ugd2l0aCB0aGUgc3RpY2tlciwgbXVzdCBiZSB1cCB0byA1MTIga2lsb2J5dGVzIGluIHNpemUsXG4gICAgICogIGRpbWVuc2lvbnMgbXVzdCBub3QgZXhjZWVkIDUxMnB4LCBhbmQgZWl0aGVyIHdpZHRoIG9yIGhlaWdodCBtdXN0IGJlIGV4YWN0bHkgNTEycHguXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBlbW9qaXMgT25lIG9yIG1vcmUgZW1vamkgY29ycmVzcG9uZGluZyB0byB0aGUgc3RpY2tlclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjcmVhdGVuZXdzdGlja2Vyc2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZU5ld1N0aWNrZXJTZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVOZXdTdGlja2VyU2V0KHVzZXJJZCwgbmFtZSwgdGl0bGUsIHBuZ1N0aWNrZXIsIGVtb2ppcykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy51c2VyX2lkID0gdXNlcklkO1xuICAgICAgb3B0cy5xcy5uYW1lID0gbmFtZTtcbiAgICAgIG9wdHMucXMudGl0bGUgPSB0aXRsZTtcbiAgICAgIG9wdHMucXMuZW1vamlzID0gZW1vamlzO1xuICAgICAgb3B0cy5xcy5tYXNrX3Bvc2l0aW9uID0gc3RyaW5naWZ5KG9wdGlvbnMubWFza19wb3NpdGlvbik7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgncG5nX3N0aWNrZXInLCBwbmdTdGlja2VyLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgICAgb3B0cy5xcy5wbmdfc3RpY2tlciA9IHNlbmREYXRhWzFdO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjcmVhdGVOZXdTdGlja2VyU2V0Jywgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGFkZCBhIG5ldyBzdGlja2VyIHRvIGEgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIFlvdSBtdXN0IHVzZSBleGFjdGx5IG9uZSBvZiB0aGUgZmllbGRzICpwbmdfc3RpY2tlciosICp0Z3Nfc3RpY2tlciosIG9yICp3ZWJtX3N0aWNrZXIqXG4gICAgICpcbiAgICAgKiBBbmltYXRlZCBzdGlja2VycyBjYW4gYmUgYWRkZWQgdG8gYW5pbWF0ZWQgc3RpY2tlciBzZXRzIGFuZCBvbmx5IHRvIHRoZW1cbiAgICAgKlxuICAgICAqIE5vdGU6XG4gICAgICogLSBFbW9qaSBzdGlja2VyIHNldHMgY2FuIGhhdmUgdXAgdG8gMjAwIHN0aWNrZXJcbiAgICAgKiAtIFN0YXRpYyBvciBBbmltYXRlZCBzdGlja2VyIHNldHMgY2FuIGhhdmUgdXAgdG8gMTIwIHN0aWNrZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCBVc2VyIGlkZW50aWZpZXIgb2Ygc3RpY2tlciBzZXQgb3duZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU3RpY2tlciBzZXQgbmFtZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gc3RpY2tlciBQbmcgaW1hZ2Ugd2l0aCB0aGUgc3RpY2tlciAobXVzdCBiZSB1cCB0byA1MTIga2lsb2J5dGVzIGluIHNpemUsXG4gICAgICogZGltZW5zaW9ucyBtdXN0IG5vdCBleGNlZWQgNTEycHgsIGFuZCBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG11c3QgYmUgZXhhY3RseSA1MTJweCwgW1RHUyBhbmltYXRpb25dKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvc3RpY2tlcnMjYW5pbWF0ZWQtc3RpY2tlci1yZXF1aXJlbWVudHMpXG4gICAgICogd2l0aCB0aGUgc3RpY2tlciBvciBbV0VCTSB2aWRlb10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9zdGlja2VycyN2aWRlby1zdGlja2VyLXJlcXVpcmVtZW50cykgd2l0aCB0aGUgc3RpY2tlci5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVtb2ppcyBPbmUgb3IgbW9yZSBlbW9qaSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdGlja2VyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzdGlja2VyVHlwZSBBbGxvdyB2YWx1ZXM6IGBwbmdfc3RpY2tlcmAsIGB0Z3Nfc3RpY2tlcmAsIG9yIGB3ZWJtX3N0aWNrZXJgLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gIFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhZGRzdGlja2VydG9zZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkU3RpY2tlclRvU2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU3RpY2tlclRvU2V0KHVzZXJJZCwgbmFtZSwgc3RpY2tlciwgZW1vamlzKSB7XG4gICAgICB2YXIgc3RpY2tlclR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6ICdwbmdfc3RpY2tlcic7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgICB2YXIgZmlsZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHt9O1xuXG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgcXM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgICBvcHRzLnFzLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICBvcHRzLnFzLm5hbWUgPSBuYW1lO1xuICAgICAgb3B0cy5xcy5lbW9qaXMgPSBlbW9qaXM7XG4gICAgICBvcHRzLnFzLm1hc2tfcG9zaXRpb24gPSBzdHJpbmdpZnkob3B0aW9ucy5tYXNrX3Bvc2l0aW9uKTtcblxuICAgICAgaWYgKHR5cGVvZiBzdGlja2VyVHlwZSAhPT0gJ3N0cmluZycgfHwgWydwbmdfc3RpY2tlcicsICd0Z3Nfc3RpY2tlcicsICd3ZWJtX3N0aWNrZXInXS5pbmRleE9mKHN0aWNrZXJUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignc3RpY2tlclR5cGUgbXVzdCBiZSBhIHN0cmluZyBhbmQgdGhlIGFsbG93IHR5cGVzIGlzOiBwbmdfc3RpY2tlciwgdGdzX3N0aWNrZXIsIHdlYm1fc3RpY2tlcicpKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoc3RpY2tlclR5cGUsIHN0aWNrZXIsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzW3N0aWNrZXJUeXBlXSA9IHNlbmREYXRhWzFdO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdhZGRTdGlja2VyVG9TZXQnLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gbW92ZSBhIHN0aWNrZXIgaW4gYSBzZXQgY3JlYXRlZCBieSB0aGUgYm90IHRvIGEgc3BlY2lmaWMgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXIgRmlsZSBpZGVudGlmaWVyIG9mIHRoZSBzdGlja2VyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBwb3NpdGlvbiBOZXcgc3RpY2tlciBwb3NpdGlvbiBpbiB0aGUgc2V0LCB6ZXJvLWJhc2VkXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHN0aWNrZXJwb3NpdGlvbmluc2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFN0aWNrZXJQb3NpdGlvbkluU2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RpY2tlclBvc2l0aW9uSW5TZXQoc3RpY2tlciwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5zdGlja2VyID0gc3RpY2tlcjtcbiAgICAgIGZvcm0ucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRTdGlja2VyUG9zaXRpb25JblNldCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIGEgc3RpY2tlciBmcm9tIGEgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlciBGaWxlIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRlc3RpY2tlcmZyb21zZXRcbiAgICAgKiBAdG9kbyBBZGQgdGVzdHMgZm9yIHRoaXMgbWV0aG9kIVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVTdGlja2VyRnJvbVNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVN0aWNrZXJGcm9tU2V0KHN0aWNrZXIpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5zdGlja2VyID0gc3RpY2tlcjtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVTdGlja2VyRnJvbVNldCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVwbGFjZSBhbiBleGlzdGluZyBzdGlja2VyIGluIGEgc3RpY2tlciBzZXQgd2l0aCBhIG5ldyBvbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcl9pZCBVc2VyIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXIgc2V0IG93bmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFN0aWNrZXIgc2V0IG5hbWVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXIgRmlsZSBpZGVudGlmaWVyIG9mIHRoZSBzdGlja2VyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3JlcGxhY2VzdGlja2VyaW5zZXRcbiAgICAgKiBAdG9kbyBBZGQgdGVzdHMgZm9yIHRoaXMgbWV0aG9kIVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlU3RpY2tlckluU2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVN0aWNrZXJJblNldCh1c2VySWQsIG5hbWUsIG9sZFN0aWNrZXIpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgICAgZm9ybS5uYW1lID0gbmFtZTtcbiAgICAgIGZvcm0ub2xkX3N0aWNrZXIgPSBvbGRTdGlja2VyO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZVN0aWNrZXJGcm9tU2V0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGxpc3Qgb2YgZW1vamkgYXNzaWduZWQgdG8gYSByZWd1bGFyIG9yIGN1c3RvbSBlbW9qaSBzdGlja2VyLlxuICAgICAqXG4gICAgICogVGhlIHN0aWNrZXIgbXVzdCBiZWxvbmcgdG8gYSBzdGlja2VyIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXIgRmlsZSBpZGVudGlmaWVyIG9mIHRoZSBzdGlja2VyXG4gICAgICogQHBhcmFtIHsgQXJyYXkgfSBlbW9qaUxpc3QgQSBKU09OLXNlcmlhbGl6ZWQgbGlzdCBvZiAxLTIwIGVtb2ppIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3RpY2tlclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRzdGlja2VyZW1vamlsaXN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFN0aWNrZXJFbW9qaUxpc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdGlja2VyRW1vamlMaXN0KHN0aWNrZXIsIGVtb2ppTGlzdCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLnN0aWNrZXIgPSBzdGlja2VyO1xuICAgICAgZm9ybS5lbW9qaV9saXN0ID0gc3RyaW5naWZ5KGVtb2ppTGlzdCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0U3RpY2tlckVtb2ppTGlzdCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBsaXN0IG9mIGVtb2ppIGFzc2lnbmVkIHRvIGEgYHJlZ3VsYXJgIG9yIGBjdXN0b20gZW1vamlgIHN0aWNrZXIuXG4gICAgICpcbiAgICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlciBGaWxlIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0c3RpY2tlcmtleXdvcmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFN0aWNrZXJLZXl3b3JkcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0aWNrZXJLZXl3b3JkcyhzdGlja2VyKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uc3RpY2tlciA9IHN0aWNrZXI7XG4gICAgICBpZiAoZm9ybS5rZXl3b3Jkcykge1xuICAgICAgICBmb3JtLmtleXdvcmRzID0gc3RyaW5naWZ5KGZvcm0ua2V5d29yZHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJLZXl3b3JkcycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBbbWFzayBwb3NpdGlvbl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtYXNrcG9zaXRpb24pIG9mIGEgbWFzayBzdGlja2VyLlxuICAgICAqXG4gICAgICogVGhlIHN0aWNrZXIgbXVzdCBiZWxvbmcgdG8gYSBzdGlja2VyIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXIgRmlsZSBpZGVudGlmaWVyIG9mIHRoZSBzdGlja2VyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHN0aWNrZXJtYXNrcG9zaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0U3RpY2tlck1hc2tQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0aWNrZXJNYXNrUG9zaXRpb24oc3RpY2tlcikge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLnN0aWNrZXIgPSBzdGlja2VyO1xuICAgICAgaWYgKGZvcm0ubWFza19wb3NpdGlvbikge1xuICAgICAgICBmb3JtLm1hc2tfcG9zaXRpb24gPSBzdHJpbmdpZnkoZm9ybS5tYXNrX3Bvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRTdGlja2VyTWFza1Bvc2l0aW9uJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgdGhlIHRpdGxlIG9mIGEgY3JlYXRlZCBzdGlja2VyIHNldC5cbiAgICAgKlxuICAgICAqIFRoZSBzdGlja2VyIG11c3QgYmVsb25nIHRvIGEgc3RpY2tlciBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFN0aWNrZXIgc2V0IG5hbWVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlIFN0aWNrZXIgc2V0IHRpdGxlLCAxLTY0IGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0c3RpY2tlcnNldHRpdGxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFN0aWNrZXJTZXRUaXRsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0aWNrZXJTZXRUaXRsZShuYW1lLCB0aXRsZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgICAgZm9ybS50aXRsZSA9IHRpdGxlO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJTZXRUaXRsZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gYWRkIGEgdGh1bWIgdG8gYSBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgICAqXG4gICAgICogQW5pbWF0ZWQgdGh1bWJuYWlscyBjYW4gYmUgc2V0IGZvciBhbmltYXRlZCBzdGlja2VyIHNldHMgb25seS4gVmlkZW8gdGh1bWJuYWlscyBjYW4gYmUgc2V0IG9ubHkgZm9yIHZpZGVvIHN0aWNrZXIgc2V0cyBvbmx5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCBVc2VyIGlkZW50aWZpZXIgb2Ygc3RpY2tlciBzZXQgb3duZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU3RpY2tlciBzZXQgbmFtZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gdGh1bWJuYWlsIEEgLldFQlAgb3IgLlBORyBpbWFnZSB3aXRoIHRoZSB0aHVtYm5haWwsXG4gICAgICogbXVzdCBiZSB1cCB0byAxMjgga2lsb2J5dGVzIGluIHNpemUgYW5kIGhhdmUgd2lkdGggYW5kIGhlaWdodCBleGFjdGx5IDEwMHB4LFxuICAgICAqIGEgVEdTIGFuaW1hdGlvbiB3aXRoIHRoZSB0aHVtYm5haWwgdXAgdG8gMzIga2lsb2J5dGVzIGluIHNpemUgb3IgYSBXRUJNIHZpZGVvIHdpdGggdGhlIHRodW1ibmFpbCB1cCB0byAzMiBraWxvYnl0ZXMgaW4gc2l6ZS5cbiAgICAgKlxuICAgICAqIFBhc3MgYSBmaWxlX2lkIGFzIGEgU3RyaW5nIHRvIHNlbmQgYSBmaWxlIHRoYXQgYWxyZWFkeSBleGlzdHMgb24gdGhlIFRlbGVncmFtIHNlcnZlcnMsIHBhc3MgYW4gSFRUUCBVUkwgYXMgYSBTdHJpbmcgZm9yIFRlbGVncmFtXG4gICAgICogdG8gZ2V0IGEgZmlsZSBmcm9tIHRoZSBJbnRlcm5ldCwgb3IgdXBsb2FkIGEgbmV3IG9uZS4gQW5pbWF0ZWQgc3RpY2tlciBzZXQgdGh1bWJuYWlscyBjYW4ndCBiZSB1cGxvYWRlZCB2aWEgSFRUUCBVUkwuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0c3RpY2tlcnNldHRodW1ibmFpbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTdGlja2VyU2V0VGh1bWJuYWlsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RpY2tlclNldFRodW1ibmFpbCh1c2VySWQsIG5hbWUsIHRodW1ibmFpbCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy51c2VyX2lkID0gdXNlcklkO1xuICAgICAgb3B0cy5xcy5uYW1lID0gbmFtZTtcbiAgICAgIG9wdHMucXMubWFza19wb3NpdGlvbiA9IHN0cmluZ2lmeShvcHRpb25zLm1hc2tfcG9zaXRpb24pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3RodW1ibmFpbCcsIHRodW1ibmFpbCwgZmlsZU9wdGlvbnMpO1xuICAgICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICAgIG9wdHMucXMudGh1bWJuYWlsID0gc2VuZERhdGFbMV07XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJTZXRUaHVtYm5haWwnLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2V0IHRoZSB0aHVtYm5haWwgb2YgYSBjdXN0b20gZW1vamkgc3RpY2tlciBzZXQuXG4gICAgICpcbiAgICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBTdGlja2VyIHNldCBuYW1lXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGN1c3RvbWVtb2ppc3RpY2tlcnNldHRodW1ibmFpbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDdXN0b21FbW9qaVN0aWNrZXJTZXRUaHVtYm5haWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXN0b21FbW9qaVN0aWNrZXJTZXRUaHVtYm5haWwobmFtZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldEN1c3RvbUVtb2ppU3RpY2tlclNldFRodW1ibmFpbCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIGEgc3RpY2tlciBzZXQgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgICAqXG4gICAgICogVGhlIHN0aWNrZXIgbXVzdCBiZWxvbmcgdG8gYSBzdGlja2VyIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU3RpY2tlciBzZXQgbmFtZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGVzdGlja2Vyc2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVN0aWNrZXJTZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVTdGlja2VyU2V0KG5hbWUpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5uYW1lID0gbmFtZTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVTdGlja2VyU2V0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYW5zd2VycyB0byBhbiBpbmxpbmUgcXVlcnkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBObyBtb3JlIHRoYW4gNTAgcmVzdWx0cyBwZXIgcXVlcnkgYXJlIGFsbG93ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlubGluZVF1ZXJ5SWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHF1ZXJ5XG4gICAgICogQHBhcmFtICB7SW5saW5lUXVlcnlSZXN1bHRbXX0gcmVzdWx0cyBBbiBhcnJheSBvZiByZXN1bHRzIGZvciB0aGUgaW5saW5lIHF1ZXJ5XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgVHJ1ZSBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhbnN3ZXJpbmxpbmVxdWVyeVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhbnN3ZXJJbmxpbmVRdWVyeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuc3dlcklubGluZVF1ZXJ5KGlubGluZVF1ZXJ5SWQsIHJlc3VsdHMpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5pbmxpbmVfcXVlcnlfaWQgPSBpbmxpbmVRdWVyeUlkO1xuICAgICAgZm9ybS5yZXN1bHRzID0gc3RyaW5naWZ5KHJlc3VsdHMpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Fuc3dlcklubGluZVF1ZXJ5JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgdGhlIHJlc3VsdCBvZiBhbiBpbnRlcmFjdGlvbiB3aXRoIGEgW1dlYiBBcHBdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy93ZWJhcHBzKVxuICAgICAqIGFuZCBzZW5kIGEgY29ycmVzcG9uZGluZyBtZXNzYWdlIG9uIGJlaGFsZiBvZiB0aGUgdXNlciB0byB0aGUgY2hhdCBmcm9tIHdoaWNoIHRoZSBxdWVyeSBvcmlnaW5hdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB3ZWJBcHBRdWVyeUlkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcXVlcnkgdG8gYmUgYW5zd2VyZWRcbiAgICAgKiBAcGFyYW0gIHtJbmxpbmVRdWVyeVJlc3VsdH0gcmVzdWx0IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgb25lIHJlc3VsdCBvZiBhbiBpbmxpbmUgcXVlcnlcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBhIFtTZW50V2ViQXBwTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW50d2ViYXBwbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Fuc3dlcndlYmFwcHF1ZXJ5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Fuc3dlcldlYkFwcFF1ZXJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5zd2VyV2ViQXBwUXVlcnkod2ViQXBwUXVlcnlJZCwgcmVzdWx0KSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0ud2ViX2FwcF9xdWVyeV9pZCA9IHdlYkFwcFF1ZXJ5SWQ7XG4gICAgICBmb3JtLnJlc3VsdCA9IHN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Fuc3dlcldlYkFwcFF1ZXJ5JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGFuIGludm9pY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlIFByb2R1Y3QgbmFtZSwgMS0zMiBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBkZXNjcmlwdGlvbiBQcm9kdWN0IGRlc2NyaXB0aW9uLCAxLTI1NSBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwYXlsb2FkIEJvdCBkZWZpbmVkIGludm9pY2UgcGF5bG9hZCwgMS0xMjggYnl0ZXMuIFRoaXMgd2lsbCBub3QgYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyLCB1c2UgZm9yIHlvdXIgaW50ZXJuYWwgcHJvY2Vzc2VzLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcHJvdmlkZXJUb2tlbiBQYXltZW50cyBwcm92aWRlciB0b2tlbiwgb2J0YWluZWQgdmlhIGBAQm90RmF0aGVyYFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gY3VycmVuY3kgVGhyZWUtbGV0dGVyIElTTyA0MjE3IGN1cnJlbmN5IGNvZGVcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcHJpY2VzIEJyZWFrZG93biBvZiBwcmljZXNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kaW52b2ljZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kSW52b2ljZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmRJbnZvaWNlKGNoYXRJZCwgdGl0bGUsIGRlc2NyaXB0aW9uLCBwYXlsb2FkLCBwcm92aWRlclRva2VuLCBjdXJyZW5jeSwgcHJpY2VzKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0udGl0bGUgPSB0aXRsZTtcbiAgICAgIGZvcm0uZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgIGZvcm0ucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICBmb3JtLnByb3ZpZGVyX3Rva2VuID0gcHJvdmlkZXJUb2tlbjtcbiAgICAgIGZvcm0uY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgICAgIGZvcm0ucHJpY2VzID0gc3RyaW5naWZ5KHByaWNlcyk7XG4gICAgICBmb3JtLnByb3ZpZGVyX2RhdGEgPSBzdHJpbmdpZnkoZm9ybS5wcm92aWRlcl9kYXRhKTtcbiAgICAgIGlmIChmb3JtLnN1Z2dlc3RlZF90aXBfYW1vdW50cykge1xuICAgICAgICBmb3JtLnN1Z2dlc3RlZF90aXBfYW1vdW50cyA9IHN0cmluZ2lmeShmb3JtLnN1Z2dlc3RlZF90aXBfYW1vdW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZEludm9pY2UnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGEgbGluayBmb3IgYW4gaW52b2ljZS5cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgUHJvZHVjdCBuYW1lLCAxLTMyIGNoYXJhY3RlcnNcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBQcm9kdWN0IGRlc2NyaXB0aW9uLCAxLTI1NSBjaGFyYWN0ZXJzXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZCBCb3QgZGVmaW5lZCBpbnZvaWNlIHBheWxvYWRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm92aWRlclRva2VuIFBheW1lbnQgcHJvdmlkZXIgdG9rZW5cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW5jeSBUaHJlZS1sZXR0ZXIgSVNPIDQyMTcgY3VycmVuY3kgY29kZVxuICAgICogQHBhcmFtIHtBcnJheX0gcHJpY2VzIEJyZWFrZG93biBvZiBwcmljZXNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIGNyZWF0ZWQgaW52b2ljZSBsaW5rIGFzIFN0cmluZyBvbiBzdWNjZXNzLlxuICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NyZWF0ZWludm9pY2VsaW5rXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlSW52b2ljZUxpbmsnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVJbnZvaWNlTGluayh0aXRsZSwgZGVzY3JpcHRpb24sIHBheWxvYWQsIHByb3ZpZGVyVG9rZW4sIGN1cnJlbmN5LCBwcmljZXMpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiB7fTtcblxuICAgICAgZm9ybS50aXRsZSA9IHRpdGxlO1xuICAgICAgZm9ybS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgZm9ybS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgIGZvcm0ucHJvdmlkZXJfdG9rZW4gPSBwcm92aWRlclRva2VuO1xuICAgICAgZm9ybS5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgICAgZm9ybS5wcmljZXMgPSBzdHJpbmdpZnkocHJpY2VzKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjcmVhdGVJbnZvaWNlTGluaycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZXBseSB0byBzaGlwcGluZyBxdWVyaWVzLlxuICAgICpcbiAgICAqIElmIHlvdSBzZW50IGFuIGludm9pY2UgcmVxdWVzdGluZyBhIHNoaXBwaW5nIGFkZHJlc3MgYW5kIHRoZSBwYXJhbWV0ZXIgaXNfZmxleGlibGUgd2FzIHNwZWNpZmllZCxcbiAgICAqIHRoZSBCb3QgQVBJIHdpbGwgc2VuZCBhbiBbVXBkYXRlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VwZGF0ZSkgd2l0aCBhIHNoaXBwaW5nX3F1ZXJ5IGZpZWxkIHRvIHRoZSBib3RcbiAgICAqXG4gICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNoaXBwaW5nUXVlcnlJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBxdWVyeSB0byBiZSBhbnN3ZXJlZFxuICAgICogQHBhcmFtICB7Qm9vbGVhbn0gb2sgU3BlY2lmeSBpZiBkZWxpdmVyeSBvZiB0aGUgcHJvZHVjdCBpcyBwb3NzaWJsZVxuICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBUcnVlIGlzIHJldHVybmVkXG4gICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYW5zd2Vyc2hpcHBpbmdxdWVyeVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Fuc3dlclNoaXBwaW5nUXVlcnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbnN3ZXJTaGlwcGluZ1F1ZXJ5KHNoaXBwaW5nUXVlcnlJZCwgb2spIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5zaGlwcGluZ19xdWVyeV9pZCA9IHNoaXBwaW5nUXVlcnlJZDtcbiAgICAgIGZvcm0ub2sgPSBvaztcbiAgICAgIGZvcm0uc2hpcHBpbmdfb3B0aW9ucyA9IHN0cmluZ2lmeShmb3JtLnNoaXBwaW5nX29wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Fuc3dlclNoaXBwaW5nUXVlcnknLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlc3BvbmQgdG8gc3VjaCBwcmUtY2hlY2tvdXQgcXVlcmllc1xuICAgICAqXG4gICAgICogT25jZSB0aGUgdXNlciBoYXMgY29uZmlybWVkIHRoZWlyIHBheW1lbnQgYW5kIHNoaXBwaW5nIGRldGFpbHMsIHRoZSBCb3QgQVBJIHNlbmRzIHRoZSBmaW5hbCBjb25maXJtYXRpb24gaW4gdGhlIGZvcm0gb2ZcbiAgICAgKiBhbiBbVXBkYXRlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VwZGF0ZSkgd2l0aCB0aGUgZmllbGQgKnByZV9jaGVja291dF9xdWVyeSouXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIEJvdCBBUEkgbXVzdCByZWNlaXZlIGFuIGFuc3dlciB3aXRoaW4gMTAgc2Vjb25kcyBhZnRlciB0aGUgcHJlLWNoZWNrb3V0IHF1ZXJ5IHdhcyBzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwcmVDaGVja291dFF1ZXJ5SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcXVlcnkgdG8gYmUgYW5zd2VyZWRcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvayBTcGVjaWZ5IGlmIGV2ZXJ5IG9yZGVyIGRldGFpbHMgYXJlIG9rXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgVHJ1ZSBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhbnN3ZXJwcmVjaGVja291dHF1ZXJ5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Fuc3dlclByZUNoZWNrb3V0UXVlcnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbnN3ZXJQcmVDaGVja291dFF1ZXJ5KHByZUNoZWNrb3V0UXVlcnlJZCwgb2spIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5wcmVfY2hlY2tvdXRfcXVlcnlfaWQgPSBwcmVDaGVja291dFF1ZXJ5SWQ7XG4gICAgICBmb3JtLm9rID0gb2s7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYW5zd2VyUHJlQ2hlY2tvdXRRdWVyeScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBhIGdhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZ2FtZVNob3J0TmFtZSBuYW1lIG9mIHRoZSBnYW1lIHRvIGJlIHNlbnQuIFNldCB1cCB5b3VyIGdhbWVzIHZpYSBgQEJvdEZhdGhlcmAuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGdhbWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZEdhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kR2FtZShjaGF0SWQsIGdhbWVTaG9ydE5hbWUpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5nYW1lX3Nob3J0X25hbWUgPSBnYW1lU2hvcnROYW1lO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRHYW1lJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgdGhlIHNjb3JlIG9mIHRoZSBzcGVjaWZpZWQgdXNlciBpbiBhIGdhbWUgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjb3JlIE5ldyBzY29yZSB2YWx1ZSwgbXVzdCBiZSBub24tbmVnYXRpdmVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBpZiB0aGUgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIFRydWUgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Z2FtZXNjb3JlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldEdhbWVTY29yZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEdhbWVTY29yZSh1c2VySWQsIHNjb3JlKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICAgIGZvcm0uc2NvcmUgPSBzY29yZTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRHYW1lU2NvcmUnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBkYXRhIGZvciBoaWdoIHNjb3JlIHRhYmxlcy5cbiAgICAgKlxuICAgICAqIFdpbGwgcmV0dXJuIHRoZSBzY29yZSBvZiB0aGUgc3BlY2lmaWVkIHVzZXIgYW5kIHNldmVyYWwgb2YgdGhlaXIgbmVpZ2hib3JzIGluIGEgZ2FtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCByZXR1cm5zIGFuIEFycmF5IG9mIFtHYW1lSGlnaFNjb3JlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dhbWVoaWdoc2NvcmUpIG9iamVjdHNcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Z2FtZWhpZ2hzY29yZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0R2FtZUhpZ2hTY29yZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHYW1lSGlnaFNjb3Jlcyh1c2VySWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldEdhbWVIaWdoU2NvcmVzJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGRlbGV0ZSBhIG1lc3NhZ2UsIGluY2x1ZGluZyBzZXJ2aWNlIG1lc3NhZ2VzLCB3aXRoIHRoZSBmb2xsb3dpbmcgbGltaXRhdGlvbnM6XG4gICAgKiAtIEEgbWVzc2FnZSBjYW4gb25seSBiZSBkZWxldGVkIGlmIGl0IHdhcyBzZW50IGxlc3MgdGhhbiA0OCBob3VycyBhZ28uXG4gICAgKiAtIEEgZGljZSBtZXNzYWdlIGNhbiBvbmx5IGJlIGRlbGV0ZWQgaWYgaXQgd2FzIHNlbnQgbW9yZSB0aGFuIDI0IGhvdXJzIGFnby5cbiAgICAqIC0gQm90cyBjYW4gZGVsZXRlIG91dGdvaW5nIG1lc3NhZ2VzIGluIGdyb3VwcyBhbmQgc3VwZXJncm91cHMuXG4gICAgKiAtIEJvdHMgY2FuIGRlbGV0ZSBpbmNvbWluZyBtZXNzYWdlcyBpbiBncm91cHMsIHN1cGVyZ3JvdXBzIGFuZCBjaGFubmVscy5cbiAgICAqIC0gQm90cyBncmFudGVkIGBjYW5fcG9zdF9tZXNzYWdlc2AgcGVybWlzc2lvbnMgY2FuIGRlbGV0ZSBvdXRnb2luZyBtZXNzYWdlcyBpbiBjaGFubmVscy5cbiAgICAqIC0gSWYgdGhlIGJvdCBpcyBhbiBhZG1pbmlzdHJhdG9yIG9mIGEgZ3JvdXAsIGl0IGNhbiBkZWxldGUgYW55IG1lc3NhZ2UgdGhlcmUuXG4gICAgKiAtIElmIHRoZSBib3QgaGFzIGBjYW5fZGVsZXRlX21lc3NhZ2VzYCBwZXJtaXNzaW9uIGluIGEgc3VwZXJncm91cCwgaXQgY2FuIGRlbGV0ZSBhbnkgbWVzc2FnZSB0aGVyZS5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IEBjaGFubmVsdXNlcm5hbWUpXG4gICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1lc3NhZ2VJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCBtZXNzYWdlXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZW1lc3NhZ2VcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVNZXNzYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlTWVzc2FnZShjaGF0SWQsIG1lc3NhZ2VJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLm1lc3NhZ2VfaWQgPSBtZXNzYWdlSWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlTWVzc2FnZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIG11bHRpcGxlIG1lc3NhZ2VzIHNpbXVsdGFuZW91c2x5LiBJZiBzb21lIG9mIHRoZSBzcGVjaWZpZWQgbWVzc2FnZXMgY2FuJ3QgYmUgZm91bmQsIHRoZXkgYXJlIHNraXBwZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IEBjaGFubmVsdXNlcm5hbWUpXG4gICAgICogQHBhcmFtICB7QXJyYXk8TnVtYmVyfFN0cmluZz59IG1lc3NhZ2VJZHMgIElkZW50aWZpZXJzIG9mIDEtMTAwIG1lc3NhZ2VzIHRvIGRlbGV0ZS4gU2VlIGRlbGV0ZU1lc3NhZ2UgZm9yIGxpbWl0YXRpb25zIG9uIHdoaWNoIG1lc3NhZ2VzIGNhbiBiZSBkZWxldGVkXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxCb29sZWFuPn0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZW1lc3NhZ2VzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZU1lc3NhZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlTWVzc2FnZXMoY2hhdElkLCBtZXNzYWdlSWRzKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV9pZHMgPSBzdHJpbmdpZnkobWVzc2FnZUlkcyk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlTWVzc2FnZXMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRlbGVncmFtQm90O1xufShFdmVudEVtaXR0ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRlbGVncmFtQm90OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/lib/telegram.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/lib/telegramPolling.js":
/*!*******************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/lib/telegramPolling.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/errors.js\");\nvar debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nvar deprecate = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/utils.js\").deprecate);\nvar ANOTHER_WEB_HOOK_USED = 409;\n\nvar TelegramBotPolling = function () {\n  /**\n   * Handles polling against the Telegram servers.\n   * @param  {TelegramBot} bot\n   * @see https://core.telegram.org/bots/api#getting-updates\n   */\n  function TelegramBotPolling(bot) {\n    _classCallCheck(this, TelegramBotPolling);\n\n    this.bot = bot;\n    this.options = typeof bot.options.polling === 'boolean' ? {} : bot.options.polling;\n    this.options.interval = typeof this.options.interval === 'number' ? this.options.interval : 300;\n    this.options.params = _typeof(this.options.params) === 'object' ? this.options.params : {};\n    this.options.params.offset = typeof this.options.params.offset === 'number' ? this.options.params.offset : 0;\n    this.options.params.timeout = typeof this.options.params.timeout === 'number' ? this.options.params.timeout : 10;\n    if (typeof this.options.timeout === 'number') {\n      deprecate('`options.polling.timeout` is deprecated. Use `options.polling.params` instead.');\n      this.options.params.timeout = this.options.timeout;\n    }\n    this._lastUpdate = 0;\n    this._lastRequest = null;\n    this._abort = false;\n    this._pollingTimeout = null;\n  }\n\n  /**\n   * Start polling\n   * @param  {Object} [options]\n   * @param  {Object} [options.restart]\n   * @return {Promise}\n   */\n\n\n  _createClass(TelegramBotPolling, [{\n    key: 'start',\n    value: function start() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._lastRequest) {\n        if (!options.restart) {\n          return Promise.resolve();\n        }\n        return this.stop({\n          cancel: true,\n          reason: 'Polling restart'\n        }).then(function () {\n          return _this._polling();\n        });\n      }\n      return this._polling();\n    }\n\n    /**\n     * Stop polling\n     * @param  {Object} [options] Options\n     * @param  {Boolean} [options.cancel] Cancel current request\n     * @param  {String} [options.reason] Reason for stopping polling\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this._lastRequest) {\n        return Promise.resolve();\n      }\n      var lastRequest = this._lastRequest;\n      this._lastRequest = null;\n      clearTimeout(this._pollingTimeout);\n      if (options.cancel) {\n        var reason = options.reason || 'Polling stop';\n        lastRequest.cancel(reason);\n        return Promise.resolve();\n      }\n      this._abort = true;\n      return lastRequest.finally(function () {\n        _this2._abort = false;\n      });\n    }\n\n    /**\n     * Return `true` if is polling. Otherwise, `false`.\n     */\n\n  }, {\n    key: 'isPolling',\n    value: function isPolling() {\n      return !!this._lastRequest;\n    }\n\n    /**\n     * Handle error thrown during polling.\n     * @private\n     * @param  {Error} error\n     */\n\n  }, {\n    key: '_error',\n    value: function _error(error) {\n      if (!this.bot.listeners('polling_error').length) {\n        return console.error('error: [polling_error] %j', error); // eslint-disable-line no-console\n      }\n      return this.bot.emit('polling_error', error);\n    }\n\n    /**\n     * Invokes polling (with recursion!)\n     * @return {Promise} promise of the current request\n     * @private\n     */\n\n  }, {\n    key: '_polling',\n    value: function _polling() {\n      var _this3 = this;\n\n      this._lastRequest = this._getUpdates().then(function (updates) {\n        _this3._lastUpdate = Date.now();\n        debug('polling data %j', updates);\n        updates.forEach(function (update) {\n          _this3.options.params.offset = update.update_id + 1;\n          debug('updated offset: %s', _this3.options.params.offset);\n          try {\n            _this3.bot.processUpdate(update);\n          } catch (err) {\n            err._processing = true;\n            throw err;\n          }\n        });\n        return null;\n      }).catch(function (err) {\n        debug('polling error: %s', err.message);\n        if (!err._processing) {\n          return _this3._error(err);\n        }\n        delete err._processing;\n        /*\n         * An error occured while processing the items,\n         * i.e. in `this.bot.processUpdate()` above.\n         * We need to mark the already-processed items\n         * to avoid fetching them again once the application\n         * is restarted, or moves to next polling interval\n         * (in cases where unhandled rejections do not terminate\n         * the process).\n         * See https://github.com/yagop/node-telegram-bot-api/issues/36#issuecomment-268532067\n         */\n        if (!_this3.bot.options.badRejection) {\n          return _this3._error(err);\n        }\n        var opts = {\n          offset: _this3.options.params.offset,\n          limit: 1,\n          timeout: 0\n        };\n        return _this3.bot.getUpdates(opts).then(function () {\n          return _this3._error(err);\n        }).catch(function (requestErr) {\n          /*\n           * We have been unable to handle this error.\n           * We have to log this to stderr to ensure devops\n           * understands that they may receive already-processed items\n           * on app restart.\n           * We simply can not rescue this situation, emit \"error\"\n           * event, with the hope that the application exits.\n           */\n          /* eslint-disable no-console */\n          var bugUrl = 'https://github.com/yagop/node-telegram-bot-api/issues/36#issuecomment-268532067';\n          console.error('error: Internal handling of The Offset Infinite Loop failed');\n          console.error('error: Due to error \\'' + requestErr + '\\'');\n          console.error('error: You may receive already-processed updates on app restart');\n          console.error('error: Please see ' + bugUrl + ' for more information');\n          /* eslint-enable no-console */\n          return _this3.bot.emit('error', new errors.FatalError(err));\n        });\n      }).finally(function () {\n        if (_this3._abort) {\n          debug('Polling is aborted!');\n        } else {\n          debug('setTimeout for %s miliseconds', _this3.options.interval);\n          _this3._pollingTimeout = setTimeout(function () {\n            return _this3._polling();\n          }, _this3.options.interval);\n        }\n      });\n      return this._lastRequest;\n    }\n\n    /**\n     * Unset current webhook. Used when we detect that a webhook has been set\n     * and we are trying to poll. Polling and WebHook are mutually exclusive.\n     * @see https://core.telegram.org/bots/api#getting-updates\n     * @private\n     */\n\n  }, {\n    key: '_unsetWebHook',\n    value: function _unsetWebHook() {\n      debug('unsetting webhook');\n      return this.bot._request('setWebHook');\n    }\n\n    /**\n     * Retrieve updates\n     */\n\n  }, {\n    key: '_getUpdates',\n    value: function _getUpdates() {\n      var _this4 = this;\n\n      debug('polling with options: %j', this.options.params);\n      return this.bot.getUpdates(this.options.params).catch(function (err) {\n        if (err.response && err.response.statusCode === ANOTHER_WEB_HOOK_USED) {\n          return _this4._unsetWebHook().then(function () {\n            return _this4.bot.getUpdates(_this4.options.params);\n          });\n        }\n        throw err;\n      });\n    }\n  }]);\n\n  return TelegramBotPolling;\n}();\n\nmodule.exports = TelegramBotPolling;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi90ZWxlZ3JhbVBvbGxpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIscUdBQXFHLHFCQUFxQixtQkFBbUI7O0FBRTdJLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVqakIsa0RBQWtELDBDQUEwQzs7QUFFNUYsYUFBYSxtQkFBTyxDQUFDLDBFQUFVO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyx5RkFBTztBQUMzQixnQkFBZ0IseUdBQTRCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kb2xpc3Qtd2ViLy4vbm9kZV9tb2R1bGVzL25vZGUtdGVsZWdyYW0tYm90LWFwaS9saWIvdGVsZWdyYW1Qb2xsaW5nLmpzPzkxYWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbm9kZS10ZWxlZ3JhbS1ib3QtYXBpJyk7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgnLi91dGlscycpLmRlcHJlY2F0ZTtcbnZhciBBTk9USEVSX1dFQl9IT09LX1VTRUQgPSA0MDk7XG5cbnZhciBUZWxlZ3JhbUJvdFBvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBIYW5kbGVzIHBvbGxpbmcgYWdhaW5zdCB0aGUgVGVsZWdyYW0gc2VydmVycy5cbiAgICogQHBhcmFtICB7VGVsZWdyYW1Cb3R9IGJvdFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0dGluZy11cGRhdGVzXG4gICAqL1xuICBmdW5jdGlvbiBUZWxlZ3JhbUJvdFBvbGxpbmcoYm90KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRlbGVncmFtQm90UG9sbGluZyk7XG5cbiAgICB0aGlzLmJvdCA9IGJvdDtcbiAgICB0aGlzLm9wdGlvbnMgPSB0eXBlb2YgYm90Lm9wdGlvbnMucG9sbGluZyA9PT0gJ2Jvb2xlYW4nID8ge30gOiBib3Qub3B0aW9ucy5wb2xsaW5nO1xuICAgIHRoaXMub3B0aW9ucy5pbnRlcnZhbCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwgPT09ICdudW1iZXInID8gdGhpcy5vcHRpb25zLmludGVydmFsIDogMzAwO1xuICAgIHRoaXMub3B0aW9ucy5wYXJhbXMgPSBfdHlwZW9mKHRoaXMub3B0aW9ucy5wYXJhbXMpID09PSAnb2JqZWN0JyA/IHRoaXMub3B0aW9ucy5wYXJhbXMgOiB7fTtcbiAgICB0aGlzLm9wdGlvbnMucGFyYW1zLm9mZnNldCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGFyYW1zLm9mZnNldCA9PT0gJ251bWJlcicgPyB0aGlzLm9wdGlvbnMucGFyYW1zLm9mZnNldCA6IDA7XG4gICAgdGhpcy5vcHRpb25zLnBhcmFtcy50aW1lb3V0ID0gdHlwZW9mIHRoaXMub3B0aW9ucy5wYXJhbXMudGltZW91dCA9PT0gJ251bWJlcicgPyB0aGlzLm9wdGlvbnMucGFyYW1zLnRpbWVvdXQgOiAxMDtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgZGVwcmVjYXRlKCdgb3B0aW9ucy5wb2xsaW5nLnRpbWVvdXRgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgb3B0aW9ucy5wb2xsaW5nLnBhcmFtc2AgaW5zdGVhZC4nKTtcbiAgICAgIHRoaXMub3B0aW9ucy5wYXJhbXMudGltZW91dCA9IHRoaXMub3B0aW9ucy50aW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLl9sYXN0VXBkYXRlID0gMDtcbiAgICB0aGlzLl9sYXN0UmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5fYWJvcnQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2xsaW5nVGltZW91dCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcG9sbGluZ1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLnJlc3RhcnRdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRlbGVncmFtQm90UG9sbGluZywgW3tcbiAgICBrZXk6ICdzdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAodGhpcy5fbGFzdFJlcXVlc3QpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJlc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcCh7XG4gICAgICAgICAgY2FuY2VsOiB0cnVlLFxuICAgICAgICAgIHJlYXNvbjogJ1BvbGxpbmcgcmVzdGFydCdcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9wb2xsaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3BvbGxpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHBvbGxpbmdcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuY2FuY2VsXSBDYW5jZWwgY3VycmVudCByZXF1ZXN0XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb25dIFJlYXNvbiBmb3Igc3RvcHBpbmcgcG9sbGluZ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgaWYgKCF0aGlzLl9sYXN0UmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdFJlcXVlc3QgPSB0aGlzLl9sYXN0UmVxdWVzdDtcbiAgICAgIHRoaXMuX2xhc3RSZXF1ZXN0ID0gbnVsbDtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9wb2xsaW5nVGltZW91dCk7XG4gICAgICBpZiAob3B0aW9ucy5jYW5jZWwpIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IG9wdGlvbnMucmVhc29uIHx8ICdQb2xsaW5nIHN0b3AnO1xuICAgICAgICBsYXN0UmVxdWVzdC5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWJvcnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGxhc3RSZXF1ZXN0LmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuX2Fib3J0ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIGlzIHBvbGxpbmcuIE90aGVyd2lzZSwgYGZhbHNlYC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNQb2xsaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQb2xsaW5nKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fbGFzdFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGVycm9yIHRocm93biBkdXJpbmcgcG9sbGluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge0Vycm9yfSBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXJyb3IoZXJyb3IpIHtcbiAgICAgIGlmICghdGhpcy5ib3QubGlzdGVuZXJzKCdwb2xsaW5nX2Vycm9yJykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdlcnJvcjogW3BvbGxpbmdfZXJyb3JdICVqJywgZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmJvdC5lbWl0KCdwb2xsaW5nX2Vycm9yJywgZXJyb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgcG9sbGluZyAod2l0aCByZWN1cnNpb24hKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugb2YgdGhlIGN1cnJlbnQgcmVxdWVzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19wb2xsaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvbGxpbmcoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5fbGFzdFJlcXVlc3QgPSB0aGlzLl9nZXRVcGRhdGVzKCkudGhlbihmdW5jdGlvbiAodXBkYXRlcykge1xuICAgICAgICBfdGhpczMuX2xhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICBkZWJ1ZygncG9sbGluZyBkYXRhICVqJywgdXBkYXRlcyk7XG4gICAgICAgIHVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgX3RoaXMzLm9wdGlvbnMucGFyYW1zLm9mZnNldCA9IHVwZGF0ZS51cGRhdGVfaWQgKyAxO1xuICAgICAgICAgIGRlYnVnKCd1cGRhdGVkIG9mZnNldDogJXMnLCBfdGhpczMub3B0aW9ucy5wYXJhbXMub2Zmc2V0KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgX3RoaXMzLmJvdC5wcm9jZXNzVXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIuX3Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkZWJ1ZygncG9sbGluZyBlcnJvcjogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIGlmICghZXJyLl9wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZXJyLl9wcm9jZXNzaW5nO1xuICAgICAgICAvKlxuICAgICAgICAgKiBBbiBlcnJvciBvY2N1cmVkIHdoaWxlIHByb2Nlc3NpbmcgdGhlIGl0ZW1zLFxuICAgICAgICAgKiBpLmUuIGluIGB0aGlzLmJvdC5wcm9jZXNzVXBkYXRlKClgIGFib3ZlLlxuICAgICAgICAgKiBXZSBuZWVkIHRvIG1hcmsgdGhlIGFscmVhZHktcHJvY2Vzc2VkIGl0ZW1zXG4gICAgICAgICAqIHRvIGF2b2lkIGZldGNoaW5nIHRoZW0gYWdhaW4gb25jZSB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgICogaXMgcmVzdGFydGVkLCBvciBtb3ZlcyB0byBuZXh0IHBvbGxpbmcgaW50ZXJ2YWxcbiAgICAgICAgICogKGluIGNhc2VzIHdoZXJlIHVuaGFuZGxlZCByZWplY3Rpb25zIGRvIG5vdCB0ZXJtaW5hdGVcbiAgICAgICAgICogdGhlIHByb2Nlc3MpLlxuICAgICAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9pc3N1ZXMvMzYjaXNzdWVjb21tZW50LTI2ODUzMjA2N1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFfdGhpczMuYm90Lm9wdGlvbnMuYmFkUmVqZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICBvZmZzZXQ6IF90aGlzMy5vcHRpb25zLnBhcmFtcy5vZmZzZXQsXG4gICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgdGltZW91dDogMFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXMzLmJvdC5nZXRVcGRhdGVzKG9wdHMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX2Vycm9yKGVycik7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChyZXF1ZXN0RXJyKSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBXZSBoYXZlIGJlZW4gdW5hYmxlIHRvIGhhbmRsZSB0aGlzIGVycm9yLlxuICAgICAgICAgICAqIFdlIGhhdmUgdG8gbG9nIHRoaXMgdG8gc3RkZXJyIHRvIGVuc3VyZSBkZXZvcHNcbiAgICAgICAgICAgKiB1bmRlcnN0YW5kcyB0aGF0IHRoZXkgbWF5IHJlY2VpdmUgYWxyZWFkeS1wcm9jZXNzZWQgaXRlbXNcbiAgICAgICAgICAgKiBvbiBhcHAgcmVzdGFydC5cbiAgICAgICAgICAgKiBXZSBzaW1wbHkgY2FuIG5vdCByZXNjdWUgdGhpcyBzaXR1YXRpb24sIGVtaXQgXCJlcnJvclwiXG4gICAgICAgICAgICogZXZlbnQsIHdpdGggdGhlIGhvcGUgdGhhdCB0aGUgYXBwbGljYXRpb24gZXhpdHMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgIHZhciBidWdVcmwgPSAnaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9pc3N1ZXMvMzYjaXNzdWVjb21tZW50LTI2ODUzMjA2Nyc7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignZXJyb3I6IEludGVybmFsIGhhbmRsaW5nIG9mIFRoZSBPZmZzZXQgSW5maW5pdGUgTG9vcCBmYWlsZWQnKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdlcnJvcjogRHVlIHRvIGVycm9yIFxcJycgKyByZXF1ZXN0RXJyICsgJ1xcJycpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiBZb3UgbWF5IHJlY2VpdmUgYWxyZWFkeS1wcm9jZXNzZWQgdXBkYXRlcyBvbiBhcHAgcmVzdGFydCcpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiBQbGVhc2Ugc2VlICcgKyBidWdVcmwgKyAnIGZvciBtb3JlIGluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5ib3QuZW1pdCgnZXJyb3InLCBuZXcgZXJyb3JzLkZhdGFsRXJyb3IoZXJyKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczMuX2Fib3J0KSB7XG4gICAgICAgICAgZGVidWcoJ1BvbGxpbmcgaXMgYWJvcnRlZCEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1Zygnc2V0VGltZW91dCBmb3IgJXMgbWlsaXNlY29uZHMnLCBfdGhpczMub3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICAgICAgX3RoaXMzLl9wb2xsaW5nVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fcG9sbGluZygpO1xuICAgICAgICAgIH0sIF90aGlzMy5vcHRpb25zLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fbGFzdFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zZXQgY3VycmVudCB3ZWJob29rLiBVc2VkIHdoZW4gd2UgZGV0ZWN0IHRoYXQgYSB3ZWJob29rIGhhcyBiZWVuIHNldFxuICAgICAqIGFuZCB3ZSBhcmUgdHJ5aW5nIHRvIHBvbGwuIFBvbGxpbmcgYW5kIFdlYkhvb2sgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0dGluZy11cGRhdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3Vuc2V0V2ViSG9vaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnNldFdlYkhvb2soKSB7XG4gICAgICBkZWJ1ZygndW5zZXR0aW5nIHdlYmhvb2snKTtcbiAgICAgIHJldHVybiB0aGlzLmJvdC5fcmVxdWVzdCgnc2V0V2ViSG9vaycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHVwZGF0ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldFVwZGF0ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VXBkYXRlcygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBkZWJ1ZygncG9sbGluZyB3aXRoIG9wdGlvbnM6ICVqJywgdGhpcy5vcHRpb25zLnBhcmFtcyk7XG4gICAgICByZXR1cm4gdGhpcy5ib3QuZ2V0VXBkYXRlcyh0aGlzLm9wdGlvbnMucGFyYW1zKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IEFOT1RIRVJfV0VCX0hPT0tfVVNFRCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQuX3Vuc2V0V2ViSG9vaygpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5ib3QuZ2V0VXBkYXRlcyhfdGhpczQub3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZWxlZ3JhbUJvdFBvbGxpbmc7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGVsZWdyYW1Cb3RQb2xsaW5nOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/lib/telegramPolling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/lib/telegramWebHook.js":
/*!*******************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/lib/telegramWebHook.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/errors.js\");\nvar debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nvar https = __webpack_require__(/*! https */ \"https\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar bl = __webpack_require__(/*! bl */ \"(rsc)/./node_modules/bl/bl.js\");\n\nvar TelegramBotWebHook = function () {\n  /**\n   * Sets up a webhook to receive updates\n   * @param  {TelegramBot} bot\n   * @see https://core.telegram.org/bots/api#getting-updates\n   */\n  function TelegramBotWebHook(bot) {\n    _classCallCheck(this, TelegramBotWebHook);\n\n    this.bot = bot;\n    this.options = typeof bot.options.webHook === 'boolean' ? {} : bot.options.webHook;\n    this.options.host = this.options.host || '0.0.0.0';\n    this.options.port = this.options.port || 8443;\n    this.options.https = this.options.https || {};\n    this.options.healthEndpoint = this.options.healthEndpoint || '/healthz';\n    this._healthRegex = new RegExp(this.options.healthEndpoint);\n    this._webServer = null;\n    this._open = false;\n    this._requestListener = this._requestListener.bind(this);\n    this._parseBody = this._parseBody.bind(this);\n\n    if (this.options.key && this.options.cert) {\n      debug('HTTPS WebHook enabled (by key/cert)');\n      this.options.https.key = fs.readFileSync(this.options.key);\n      this.options.https.cert = fs.readFileSync(this.options.cert);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (this.options.pfx) {\n      debug('HTTPS WebHook enabled (by pfx)');\n      this.options.https.pfx = fs.readFileSync(this.options.pfx);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (Object.keys(this.options.https).length) {\n      debug('HTTPS WebHook enabled by (https)');\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else {\n      debug('HTTP WebHook enabled');\n      this._webServer = http.createServer(this._requestListener);\n    }\n  }\n\n  /**\n   * Open WebHook by listening on the port\n   * @return {Promise}\n   */\n\n\n  _createClass(TelegramBotWebHook, [{\n    key: 'open',\n    value: function open() {\n      var _this = this;\n\n      if (this.isOpen()) {\n        return Promise.resolve();\n      }\n      return new Promise(function (resolve, reject) {\n        _this._webServer.listen(_this.options.port, _this.options.host, function () {\n          debug('WebHook listening on port %s', _this.options.port);\n          _this._open = true;\n          return resolve();\n        });\n\n        _this._webServer.once('error', function (err) {\n          reject(err);\n        });\n      });\n    }\n\n    /**\n     * Close the webHook\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'close',\n    value: function close() {\n      var _this2 = this;\n\n      if (!this.isOpen()) {\n        return Promise.resolve();\n      }\n      return new Promise(function (resolve, reject) {\n        _this2._webServer.close(function (error) {\n          if (error) return reject(error);\n          _this2._open = false;\n          return resolve();\n        });\n      });\n    }\n\n    /**\n     * Return `true` if server is listening. Otherwise, `false`.\n     */\n\n  }, {\n    key: 'isOpen',\n    value: function isOpen() {\n      // NOTE: Since `http.Server.listening` was added in v5.7.0\n      // and we still need to support Node v4,\n      // we are going to fallback to 'this._open'.\n      // The following LOC would suffice for newer versions of Node.js\n      // return this._webServer.listening;\n      return this._open;\n    }\n\n    /**\n     * Handle error thrown during processing of webhook request.\n     * @private\n     * @param  {Error} error\n     */\n\n  }, {\n    key: '_error',\n    value: function _error(error) {\n      if (!this.bot.listeners('webhook_error').length) {\n        return console.error('error: [webhook_error] %j', error); // eslint-disable-line no-console\n      }\n      return this.bot.emit('webhook_error', error);\n    }\n\n    /**\n     * Handle request body by passing it to 'callback'\n     * @private\n     */\n\n  }, {\n    key: '_parseBody',\n    value: function _parseBody(error, body) {\n      if (error) {\n        return this._error(new errors.FatalError(error));\n      }\n\n      var data = void 0;\n      try {\n        data = JSON.parse(body.toString());\n      } catch (parseError) {\n        return this._error(new errors.ParseError(parseError.message));\n      }\n\n      return this.bot.processUpdate(data);\n    }\n\n    /**\n     * Listener for 'request' event on server\n     * @private\n     * @see https://nodejs.org/docs/latest/api/http.html#http_http_createserver_requestlistener\n     * @see https://nodejs.org/docs/latest/api/https.html#https_https_createserver_options_requestlistener\n     */\n\n  }, {\n    key: '_requestListener',\n    value: function _requestListener(req, res) {\n      debug('WebHook request URL: %s', req.url);\n      debug('WebHook request headers: %j', req.headers);\n\n      if (req.url.indexOf(this.bot.token) !== -1) {\n        if (req.method !== 'POST') {\n          debug('WebHook request isn\\'t a POST');\n          res.statusCode = 418; // I'm a teabot!\n          res.end();\n        } else {\n          req.pipe(bl(this._parseBody)).on('finish', function () {\n            return res.end('OK');\n          });\n        }\n      } else if (this._healthRegex.test(req.url)) {\n        debug('WebHook health check passed');\n        res.statusCode = 200;\n        res.end('OK');\n      } else {\n        debug('WebHook request unauthorized');\n        res.statusCode = 401;\n        res.end();\n      }\n    }\n  }]);\n\n  return TelegramBotWebHook;\n}();\n\nmodule.exports = TelegramBotWebHook;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi90ZWxlZ3JhbVdlYkhvb2suanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixrREFBa0QsMENBQTBDOztBQUU1RixhQUFhLG1CQUFPLENBQUMsMEVBQVU7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLHlGQUFPO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsU0FBUyxtQkFBTyxDQUFDLHlDQUFJOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kb2xpc3Qtd2ViLy4vbm9kZV9tb2R1bGVzL25vZGUtdGVsZWdyYW0tYm90LWFwaS9saWIvdGVsZWdyYW1XZWJIb29rLmpzPzk3YmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ25vZGUtdGVsZWdyYW0tYm90LWFwaScpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBibCA9IHJlcXVpcmUoJ2JsJyk7XG5cbnZhciBUZWxlZ3JhbUJvdFdlYkhvb2sgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIGEgd2ViaG9vayB0byByZWNlaXZlIHVwZGF0ZXNcbiAgICogQHBhcmFtICB7VGVsZWdyYW1Cb3R9IGJvdFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0dGluZy11cGRhdGVzXG4gICAqL1xuICBmdW5jdGlvbiBUZWxlZ3JhbUJvdFdlYkhvb2soYm90KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRlbGVncmFtQm90V2ViSG9vayk7XG5cbiAgICB0aGlzLmJvdCA9IGJvdDtcbiAgICB0aGlzLm9wdGlvbnMgPSB0eXBlb2YgYm90Lm9wdGlvbnMud2ViSG9vayA9PT0gJ2Jvb2xlYW4nID8ge30gOiBib3Qub3B0aW9ucy53ZWJIb29rO1xuICAgIHRoaXMub3B0aW9ucy5ob3N0ID0gdGhpcy5vcHRpb25zLmhvc3QgfHwgJzAuMC4wLjAnO1xuICAgIHRoaXMub3B0aW9ucy5wb3J0ID0gdGhpcy5vcHRpb25zLnBvcnQgfHwgODQ0MztcbiAgICB0aGlzLm9wdGlvbnMuaHR0cHMgPSB0aGlzLm9wdGlvbnMuaHR0cHMgfHwge307XG4gICAgdGhpcy5vcHRpb25zLmhlYWx0aEVuZHBvaW50ID0gdGhpcy5vcHRpb25zLmhlYWx0aEVuZHBvaW50IHx8ICcvaGVhbHRoeic7XG4gICAgdGhpcy5faGVhbHRoUmVnZXggPSBuZXcgUmVnRXhwKHRoaXMub3B0aW9ucy5oZWFsdGhFbmRwb2ludCk7XG4gICAgdGhpcy5fd2ViU2VydmVyID0gbnVsbDtcbiAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgdGhpcy5fcmVxdWVzdExpc3RlbmVyID0gdGhpcy5fcmVxdWVzdExpc3RlbmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcGFyc2VCb2R5ID0gdGhpcy5fcGFyc2VCb2R5LmJpbmQodGhpcyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmtleSAmJiB0aGlzLm9wdGlvbnMuY2VydCkge1xuICAgICAgZGVidWcoJ0hUVFBTIFdlYkhvb2sgZW5hYmxlZCAoYnkga2V5L2NlcnQpJyk7XG4gICAgICB0aGlzLm9wdGlvbnMuaHR0cHMua2V5ID0gZnMucmVhZEZpbGVTeW5jKHRoaXMub3B0aW9ucy5rZXkpO1xuICAgICAgdGhpcy5vcHRpb25zLmh0dHBzLmNlcnQgPSBmcy5yZWFkRmlsZVN5bmModGhpcy5vcHRpb25zLmNlcnQpO1xuICAgICAgdGhpcy5fd2ViU2VydmVyID0gaHR0cHMuY3JlYXRlU2VydmVyKHRoaXMub3B0aW9ucy5odHRwcywgdGhpcy5fcmVxdWVzdExpc3RlbmVyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5wZngpIHtcbiAgICAgIGRlYnVnKCdIVFRQUyBXZWJIb29rIGVuYWJsZWQgKGJ5IHBmeCknKTtcbiAgICAgIHRoaXMub3B0aW9ucy5odHRwcy5wZnggPSBmcy5yZWFkRmlsZVN5bmModGhpcy5vcHRpb25zLnBmeCk7XG4gICAgICB0aGlzLl93ZWJTZXJ2ZXIgPSBodHRwcy5jcmVhdGVTZXJ2ZXIodGhpcy5vcHRpb25zLmh0dHBzLCB0aGlzLl9yZXF1ZXN0TGlzdGVuZXIpO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmh0dHBzKS5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKCdIVFRQUyBXZWJIb29rIGVuYWJsZWQgYnkgKGh0dHBzKScpO1xuICAgICAgdGhpcy5fd2ViU2VydmVyID0gaHR0cHMuY3JlYXRlU2VydmVyKHRoaXMub3B0aW9ucy5odHRwcywgdGhpcy5fcmVxdWVzdExpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ0hUVFAgV2ViSG9vayBlbmFibGVkJyk7XG4gICAgICB0aGlzLl93ZWJTZXJ2ZXIgPSBodHRwLmNyZWF0ZVNlcnZlcih0aGlzLl9yZXF1ZXN0TGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIFdlYkhvb2sgYnkgbGlzdGVuaW5nIG9uIHRoZSBwb3J0XG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRlbGVncmFtQm90V2ViSG9vaywgW3tcbiAgICBrZXk6ICdvcGVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzLl93ZWJTZXJ2ZXIubGlzdGVuKF90aGlzLm9wdGlvbnMucG9ydCwgX3RoaXMub3B0aW9ucy5ob3N0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVidWcoJ1dlYkhvb2sgbGlzdGVuaW5nIG9uIHBvcnQgJXMnLCBfdGhpcy5vcHRpb25zLnBvcnQpO1xuICAgICAgICAgIF90aGlzLl9vcGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy5fd2ViU2VydmVyLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSB3ZWJIb29rXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMyLl93ZWJTZXJ2ZXIuY2xvc2UoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICBfdGhpczIuX29wZW4gPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgc2VydmVyIGlzIGxpc3RlbmluZy4gT3RoZXJ3aXNlLCBgZmFsc2VgLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc09wZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc09wZW4oKSB7XG4gICAgICAvLyBOT1RFOiBTaW5jZSBgaHR0cC5TZXJ2ZXIubGlzdGVuaW5nYCB3YXMgYWRkZWQgaW4gdjUuNy4wXG4gICAgICAvLyBhbmQgd2Ugc3RpbGwgbmVlZCB0byBzdXBwb3J0IE5vZGUgdjQsXG4gICAgICAvLyB3ZSBhcmUgZ29pbmcgdG8gZmFsbGJhY2sgdG8gJ3RoaXMuX29wZW4nLlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBMT0Mgd291bGQgc3VmZmljZSBmb3IgbmV3ZXIgdmVyc2lvbnMgb2YgTm9kZS5qc1xuICAgICAgLy8gcmV0dXJuIHRoaXMuX3dlYlNlcnZlci5saXN0ZW5pbmc7XG4gICAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZXJyb3IgdGhyb3duIGR1cmluZyBwcm9jZXNzaW5nIG9mIHdlYmhvb2sgcmVxdWVzdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge0Vycm9yfSBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXJyb3IoZXJyb3IpIHtcbiAgICAgIGlmICghdGhpcy5ib3QubGlzdGVuZXJzKCd3ZWJob29rX2Vycm9yJykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdlcnJvcjogW3dlYmhvb2tfZXJyb3JdICVqJywgZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmJvdC5lbWl0KCd3ZWJob29rX2Vycm9yJywgZXJyb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSByZXF1ZXN0IGJvZHkgYnkgcGFzc2luZyBpdCB0byAnY2FsbGJhY2snXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BhcnNlQm9keScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZUJvZHkoZXJyb3IsIGJvZHkpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IobmV3IGVycm9ycy5GYXRhbEVycm9yKGVycm9yKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYm9keS50b1N0cmluZygpKTtcbiAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKG5ldyBlcnJvcnMuUGFyc2VFcnJvcihwYXJzZUVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYm90LnByb2Nlc3NVcGRhdGUoZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuZXIgZm9yICdyZXF1ZXN0JyBldmVudCBvbiBzZXJ2ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9odHRwLmh0bWwjaHR0cF9odHRwX2NyZWF0ZXNlcnZlcl9yZXF1ZXN0bGlzdGVuZXJcbiAgICAgKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC9hcGkvaHR0cHMuaHRtbCNodHRwc19odHRwc19jcmVhdGVzZXJ2ZXJfb3B0aW9uc19yZXF1ZXN0bGlzdGVuZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlcXVlc3RMaXN0ZW5lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1ZXN0TGlzdGVuZXIocmVxLCByZXMpIHtcbiAgICAgIGRlYnVnKCdXZWJIb29rIHJlcXVlc3QgVVJMOiAlcycsIHJlcS51cmwpO1xuICAgICAgZGVidWcoJ1dlYkhvb2sgcmVxdWVzdCBoZWFkZXJzOiAlaicsIHJlcS5oZWFkZXJzKTtcblxuICAgICAgaWYgKHJlcS51cmwuaW5kZXhPZih0aGlzLmJvdC50b2tlbikgIT09IC0xKSB7XG4gICAgICAgIGlmIChyZXEubWV0aG9kICE9PSAnUE9TVCcpIHtcbiAgICAgICAgICBkZWJ1ZygnV2ViSG9vayByZXF1ZXN0IGlzblxcJ3QgYSBQT1NUJyk7XG4gICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MTg7IC8vIEknbSBhIHRlYWJvdCFcbiAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxLnBpcGUoYmwodGhpcy5fcGFyc2VCb2R5KSkub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuZW5kKCdPSycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2hlYWx0aFJlZ2V4LnRlc3QocmVxLnVybCkpIHtcbiAgICAgICAgZGVidWcoJ1dlYkhvb2sgaGVhbHRoIGNoZWNrIHBhc3NlZCcpO1xuICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDIwMDtcbiAgICAgICAgcmVzLmVuZCgnT0snKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdXZWJIb29rIHJlcXVlc3QgdW5hdXRob3JpemVkJyk7XG4gICAgICAgIHJlcy5zdGF0dXNDb2RlID0gNDAxO1xuICAgICAgICByZXMuZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRlbGVncmFtQm90V2ViSG9vaztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZWxlZ3JhbUJvdFdlYkhvb2s7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/lib/telegramWebHook.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/lib/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\n// Native deprecation warning\nexports.deprecate = function (msg) {\n  return util.deprecate(function () {}, msg, 'node-telegram-bot-api')();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekI7QUFDQSxpQkFBaUI7QUFDakIsc0NBQXNDO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kb2xpc3Qtd2ViLy4vbm9kZV9tb2R1bGVzL25vZGUtdGVsZWdyYW0tYm90LWFwaS9saWIvdXRpbHMuanM/M2FiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuLy8gTmF0aXZlIGRlcHJlY2F0aW9uIHdhcm5pbmdcbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24gKG1zZykge1xuICByZXR1cm4gdXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge30sIG1zZywgJ25vZGUtdGVsZWdyYW0tYm90LWFwaScpKCk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/node_modules/debug/src/browser.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix3QkFBd0IsMkVBQTJFLGtDQUFrQyx3QkFBd0IsT0FBTyxrQ0FBa0MsbUlBQW1JOztBQUV6VTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsNkZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG9saXN0LXdlYi8uL25vZGVfbW9kdWxlcy9ub2RlLXRlbGVncmFtLWJvdC1hcGkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzPzdiZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/common.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/node_modules/debug/src/common.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw0Q0FBSTtBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvbGlzdC13ZWIvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzPzdkZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG4gIGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcbiAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG4gIC8qKlxuICAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcbiAgLyoqXG4gICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gICovXG5cbiAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgLyoqXG4gICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICAqXG4gICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcbiAgLyoqXG4gICogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcbiAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2VcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICB2YXIgaGFzaCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAvKipcbiAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgIHZhciBwcmV2VGltZTtcblxuICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgLy8gRGlzYWJsZWQ/XG4gICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSBkZWJ1ZzsgLy8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblxuICAgICAgdmFyIGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgc2VsZi5kaWZmID0gbXM7XG4gICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICBwcmV2VGltZSA9IGN1cnI7XG4gICAgICBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICAgIH0gLy8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblxuXG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uIChtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7IC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblxuICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7IC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcbiAgICAgIHZhciBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcbiAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICBkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgIGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICBkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7IC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcbiAgICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG4gICAgcmV0dXJuIGRlYnVnO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG4gIH1cbiAgLyoqXG4gICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICAgIGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG4gICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFzcGxpdFtpXSkge1xuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cbiAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcbiAgICAgIGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAqXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgY3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcbiAgfVxuICAvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICAgIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBDb2VyY2UgYHZhbGAuXG4gICpcbiAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuICByZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\nif (typeof process === 'undefined' || process.type === 'renderer' || false === true || process.__nwjs) {\n  module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/browser.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/node.js\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsS0FBZTtBQUNwRixFQUFFLHdJQUF3QztBQUMxQyxFQUFFO0FBQ0YsRUFBRSxrSUFBcUM7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvbGlzdC13ZWIvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanM/OTUyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgLyBud2pzIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/node.js":
/*!***************************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/node_modules/debug/src/node.js ***!
  \***************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Module dependencies.\n */\nvar tty = __webpack_require__(/*! tty */ \"tty\");\n\nvar util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n  // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n  // eslint-disable-next-line import/no-extraneous-dependencies\n  var supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n\n  if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];\n  }\n} catch (error) {} // Swallow - we only care if `supports-color` is available; it doesn't have to be.\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // Camel-case\n  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n    return k.toUpperCase();\n  }); // Coerce string value into JS value\n\n  var val = process.env[key];\n\n  if (/^(yes|on|true|enabled)$/i.test(val)) {\n    val = true;\n  } else if (/^(no|off|false|disabled)$/i.test(val)) {\n    val = false;\n  } else if (val === 'null') {\n    val = null;\n  } else {\n    val = Number(val);\n  }\n\n  obj[prop] = val;\n  return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  var name = this.namespace,\n      useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var colorCode = \"\\x1B[3\" + (c < 8 ? c : '8;5;' + c);\n    var prefix = \"  \".concat(colorCode, \";1m\").concat(name, \" \\x1B[0m\");\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + \"\\x1B[0m\");\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  }\n\n  return new Date().toISOString() + ' ';\n}\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\n\nfunction log() {\n  return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  if (namespaces) {\n    process.env.DEBUG = namespaces;\n  } else {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\n\nfunction init(debug) {\n  debug.inspectOpts = {};\n  var keys = Object.keys(exports.inspectOpts);\n\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n')\n    .map(function (str) { return str.trim(); })\n    .join(' ');\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\n\nformatters.O = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsZ0JBQUs7O0FBRXZCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QjtBQUNBO0FBQ0E7OztBQUdBLFlBQVk7QUFDWixXQUFXO0FBQ1gsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFnQjs7QUFFOUM7QUFDQSxJQUFJLGNBQWM7QUFDbEI7QUFDQSxFQUFFLGlCQUFpQiw0REFBNEQ7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLG1CQUFtQjtBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLDZGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG9saXN0LXdlYi8uL25vZGVfbW9kdWxlcy9ub2RlLXRlbGVncmFtLWJvdC1hcGkvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzPzFiNGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xudmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbi8qKlxuICogVGhpcyBpcyB0aGUgTm9kZS5qcyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuICAvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4gIHZhciBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuICBpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuICAgIGV4cG9ydHMuY29sb3JzID0gWzIwLCAyMSwgMjYsIDI3LCAzMiwgMzMsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNTYsIDU3LCA2MiwgNjMsIDY4LCA2OSwgNzQsIDc1LCA3NiwgNzcsIDc4LCA3OSwgODAsIDgxLCA5MiwgOTMsIDk4LCA5OSwgMTEyLCAxMTMsIDEyOCwgMTI5LCAxMzQsIDEzNSwgMTQ4LCAxNDksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzgsIDE3OSwgMTg0LCAxODUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTQsIDIxNSwgMjIwLCAyMjFdO1xuICB9XG59IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAvLyBDYW1lbC1jYXNlXG4gIHZhciBwcm9wID0ga2V5LnN1YnN0cmluZyg2KS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL18oW2Etel0pL2csIGZ1bmN0aW9uIChfLCBrKSB7XG4gICAgcmV0dXJuIGsudG9VcHBlckNhc2UoKTtcbiAgfSk7IC8vIENvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuXG4gIHZhciB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXG4gIGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcbiAgICB2YWwgPSB0cnVlO1xuICB9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG4gICAgdmFsID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcbiAgICB2YWwgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICB9XG5cbiAgb2JqW3Byb3BdID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICByZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/IEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpIDogdHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lc3BhY2UsXG4gICAgICB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBpZiAodXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNvbG9yO1xuICAgIHZhciBjb2xvckNvZGUgPSBcIlxceDFCWzNcIiArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcbiAgICB2YXIgcHJlZml4ID0gXCIgIFwiLmNvbmNhdChjb2xvckNvZGUsIFwiOzFtXCIpLmNvbmNhdChuYW1lLCBcIiBcXHgxQlswbVwiKTtcbiAgICBhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG4gICAgYXJncy5wdXNoKGNvbG9yQ29kZSArICdtKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgXCJcXHgxQlswbVwiKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzWzBdID0gZ2V0RGF0ZSgpICsgbmFtZSArICcgJyArIGFyZ3NbMF07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcbiAgaWYgKGV4cG9ydHMuaW5zcGVjdE9wdHMuaGlkZURhdGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdCgpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cblxuZnVuY3Rpb24gbG9nKCkge1xuICByZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSArICdcXG4nKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgcHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuICAgIC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcbiAgZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKVxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci50cmltKCk7IH0pXG4gICAgLmpvaW4oJyAnKTtcbn07XG4vKipcbiAqIE1hcCAlTyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuXG5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbiAodikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/src/errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/src/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.BaseError = class BaseError extends Error {\n  /**\n   * @class BaseError\n   * @constructor\n   * @private\n   * @param  {String} code Error code\n   * @param  {String} message Error message\n   */\n  constructor(code, message) {\n    super(`${code}: ${message}`);\n    this.code = code;\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      message: this.message,\n    };\n  }\n};\n\n\nexports.FatalError = class FatalError extends exports.BaseError {\n  /**\n   * Fatal Error. Error code is `\"EFATAL\"`.\n   * @class FatalError\n   * @constructor\n   * @param  {String|Error} data Error object or message\n   */\n  constructor(data) {\n    const error = (typeof data === 'string') ? null : data;\n    const message = error ? error.message : data;\n    super('EFATAL', message);\n    if (error) this.stack = error.stack;\n  }\n};\n\n\nexports.ParseError = class ParseError extends exports.BaseError {\n  /**\n   * Error during parsing. Error code is `\"EPARSE\"`.\n   * @class ParseError\n   * @constructor\n   * @param  {String} message Error message\n   * @param  {http.IncomingMessage} response Server response\n   */\n  constructor(message, response) {\n    super('EPARSE', message);\n    this.response = response;\n  }\n};\n\n\nexports.TelegramError = class TelegramError extends exports.BaseError {\n  /**\n   * Error returned from Telegram. Error code is `\"ETELEGRAM\"`.\n   * @class TelegramError\n   * @constructor\n   * @param  {String} message Error message\n   * @param  {http.IncomingMessage} response Server response\n   */\n  constructor(message, response) {\n    super('ETELEGRAM', message);\n    this.response = response;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL3NyYy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsYUFBYSxLQUFLLElBQUksUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kb2xpc3Qtd2ViLy4vbm9kZV9tb2R1bGVzL25vZGUtdGVsZWdyYW0tYm90LWFwaS9zcmMvZXJyb3JzLmpzPzAzNDAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5CYXNlRXJyb3IgPSBjbGFzcyBCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBAY2xhc3MgQmFzZUVycm9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNvZGUgRXJyb3IgY29kZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKGAke2NvZGV9OiAke21lc3NhZ2V9YCk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICB9O1xuICB9XG59O1xuXG5cbmV4cG9ydHMuRmF0YWxFcnJvciA9IGNsYXNzIEZhdGFsRXJyb3IgZXh0ZW5kcyBleHBvcnRzLkJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBGYXRhbCBFcnJvci4gRXJyb3IgY29kZSBpcyBgXCJFRkFUQUxcImAuXG4gICAqIEBjbGFzcyBGYXRhbEVycm9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtTdHJpbmd8RXJyb3J9IGRhdGEgRXJyb3Igb2JqZWN0IG9yIG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBjb25zdCBlcnJvciA9ICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpID8gbnVsbCA6IGRhdGE7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yID8gZXJyb3IubWVzc2FnZSA6IGRhdGE7XG4gICAgc3VwZXIoJ0VGQVRBTCcsIG1lc3NhZ2UpO1xuICAgIGlmIChlcnJvcikgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICB9XG59O1xuXG5cbmV4cG9ydHMuUGFyc2VFcnJvciA9IGNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBleHBvcnRzLkJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBFcnJvciBkdXJpbmcgcGFyc2luZy4gRXJyb3IgY29kZSBpcyBgXCJFUEFSU0VcImAuXG4gICAqIEBjbGFzcyBQYXJzZUVycm9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0gIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVzcG9uc2UgU2VydmVyIHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZXNwb25zZSkge1xuICAgIHN1cGVyKCdFUEFSU0UnLCBtZXNzYWdlKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIH1cbn07XG5cblxuZXhwb3J0cy5UZWxlZ3JhbUVycm9yID0gY2xhc3MgVGVsZWdyYW1FcnJvciBleHRlbmRzIGV4cG9ydHMuQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEVycm9yIHJldHVybmVkIGZyb20gVGVsZWdyYW0uIEVycm9yIGNvZGUgaXMgYFwiRVRFTEVHUkFNXCJgLlxuICAgKiBAY2xhc3MgVGVsZWdyYW1FcnJvclxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7U3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtICB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlc3BvbnNlIFNlcnZlciByZXNwb25zZVxuICAgKi9cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVzcG9uc2UpIHtcbiAgICBzdXBlcignRVRFTEVHUkFNJywgbWVzc2FnZSk7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/src/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/src/telegram.js":
/*!************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/src/telegram.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// shims\n(__webpack_require__(/*! array.prototype.findindex */ \"(rsc)/./node_modules/array.prototype.findindex/index.js\").shim)(); // for Node.js v0.x\n\nconst errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/src/errors.js\");\nconst TelegramBotWebHook = __webpack_require__(/*! ./telegramWebHook */ \"(rsc)/./node_modules/node-telegram-bot-api/src/telegramWebHook.js\");\nconst TelegramBotPolling = __webpack_require__(/*! ./telegramPolling */ \"(rsc)/./node_modules/node-telegram-bot-api/src/telegramPolling.js\");\nconst debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nconst EventEmitter = __webpack_require__(/*! eventemitter3 */ \"(rsc)/./node_modules/eventemitter3/index.js\");\nconst fileType = __webpack_require__(/*! file-type */ \"(rsc)/./node_modules/file-type/index.js\");\nconst request = __webpack_require__(/*! @cypress/request-promise */ \"(rsc)/./node_modules/@cypress/request-promise/lib/rp.js\");\nconst streamedRequest = __webpack_require__(/*! @cypress/request */ \"(rsc)/./node_modules/@cypress/request/index.js\");\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst mime = __webpack_require__(/*! mime */ \"(rsc)/./node_modules/mime/mime.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst URL = __webpack_require__(/*! url */ \"url\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst pump = __webpack_require__(/*! pump */ \"(rsc)/./node_modules/pump/index.js\");\nconst deprecate = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/node-telegram-bot-api/src/utils.js\").deprecate);\n\nconst _messageTypes = [\n  'text',\n  'animation',\n  'audio',\n  'channel_chat_created',\n  'contact',\n  'delete_chat_photo',\n  'dice',\n  'document',\n  'game',\n  'group_chat_created',\n  'invoice',\n  'left_chat_member',\n  'location',\n  'migrate_from_chat_id',\n  'migrate_to_chat_id',\n  'new_chat_members',\n  'new_chat_photo',\n  'new_chat_title',\n  'passport_data',\n  'photo',\n  'pinned_message',\n  'poll',\n  'sticker',\n  'successful_payment',\n  'supergroup_chat_created',\n  'video',\n  'video_note',\n  'voice',\n  'video_chat_started',\n  'video_chat_ended',\n  'video_chat_participants_invited',\n  'video_chat_scheduled',\n  'message_auto_delete_timer_changed',\n  'chat_invite_link',\n  'chat_member_updated',\n  'web_app_data',\n  'message_reaction'\n];\n\nconst _deprecatedMessageTypes = [\n  'new_chat_participant', 'left_chat_participant'\n];\n\n/**\n * JSON-serialize data. If the provided data is already a String,\n * return it as is.\n * @private\n * @param  {*} data\n * @return {String}\n */\nfunction stringify(data) {\n  if (typeof data === 'string') {\n    return data;\n  }\n  return JSON.stringify(data);\n}\n\n\nclass TelegramBot extends EventEmitter {\n  /**\n   * The different errors the library uses.\n   * @type {Object}\n   */\n  static get errors() {\n    return errors;\n  }\n\n  /**\n   * The types of message updates the library handles.\n   * @type {String[]}\n   */\n  static get messageTypes() {\n    return _messageTypes;\n  }\n\n  /**\n   * Add listener for the specified [event](https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events).\n   * This is the usual `emitter.on()` method.\n   * @param  {String} event\n   * @param  {Function} listener\n   * @see {@link https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events|Available events}\n   * @see https://nodejs.org/api/events.html#events_emitter_on_eventname_listener\n   */\n  on(event, listener) {\n    if (_deprecatedMessageTypes.indexOf(event) !== -1) {\n      const url = 'https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events';\n      deprecate(`Events ${_deprecatedMessageTypes.join(',')} are deprecated. See the updated list of events: ${url}`);\n    }\n    super.on(event, listener);\n  }\n\n  /**\n   * Both request method to obtain messages are implemented. To use standard polling, set `polling: true`\n   * on `options`. Notice that [webHook](https://core.telegram.org/bots/api#setwebhook) will need a SSL certificate.\n   * Emits `message` when a message arrives.\n   *\n   * @class TelegramBot\n   * @constructor\n   * @param {String} token Bot Token\n   * @param {Object} [options]\n   * @param {Boolean|Object} [options.polling=false] Set true to enable polling or set options.\n   *  If a WebHook has been set, it will be deleted automatically.\n   * @param {String|Number} [options.polling.timeout=10] *Deprecated. Use `options.polling.params` instead*.\n   *  Timeout in seconds for long polling.\n   * @param {Boolean} [options.testEnvironment=false] Set true to  work with test enviroment.\n   * When working with the test environment, you may use HTTP links without TLS to test your Web App.\n   * @param {String|Number} [options.polling.interval=300] Interval between requests in miliseconds\n   * @param {Boolean} [options.polling.autoStart=true] Start polling immediately\n   * @param {Object} [options.polling.params] Parameters to be used in polling API requests.\n   *  See https://core.telegram.org/bots/api#getupdates for more information.\n   * @param  {Number} [options.polling.params.timeout=10] Timeout in seconds for long polling.\n   * @param {Boolean|Object} [options.webHook=false] Set true to enable WebHook or set options\n   * @param {String} [options.webHook.host=\"0.0.0.0\"] Host to bind to\n   * @param {Number} [options.webHook.port=8443] Port to bind to\n   * @param {String} [options.webHook.key] Path to file with PEM private key for webHook server.\n   *  The file is read **synchronously**!\n   * @param {String} [options.webHook.cert] Path to file with PEM certificate (public) for webHook server.\n   *  The file is read **synchronously**!\n   * @param {String} [options.webHook.pfx] Path to file with PFX private key and certificate chain for webHook server.\n   *  The file is read **synchronously**!\n   * @param {Boolean} [options.webHook.autoOpen=true] Open webHook immediately\n   * @param {Object} [options.webHook.https] Options to be passed to `https.createServer()`.\n   *  Note that `options.webHook.key`, `options.webHook.cert` and `options.webHook.pfx`, if provided, will be\n   *  used to override `key`, `cert` and `pfx` in this object, respectively.\n   *  See https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener for more information.\n   * @param {String} [options.webHook.healthEndpoint=\"/healthz\"] An endpoint for health checks that always responds with 200 OK\n   * @param {Boolean} [options.onlyFirstMatch=false] Set to true to stop after first match. Otherwise, all regexps are executed\n   * @param {Object} [options.request] Options which will be added for all requests to telegram api.\n   *  See https://github.com/request/request#requestoptions-callback for more information.\n   * @param {String} [options.baseApiUrl=\"https://api.telegram.org\"] API Base URl; useful for proxying and testing\n   * @param {Boolean} [options.filepath=true] Allow passing file-paths as arguments when sending files,\n   *  such as photos using `TelegramBot#sendPhoto()`. See [usage information][usage-sending-files-performance]\n   *  for more information on this option and its consequences.\n   * @param {Boolean} [options.badRejection=false] Set to `true`\n   *  **if and only if** the Node.js version you're using terminates the\n   *  process on unhandled rejections. This option is only for\n   *  *forward-compatibility purposes*.\n   * @see https://core.telegram.org/bots/api\n   */\n  constructor(token, options = {}) {\n    super();\n    this.token = token;\n    this.options = options;\n    this.options.polling = (typeof options.polling === 'undefined') ? false : options.polling;\n    this.options.webHook = (typeof options.webHook === 'undefined') ? false : options.webHook;\n    this.options.baseApiUrl = options.baseApiUrl || 'https://api.telegram.org';\n    this.options.filepath = (typeof options.filepath === 'undefined') ? true : options.filepath;\n    this.options.badRejection = (typeof options.badRejection === 'undefined') ? false : options.badRejection;\n    this._textRegexpCallbacks = [];\n    this._replyListenerId = 0;\n    this._replyListeners = [];\n    this._polling = null;\n    this._webHook = null;\n\n    if (options.polling) {\n      const autoStart = options.polling.autoStart;\n      if (typeof autoStart === 'undefined' || autoStart === true) {\n        this.startPolling();\n      }\n    }\n\n    if (options.webHook) {\n      const autoOpen = options.webHook.autoOpen;\n      if (typeof autoOpen === 'undefined' || autoOpen === true) {\n        this.openWebHook();\n      }\n    }\n  }\n\n  /**\n   * Generates url with bot token and provided path/method you want to be got/executed by bot\n   * @param  {String} path\n   * @return {String} url\n   * @private\n   * @see https://core.telegram.org/bots/api#making-requests\n   */\n  _buildURL(_path) {\n    return `${this.options.baseApiUrl}/bot${this.token}${this.options.testEnvironment ? '/test' : ''}/${_path}`;\n  }\n\n  /**\n   * Fix 'reply_markup' parameter by making it JSON-serialized, as\n   * required by the Telegram Bot API\n   * @param {Object} obj Object; either 'form' or 'qs'\n   * @private\n   * @see https://core.telegram.org/bots/api#sendmessage\n   */\n  _fixReplyMarkup(obj) {\n    const replyMarkup = obj.reply_markup;\n    if (replyMarkup && typeof replyMarkup !== 'string') {\n      obj.reply_markup = stringify(replyMarkup);\n    }\n  }\n\n  /**\n   * Fix 'entities' or 'caption_entities' or 'explanation_entities' parameter by making it JSON-serialized, as\n   * required by the Telegram Bot API\n   * @param {Object} obj Object;\n   * @private\n   * @see https://core.telegram.org/bots/api#sendmessage\n   * @see https://core.telegram.org/bots/api#copymessage\n   * @see https://core.telegram.org/bots/api#sendpoll\n   */\n  _fixEntitiesField(obj) {\n    const entities = obj.entities;\n    const captionEntities = obj.caption_entities;\n    const explanationEntities = obj.explanation_entities;\n    if (entities && typeof entities !== 'string') {\n      obj.entities = stringify(entities);\n    }\n\n    if (captionEntities && typeof captionEntities !== 'string') {\n      obj.caption_entities = stringify(captionEntities);\n    }\n\n    if (explanationEntities && typeof explanationEntities !== 'string') {\n      obj.explanation_entities = stringify(explanationEntities);\n    }\n  }\n\n  _fixAddFileThumbnail(options, opts) {\n    if (options.thumb) {\n      if (opts.formData === null) {\n        opts.formData = {};\n      }\n\n      const attachName = 'photo';\n      const [formData] = this._formatSendData(attachName, options.thumb.replace('attach://', ''));\n\n      if (formData) {\n        opts.formData[attachName] = formData[attachName];\n        opts.qs.thumbnail = `attach://${attachName}`;\n      }\n    }\n  }\n\n  /**\n   * Fix 'reply_parameters' parameter by making it JSON-serialized, as\n   * required by the Telegram Bot API\n   * @param {Object} obj Object; either 'form' or 'qs'\n   * @private\n   * @see https://core.telegram.org/bots/api#sendmessage\n   */\n  _fixReplyParameters(obj) {\n    if (obj.hasOwnProperty('reply_parameters') && typeof obj.reply_parameters !== 'string') {\n      obj.reply_parameters = stringify(obj.reply_parameters);\n    }\n  }\n\n  /**\n   * Make request against the API\n   * @param  {String} _path API endpoint\n   * @param  {Object} [options]\n   * @private\n   * @return {Promise}\n   */\n  _request(_path, options = {}) {\n    if (!this.token) {\n      return Promise.reject(new errors.FatalError('Telegram Bot Token not provided!'));\n    }\n\n    if (this.options.request) {\n      Object.assign(options, this.options.request);\n    }\n\n    if (options.form) {\n      this._fixReplyMarkup(options.form);\n      this._fixEntitiesField(options.form);\n      this._fixReplyParameters(options.form);\n    }\n    if (options.qs) {\n      this._fixReplyMarkup(options.qs);\n      this._fixReplyParameters(options.qs);\n    }\n\n    options.method = 'POST';\n    options.url = this._buildURL(_path);\n    options.simple = false;\n    options.resolveWithFullResponse = true;\n    options.forever = true;\n    debug('HTTP request: %j', options);\n    return request(options)\n      .then(resp => {\n        let data;\n        try {\n          data = resp.body = JSON.parse(resp.body);\n        } catch (err) {\n          throw new errors.ParseError(`Error parsing response: ${resp.body}`, resp);\n        }\n\n        if (data.ok) {\n          return data.result;\n        }\n\n        throw new errors.TelegramError(`${data.error_code} ${data.description}`, resp);\n      }).catch(error => {\n        // TODO: why can't we do `error instanceof errors.BaseError`?\n        if (error.response) throw error;\n        throw new errors.FatalError(error);\n      });\n  }\n\n  /**\n   * Format data to be uploaded; handles file paths, streams and buffers\n   * @param  {String} type\n   * @param  {String|stream.Stream|Buffer} data\n   * @param  {Object} fileOptions File options\n   * @param  {String} [fileOptions.filename] File name\n   * @param  {String} [fileOptions.contentType] Content type (i.e. MIME)\n   * @return {Array} formatted\n   * @return {Object} formatted[0] formData\n   * @return {String} formatted[1] fileId\n   * @throws Error if Buffer file type is not supported.\n   * @see https://npmjs.com/package/file-type\n   * @private\n   */\n  _formatSendData(type, data, fileOptions = {}) {\n    const deprecationMessage =\n      'See https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files' +\n      ' for more information on how sending files has been improved and' +\n      ' on how to disable this deprecation message altogether.';\n    let filedata = data;\n    let filename = fileOptions.filename;\n    let contentType = fileOptions.contentType;\n\n    if (data instanceof stream.Stream) {\n      if (!filename && data.path) {\n        // Will be 'null' if could not be parsed.\n        // For example, 'data.path' === '/?id=123' from 'request(\"https://example.com/?id=123\")'\n        const url = URL.parse(path.basename(data.path.toString()));\n        if (url.pathname) {\n          filename = qs.unescape(url.pathname);\n        }\n      }\n    } else if (Buffer.isBuffer(data)) {\n      if (!filename && !process.env.NTBA_FIX_350) {\n        deprecate(`Buffers will have their filenames default to \"filename\" instead of \"data\". ${deprecationMessage}`);\n        filename = 'data';\n      }\n      if (!contentType) {\n        const filetype = fileType(data);\n        if (filetype) {\n          contentType = filetype.mime;\n          const ext = filetype.ext;\n          if (ext && !process.env.NTBA_FIX_350) {\n            filename = `${filename}.${ext}`;\n          }\n        } else if (!process.env.NTBA_FIX_350) {\n          deprecate(`An error will no longer be thrown if file-type of buffer could not be detected. ${deprecationMessage}`);\n          throw new errors.FatalError('Unsupported Buffer file-type');\n        }\n      }\n    } else if (data) {\n      if (this.options.filepath && fs.existsSync(data)) {\n        filedata = fs.createReadStream(data);\n        if (!filename) {\n          filename = path.basename(data);\n        }\n      } else {\n        return [null, data];\n      }\n    } else {\n      return [null, data];\n    }\n\n    filename = filename || 'filename';\n    contentType = contentType || mime.lookup(filename);\n    if (process.env.NTBA_FIX_350) {\n      contentType = contentType || 'application/octet-stream';\n    } else {\n      deprecate(`In the future, content-type of files you send will default to \"application/octet-stream\". ${deprecationMessage}`);\n    }\n\n    // TODO: Add missing file extension.\n\n    return [{\n      [type]: {\n        value: filedata,\n        options: {\n          filename,\n          contentType,\n        },\n      },\n    }, null];\n  }\n\n  /**\n   * Start polling.\n   * Rejects returned promise if a WebHook is being used by this instance.\n   * @param  {Object} [options]\n   * @param  {Boolean} [options.restart=true] Consecutive calls to this method causes polling to be restarted\n   * @return {Promise}\n   */\n  startPolling(options = {}) {\n    if (this.hasOpenWebHook()) {\n      return Promise.reject(new errors.FatalError('Polling and WebHook are mutually exclusive'));\n    }\n    options.restart = typeof options.restart === 'undefined' ? true : options.restart;\n    if (!this._polling) {\n      this._polling = new TelegramBotPolling(this);\n    }\n    return this._polling.start(options);\n  }\n\n  /**\n   * Alias of `TelegramBot#startPolling()`. This is **deprecated**.\n   * @param  {Object} [options]\n   * @return {Promise}\n   * @deprecated\n   */\n  initPolling() {\n    deprecate('TelegramBot#initPolling() is deprecated. Use TelegramBot#startPolling() instead.');\n    return this.startPolling();\n  }\n\n  /**\n   * Stops polling after the last polling request resolves.\n   * Multiple invocations do nothing if polling is already stopped.\n   * Returning the promise of the last polling request is **deprecated**.\n   * @param  {Object} [options] Options\n   * @param  {Boolean} [options.cancel] Cancel current request\n   * @param  {String} [options.reason] Reason for stopping polling\n   * @return {Promise}\n   */\n  stopPolling(options) {\n    if (!this._polling) {\n      return Promise.resolve();\n    }\n    return this._polling.stop(options);\n  }\n\n  /**\n   * Get link for file.\n   * Use this method to get link for file for subsequent use.\n   * Attention: link will be valid for 1 hour.\n   *\n   * This method is a sugar extension of the (getFile)[#getfilefileid] method,\n   * which returns just path to file on remote server (you will have to manually build full uri after that).\n   *\n   * @param  {String} fileId  File identifier to get info about\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Promise which will have  *fileURI* in resolve callback\n   * @see https://core.telegram.org/bots/api#getfile\n   */\n  getFileLink(fileId, form = {}) {\n    return this.getFile(fileId, form)\n      .then(resp => `${this.options.baseApiUrl}/file/bot${this.token}/${resp.file_path}`);\n  }\n\n  /**\n   * Return a readable stream for file.\n   *\n   * `fileStream.path` is the specified file ID i.e. `fileId`.\n   * `fileStream` emits event `info` passing a single argument i.e.\n   * `info` with the interface `{ uri }` where `uri` is the URI of the\n   * file on Telegram servers.\n   *\n   * This method is a sugar extension of the [getFileLink](#TelegramBot+getFileLink) method,\n   * which returns the full URI to the file on remote server.\n   *\n   * @param  {String} fileId File identifier to get info about\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {stream.Readable} fileStream\n   */\n  getFileStream(fileId, form = {}) {\n    const fileStream = new stream.PassThrough();\n    fileStream.path = fileId;\n    this.getFileLink(fileId, form)\n      .then((fileURI) => {\n        fileStream.emit('info', {\n          uri: fileURI,\n        });\n        pump(streamedRequest(Object.assign({ uri: fileURI }, this.options.request)), fileStream);\n      })\n      .catch((error) => {\n        fileStream.emit('error', error);\n      });\n    return fileStream;\n  }\n\n  /**\n   * Downloads file in the specified folder.\n   *\n   * This method is a sugar extension of the [getFileStream](#TelegramBot+getFileStream) method,\n   * which returns a readable file stream.\n   *\n   * @param  {String} fileId  File identifier to get info about\n   * @param  {String} downloadDir Absolute path to the folder in which file will be saved\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Promise, which will have *filePath* of downloaded file in resolve callback\n   */\n  downloadFile(fileId, downloadDir, form = {}) {\n    let resolve;\n    let reject;\n    const promise = new Promise((a, b) => {\n      resolve = a;\n      reject = b;\n    });\n    const fileStream = this.getFileStream(fileId, form);\n    fileStream.on('info', (info) => {\n      const fileName = info.uri.slice(info.uri.lastIndexOf('/') + 1);\n      // TODO: Ensure fileName doesn't contains slashes\n      const filePath = path.join(downloadDir, fileName);\n      pump(fileStream, fs.createWriteStream(filePath), (error) => {\n        if (error) { return reject(error); }\n        return resolve(filePath);\n      });\n    });\n    fileStream.on('error', (err) => {\n      reject(err);\n    });\n    return promise;\n  }\n\n  /**\n   * Register a RegExp to test against an incomming text message.\n   * @param  {RegExp}   regexpRexecuted with `exec`.\n   * @param  {Function} callback     Callback will be called with 2 parameters,\n   * the `msg` and the result of executing `regexp.exec` on message text.\n   */\n  onText(regexp, callback) {\n    this._textRegexpCallbacks.push({ regexp, callback });\n  }\n\n  /**\n   * Remove a listener registered with `onText()`.\n   * @param  {RegExp} regexp RegExp used previously in `onText()`\n   * @return {Object} deletedListener The removed reply listener if\n   *   found. This object has `regexp` and `callback`\n   *   properties. If not found, returns `null`.\n   */\n  removeTextListener(regexp) {\n    const index = this._textRegexpCallbacks.findIndex((textListener) => {\n      return String(textListener.regexp) === String(regexp);\n    });\n    if (index === -1) {\n      return null;\n    }\n    return this._textRegexpCallbacks.splice(index, 1)[0];\n  }\n\n  /**\n   * Remove all listeners registered with `onText()`.\n   */\n  clearTextListeners() {\n    this._textRegexpCallbacks = [];\n  }\n\n  /**\n   * Register a reply to wait for a message response.\n   *\n   * @param  {Number|String} chatId The chat id where the message cames from.\n   * @param  {Number|String} messageId The message id to be replied.\n   * @param  {Function} callback Callback will be called with the reply\n   *  message.\n   * @return {Number} id The ID of the inserted reply listener.\n   */\n  onReplyToMessage(chatId, messageId, callback) {\n    const id = ++this._replyListenerId;\n    this._replyListeners.push({\n      id,\n      chatId,\n      messageId,\n      callback\n    });\n    return id;\n  }\n\n  /**\n   * Removes a reply that has been prev. registered for a message response.\n   * @param   {Number} replyListenerId The ID of the reply listener.\n   * @return  {Object} deletedListener The removed reply listener if\n   *   found. This object has `id`, `chatId`, `messageId` and `callback`\n   *   properties. If not found, returns `null`.\n   */\n  removeReplyListener(replyListenerId) {\n    const index = this._replyListeners.findIndex((replyListener) => {\n      return replyListener.id === replyListenerId;\n    });\n    if (index === -1) {\n      return null;\n    }\n    return this._replyListeners.splice(index, 1)[0];\n  }\n\n  /**\n   * Removes all replies that have been prev. registered for a message response.\n   *\n   * @return  {Array} deletedListeners An array of removed listeners.\n   */\n  clearReplyListeners() {\n    this._replyListeners = [];\n  }\n\n  /**\n   * Return true if polling. Otherwise, false.\n   *\n   * @return {Boolean}\n   */\n  isPolling() {\n    return this._polling ? this._polling.isPolling() : false;\n  }\n\n  /**\n   * Open webhook.\n   * Multiple invocations do nothing if webhook is already open.\n   * Rejects returned promise if Polling is being used by this instance.\n   *\n   * @return {Promise}\n   */\n  openWebHook() {\n    if (this.isPolling()) {\n      return Promise.reject(new errors.FatalError('WebHook and Polling are mutually exclusive'));\n    }\n    if (!this._webHook) {\n      this._webHook = new TelegramBotWebHook(this);\n    }\n    return this._webHook.open();\n  }\n\n  /**\n   * Close webhook after closing all current connections.\n   * Multiple invocations do nothing if webhook is already closed.\n   *\n   * @return {Promise} Promise\n   */\n  closeWebHook() {\n    if (!this._webHook) {\n      return Promise.resolve();\n    }\n    return this._webHook.close();\n  }\n\n  /**\n   * Return true if using webhook and it is open i.e. accepts connections.\n   * Otherwise, false.\n   *\n   * @return {Boolean}\n   */\n  hasOpenWebHook() {\n    return this._webHook ? this._webHook.isOpen() : false;\n  }\n\n\n  /**\n   * Process an update; emitting the proper events and executing regexp\n   * callbacks. This method is useful should you be using a different\n   * way to fetch updates, other than those provided by TelegramBot.\n   *\n   * @param  {Object} update\n   * @see https://core.telegram.org/bots/api#update\n   */\n  processUpdate(update) {\n    debug('Process Update %j', update);\n    const message = update.message;\n    const editedMessage = update.edited_message;\n    const channelPost = update.channel_post;\n    const editedChannelPost = update.edited_channel_post;\n    const businessConnection = update.business_connection;\n    const businesssMessage = update.business_message;\n    const editedBusinessMessage = update.edited_business_message;\n    const deletedBusinessMessage = update.deleted_business_messages;\n    const messageReaction = update.message_reaction;\n    const messageReactionCount = update.message_reaction_count;\n    const inlineQuery = update.inline_query;\n    const chosenInlineResult = update.chosen_inline_result;\n    const callbackQuery = update.callback_query;\n    const shippingQuery = update.shipping_query;\n    const preCheckoutQuery = update.pre_checkout_query;\n    const poll = update.poll;\n    const pollAnswer = update.poll_answer;\n    const myChatMember = update.my_chat_member;\n    const chatMember = update.chat_member;\n    const chatJoinRequest = update.chat_join_request;\n    const chatBoost = update.chat_boost;\n    const removedChatBoost = update.removed_chat_boost;\n\n\n    if (message) {\n      debug('Process Update message %j', message);\n      const metadata = {};\n      metadata.type = TelegramBot.messageTypes.find((messageType) => {\n        return message[messageType];\n      });\n      this.emit('message', message, metadata);\n      if (metadata.type) {\n        debug('Emitting %s: %j', metadata.type, message);\n        this.emit(metadata.type, message, metadata);\n      }\n      if (message.text) {\n        debug('Text message');\n        this._textRegexpCallbacks.some(reg => {\n          debug('Matching %s with %s', message.text, reg.regexp);\n\n          if (!(reg.regexp instanceof RegExp)) {\n            reg.regexp = new RegExp(reg.regexp);\n          }\n\n          const result = reg.regexp.exec(message.text);\n          if (!result) {\n            return false;\n          }\n          // reset index so we start at the beginning of the regex each time\n          reg.regexp.lastIndex = 0;\n          debug('Matches %s', reg.regexp);\n          reg.callback(message, result);\n          // returning truthy value exits .some\n          return this.options.onlyFirstMatch;\n        });\n      }\n      if (message.reply_to_message) {\n        // Only callbacks waiting for this message\n        this._replyListeners.forEach(reply => {\n          // Message from the same chat\n          if (reply.chatId === message.chat.id) {\n            // Responding to that message\n            if (reply.messageId === message.reply_to_message.message_id) {\n              // Resolve the promise\n              reply.callback(message);\n            }\n          }\n        });\n      }\n    } else if (editedMessage) {\n      debug('Process Update edited_message %j', editedMessage);\n      this.emit('edited_message', editedMessage);\n      if (editedMessage.text) {\n        this.emit('edited_message_text', editedMessage);\n      }\n      if (editedMessage.caption) {\n        this.emit('edited_message_caption', editedMessage);\n      }\n    } else if (channelPost) {\n      debug('Process Update channel_post %j', channelPost);\n      this.emit('channel_post', channelPost);\n    } else if (editedChannelPost) {\n      debug('Process Update edited_channel_post %j', editedChannelPost);\n      this.emit('edited_channel_post', editedChannelPost);\n      if (editedChannelPost.text) {\n        this.emit('edited_channel_post_text', editedChannelPost);\n      }\n      if (editedChannelPost.caption) {\n        this.emit('edited_channel_post_caption', editedChannelPost);\n      }\n    } else if (businessConnection) {\n      debug('Process Update business_connection %j', businessConnection);\n      this.emit('business_connection', businessConnection);\n    } else if (businesssMessage) {\n      debug('Process Update business_message %j', businesssMessage);\n      this.emit('business_message', businesssMessage);\n    } else if (editedBusinessMessage) {\n      debug('Process Update edited_business_message %j', editedBusinessMessage);\n      this.emit('edited_business_message', editedBusinessMessage);\n    } else if (deletedBusinessMessage) {\n      debug('Process Update deleted_business_messages %j', deletedBusinessMessage);\n      this.emit('deleted_business_messages', deletedBusinessMessage);\n    } else if (messageReaction) {\n      debug('Process Update message_reaction %j', messageReaction);\n      this.emit('message_reaction', messageReaction);\n    } else if (messageReactionCount) {\n      debug('Process Update message_reaction_count %j', messageReactionCount);\n      this.emit('message_reaction_count', messageReactionCount);\n    } else if (inlineQuery) {\n      debug('Process Update inline_query %j', inlineQuery);\n      this.emit('inline_query', inlineQuery);\n    } else if (chosenInlineResult) {\n      debug('Process Update chosen_inline_result %j', chosenInlineResult);\n      this.emit('chosen_inline_result', chosenInlineResult);\n    } else if (callbackQuery) {\n      debug('Process Update callback_query %j', callbackQuery);\n      this.emit('callback_query', callbackQuery);\n    } else if (shippingQuery) {\n      debug('Process Update shipping_query %j', shippingQuery);\n      this.emit('shipping_query', shippingQuery);\n    } else if (preCheckoutQuery) {\n      debug('Process Update pre_checkout_query %j', preCheckoutQuery);\n      this.emit('pre_checkout_query', preCheckoutQuery);\n    } else if (poll) {\n      debug('Process Update poll %j', poll);\n      this.emit('poll', poll);\n    } else if (pollAnswer) {\n      debug('Process Update poll_answer %j', pollAnswer);\n      this.emit('poll_answer', pollAnswer);\n    } else if (chatMember) {\n      debug('Process Update chat_member %j', chatMember);\n      this.emit('chat_member', chatMember);\n    } else if (myChatMember) {\n      debug('Process Update my_chat_member %j', myChatMember);\n      this.emit('my_chat_member', myChatMember);\n    } else if (chatJoinRequest) {\n      debug('Process Update my_chat_member %j', chatJoinRequest);\n      this.emit('chat_join_request', chatJoinRequest);\n    } else if (chatBoost) {\n      debug('Process Update chat_boost %j', chatBoost);\n      this.emit('chat_boost', chatBoost);\n    } else if (removedChatBoost) {\n      debug('Process Update removed_chat_boost %j', removedChatBoost);\n      this.emit('removed_chat_boost', removedChatBoost);\n    }\n  }\n\n  /** Start Telegram Bot API methods */\n\n  /**\n  * Use this method to receive incoming updates using long polling.\n  * This method has an [older, compatible signature][getUpdates-v0.25.0]\n  * that is being deprecated.\n  *\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise}\n  * @see https://core.telegram.org/bots/api#getupdates\n  */\n  getUpdates(form = {}) {\n    /* The older method signature was getUpdates(timeout, limit, offset).\n     * We need to ensure backwards-compatibility while maintaining\n     * consistency of the method signatures throughout the library */\n    if (typeof form !== 'object') {\n      /* eslint-disable no-param-reassign, prefer-rest-params */\n      deprecate('The method signature getUpdates(timeout, limit, offset) has been deprecated since v0.25.0');\n      form = {\n        timeout: arguments[0],\n        limit: arguments[1],\n        offset: arguments[2],\n      };\n      /* eslint-enable no-param-reassign, prefer-rest-params */\n    }\n\n    return this._request('getUpdates', { form });\n  }\n\n  /**\n   * Specify an url to receive incoming updates via an outgoing webHook.\n   * This method has an [older, compatible signature][setWebHook-v0.25.0]\n   * that is being deprecated.\n   *\n   * @param  {String} url URL where Telegram will make HTTP Post. Leave empty to\n   * delete webHook.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {String|stream.Stream} [options.certificate] PEM certificate key (public).\n   * @param  {String} [options.secret_token] Optional secret token to be sent in a header `X-Telegram-Bot-Api-Secret-Token` in every webhook request.\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise}\n   * @see https://core.telegram.org/bots/api#setwebhook\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  setWebHook(url, options = {}, fileOptions = {}) {\n    /* The older method signature was setWebHook(url, cert).\n     * We need to ensure backwards-compatibility while maintaining\n     * consistency of the method signatures throughout the library */\n    let cert;\n    // Note: 'options' could be an object, if a stream was provided (in place of 'cert')\n    if (typeof options !== 'object' || options instanceof stream.Stream) {\n      deprecate('The method signature setWebHook(url, cert) has been deprecated since v0.25.0');\n      cert = options;\n      options = {}; // eslint-disable-line no-param-reassign\n    } else {\n      cert = options.certificate;\n    }\n\n    const opts = {\n      qs: options,\n    };\n    opts.qs.url = url;\n\n    if (cert) {\n      try {\n        const sendData = this._formatSendData('certificate', cert, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.certificate = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n    }\n\n    return this._request('setWebHook', opts);\n  }\n\n  /**\n   * Use this method to remove webhook integration if you decide to\n   * switch back to getUpdates. Returns True on success.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}\n   * @see https://core.telegram.org/bots/api#deletewebhook\n   */\n  deleteWebHook(form = {}) {\n    return this._request('deleteWebhook', { form });\n  }\n\n  /**\n   * Use this method to get current webhook status.\n   * On success, returns a [WebhookInfo](https://core.telegram.org/bots/api#webhookinfo) object.\n   * If the bot is using getUpdates, will return an object with the\n   * url field empty.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}\n   * @see https://core.telegram.org/bots/api#getwebhookinfo\n   */\n  getWebHookInfo(form = {}) {\n    return this._request('getWebhookInfo', { form });\n  }\n\n  /**\n   * A simple method for testing your bot's authentication token. Requires no parameters.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} basic information about the bot in form of a [User](https://core.telegram.org/bots/api#user) object.\n   * @see https://core.telegram.org/bots/api#getme\n   */\n  getMe(form = {}) {\n    return this._request('getMe', { form });\n  }\n\n  /**\n   * This method log out your bot from the cloud Bot API server before launching the bot locally.\n   * You must log out the bot before running it locally, otherwise there is no guarantee that the bot will receive updates.\n   * After a successful call, you will not be able to log in again using the same token for 10 minutes.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}  True on success\n   * @see https://core.telegram.org/bots/api#logout\n   */\n  logOut(form = {}) {\n    return this._request('logOut', { form });\n  }\n\n  /**\n   * This method close the bot instance before moving it from one local server to another.\n   * This method will return error 429 in the first 10 minutes after the bot is launched.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}  True on success\n   * @see https://core.telegram.org/bots/api#close\n   */\n  close(form = {}) {\n    return this._request('close', { form });\n  }\n\n  /**\n   * Send text message.\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} text Text of the message to be sent\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendmessage\n   */\n  sendMessage(chatId, text, form = {}) {\n    form.chat_id = chatId;\n    form.text = text;\n    return this._request('sendMessage', { form });\n  }\n\n  /**\n   * Forward messages of any kind.\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * or username of the target channel (in the format `@channelusername`)\n   * @param  {Number|String} fromChatId Unique identifier for the chat where the\n   * original message was sent (or channel username in the format `@channelusername`)\n   * @param  {Number|String} messageId  Unique message identifier in the chat specified in fromChatId\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}\n   * @see https://core.telegram.org/bots/api#forwardmessage\n   */\n  forwardMessage(chatId, fromChatId, messageId, form = {}) {\n    form.chat_id = chatId;\n    form.from_chat_id = fromChatId;\n    form.message_id = messageId;\n    return this._request('forwardMessage', { form });\n  }\n\n  /**\n   * Use this method to forward multiple messages of any kind.\n   * If some of the specified messages can't be found or forwarded, they are skipped.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * or username of the target channel (in the format `@channelusername`)\n   * @param  {Number|String} fromChatId Unique identifier for the chat where the\n   * original message was sent (or channel username in the format `@channelusername`)\n   * @param  {Array<Number|String>} messageIds Identifiers of 1-100 messages in the chat from_chat_id to forward.\n   * The identifiers must be specified in a strictly increasing order.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} An array of MessageId of the sent messages on success\n   * @see https://core.telegram.org/bots/api#forwardmessages\n   */\n  forwardMessages(chatId, fromChatId, messageIds, form = {}) {\n    form.chat_id = chatId;\n    form.from_chat_id = fromChatId;\n    form.message_ids = messageIds;\n    return this._request('forwardMessages', { form });\n  }\n\n  /**\n   * Copy messages of any kind. **Service messages and invoice messages can't be copied.**\n   * The method is analogous to the method forwardMessages, but the copied message doesn't\n   * have a link to the original message.\n   * Returns the MessageId of the sent message on success.\n   * @param  {Number|String} chatId     Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number|String} fromChatId Unique identifier for the chat where the\n   * original message was sent\n   * @param  {Number|String} messageId  Unique message identifier\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} The [MessageId](https://core.telegram.org/bots/api#messageid) of the sent message on success\n   * @see https://core.telegram.org/bots/api#copymessage\n   */\n  copyMessage(chatId, fromChatId, messageId, form = {}) {\n    form.chat_id = chatId;\n    form.from_chat_id = fromChatId;\n    form.message_id = messageId;\n    return this._request('copyMessage', { form });\n  }\n\n  /**\n   * Use this method to copy messages of any kind. If some of the specified messages can't be found or copied, they are skipped.\n   * Service messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied.\n   * Returns the MessageId of the sent message on success.\n   * @param  {Number|String} chatId Unique identifier for the target chat\n   * @param  {Number|String} fromChatId Unique identifier for the chat where the\n   * original message was sent\n   * @param  {Array} messageIds  Identifiers of 1-100 messages in the chat from_chat_id to copy.\n   * The identifiers must be specified in a strictly increasing order.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} An array of MessageId of the sent messages\n   * @see https://core.telegram.org/bots/api#copymessages\n   */\n  copyMessages(chatId, fromChatId, messageIds, form = {}) {\n    form.chat_id = chatId;\n    form.from_chat_id = fromChatId;\n    form.message_ids = stringify(messageIds);\n    return this._request('copyMessages', { form });\n  }\n\n  /**\n   * Send photo\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} photo A file path or a Stream. Can\n   * also be a `file_id` previously uploaded\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendphoto\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  sendPhoto(chatId, photo, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('photo', photo, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.photo = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendPhoto', opts);\n  }\n\n  /**\n  * Send audio\n  *\n  * **Your audio must be in the .MP3 or .M4A format.**\n  *\n  * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {String|stream.Stream|Buffer} audio A file path, Stream or Buffer.\n  * Can also be a `file_id` previously uploaded.\n  * @param  {Object} [options] Additional Telegram query options\n  * @param  {Object} [fileOptions] Optional file related meta-data\n  * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n  * @see https://core.telegram.org/bots/api#sendaudio\n  * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n  */\n  sendAudio(chatId, audio, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n\n    opts.qs.chat_id = chatId;\n\n    try {\n      const sendData = this._formatSendData('audio', audio, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.audio = sendData[1];\n      this._fixAddFileThumbnail(options, opts);\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    return this._request('sendAudio', opts);\n  }\n\n  /**\n  * Send Document\n  * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {String|stream.Stream|Buffer} doc A file path, Stream or Buffer.\n  * Can also be a `file_id` previously uploaded.\n  * @param  {Object} [options] Additional Telegram query options\n  * @param  {Object} [fileOptions] Optional file related meta-data\n  * @return {Promise}  On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n  * @see https://core.telegram.org/bots/api#sendDocument\n  * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n  */\n  sendDocument(chatId, doc, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('document', doc, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.document = sendData[1];\n      this._fixAddFileThumbnail(options, opts);\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    return this._request('sendDocument', opts);\n  }\n\n  /**\n   * Use this method to send video files, **Telegram clients support mp4 videos** (other formats may be sent as Document).\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} video A file path or Stream.\n   * Can also be a `file_id` previously uploaded.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendvideo\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  sendVideo(chatId, video, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('video', video, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.video = sendData[1];\n      this._fixAddFileThumbnail(options, opts);\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendVideo', opts);\n  }\n\n  /**\n   * Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound).\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} animation A file path, Stream or Buffer.\n   * Can also be a `file_id` previously uploaded.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendanimation\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  sendAnimation(chatId, animation, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('animation', animation, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.animation = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendAnimation', opts);\n  }\n\n  /**\n   * Send voice\n   *\n   * **Your audio must be in an .OGG file encoded with OPUS**, or in .MP3 format, or in .M4A format (other formats may be sent as Audio or Document)\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} voice A file path, Stream or Buffer.\n   * Can also be a `file_id` previously uploaded.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendvoice\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  sendVoice(chatId, voice, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('voice', voice, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.voice = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendVoice', opts);\n  }\n\n  /**\n   * Use this method to send video messages\n   * Telegram clients support **rounded square MPEG4 videos** of up to 1 minute long.\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} videoNote A file path or Stream.\n   * Can also be a `file_id` previously uploaded.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @info The length parameter is actually optional. However, the API (at time of writing) requires you to always provide it until it is fixed.\n   * @see https://core.telegram.org/bots/api#sendvideonote\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n  */\n  sendVideoNote(chatId, videoNote, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('video_note', videoNote, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.video_note = sendData[1];\n      this._fixAddFileThumbnail(options, opts);\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendVideoNote', opts);\n  }\n\n  /**\n   * Use this method to send a group of photos or videos as an album.\n   *\n   * **Documents and audio files can be only grouped in an album with messages of the same type**\n   *\n   * If you wish to [specify file options](https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files),\n   * add a `fileOptions` property to the target input in `media`.\n   *\n   * @param  {String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Array} media A JSON-serialized array describing photos and videos to be sent, must include 2–10 items\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, an array of the sent [Messages](https://core.telegram.org/bots/api#message)\n   * is returned.\n   * @see https://core.telegram.org/bots/api#sendmediagroup\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  sendMediaGroup(chatId, media, options = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.chat_id = chatId;\n\n    opts.formData = {};\n    const inputMedia = [];\n    let index = 0;\n    for (const input of media) {\n      const payload = Object.assign({}, input);\n      delete payload.media;\n      delete payload.fileOptions;\n      try {\n        const attachName = String(index);\n        const [formData, fileId] = this._formatSendData(attachName, input.media, input.fileOptions);\n        if (formData) {\n          opts.formData[attachName] = formData[attachName];\n          payload.media = `attach://${attachName}`;\n        } else {\n          payload.media = fileId;\n        }\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      inputMedia.push(payload);\n      index++;\n    }\n    opts.qs.media = stringify(inputMedia);\n\n    return this._request('sendMediaGroup', opts);\n  }\n\n\n  /**\n   * Send location.\n   * Use this method to send point on the map.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Float} latitude Latitude of location\n   * @param  {Float} longitude Longitude of location\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendlocation\n   */\n  sendLocation(chatId, latitude, longitude, form = {}) {\n    form.chat_id = chatId;\n    form.latitude = latitude;\n    form.longitude = longitude;\n    return this._request('sendLocation', { form });\n  }\n\n  /**\n   * Use this method to edit live location messages sent by\n   * the bot or via the bot (for inline bots).\n   *\n   *  A location **can be edited until its live_period expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.telegram.org/bots/api#stopmessagelivelocation)**\n   *\n   * Note that you must provide one of chat_id, message_id, or\n   * inline_message_id in your request.\n   *\n   * @param  {Float} latitude Latitude of location\n   * @param  {Float} longitude Longitude of location\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned.\n   * @see https://core.telegram.org/bots/api#editmessagelivelocation\n   */\n  editMessageLiveLocation(latitude, longitude, form = {}) {\n    form.latitude = latitude;\n    form.longitude = longitude;\n    return this._request('editMessageLiveLocation', { form });\n  }\n\n  /**\n   * Use this method to stop updating a live location message sent by\n   * the bot or via the bot (for inline bots) before live_period expires.\n   *\n   * Note that you must provide one of chat_id, message_id, or\n   * inline_message_id in your request.\n   *\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned.\n   * @see https://core.telegram.org/bots/api#stopmessagelivelocation\n   */\n  stopMessageLiveLocation(form = {}) {\n    return this._request('stopMessageLiveLocation', { form });\n  }\n\n  /**\n   * Send venue.\n   * Use this method to send information about a venue.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Float} latitude Latitude of location\n   * @param  {Float} longitude Longitude of location\n   * @param  {String} title Name of the venue\n   * @param  {String} address Address of the venue\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned.\n   * @see https://core.telegram.org/bots/api#sendvenue\n   */\n  sendVenue(chatId, latitude, longitude, title, address, form = {}) {\n    form.chat_id = chatId;\n    form.latitude = latitude;\n    form.longitude = longitude;\n    form.title = title;\n    form.address = address;\n    return this._request('sendVenue', { form });\n  }\n\n  /**\n   * Send contact.\n   * Use this method to send phone contacts.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} phoneNumber Contact's phone number\n   * @param  {String} firstName Contact's first name\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendcontact\n   */\n  sendContact(chatId, phoneNumber, firstName, form = {}) {\n    form.chat_id = chatId;\n    form.phone_number = phoneNumber;\n    form.first_name = firstName;\n    return this._request('sendContact', { form });\n  }\n\n  /**\n   * Send poll.\n   * Use this method to send a native poll.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the group/channel\n   * @param  {String} question Poll question, 1-300 characters\n   * @param  {Array} pollOptions Poll options, between 2-10 options (only 1-100 characters each)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendpoll\n   */\n  sendPoll(chatId, question, pollOptions, form = {}) {\n    form.chat_id = chatId;\n    form.question = question;\n    form.options = stringify(pollOptions);\n    return this._request('sendPoll', { form });\n  }\n\n  /**\n   * Send Dice\n   * Use this method to send an animated emoji that will display a random value.\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}  On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#senddice\n   */\n  sendDice(chatId, options = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('dice');\n      opts.formData = sendData[0];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendDice', opts);\n  }\n\n\n  /**\n   * Send chat action.\n   *\n   * Use this method when you need to tell the user that something is happening on the bot's side.\n   * **The status is set for 5 seconds or less** (when a message arrives from your bot, Telegram clients clear its typing status).\n   *\n   *  Action `typing` for [text messages](https://core.telegram.org/bots/api#sendmessage),\n   * `upload_photo` for [photos](https://core.telegram.org/bots/api#sendphoto), `record_video` or `upload_video` for [videos](https://core.telegram.org/bots/api#sendvideo),\n   * `record_voice` or `upload_voice` for [voice notes](https://core.telegram.org/bots/api#sendvoice), `upload_document` for [general files](https://core.telegram.org/bots/api#senddocument),\n   * `choose_sticker` for [stickers](https://core.telegram.org/bots/api#sendsticker), `find_location` for [location data](https://core.telegram.org/bots/api#sendlocation),\n   * `record_video_note` or `upload_video_note` for [video notes](https://core.telegram.org/bots/api#sendvideonote).\n   *\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} action Type of action to broadcast.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#sendchataction\n   */\n  sendChatAction(chatId, action, form = {}) {\n    form.chat_id = chatId;\n    form.action = action;\n    return this._request('sendChatAction', { form });\n  }\n\n  /**\n   * Use this method to change the chosen reactions on a message.\n   * - Service messages can't be reacted to.\n   * - Automatically forwarded messages from a channel to its discussion group have the same available reactions as messages in the channel.\n   * - In albums, bots must react to the first message.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n   * @param  {Number} messageId  Unique identifier of the target message\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise<Boolean>} True on success\n   * @see https://core.telegram.org/bots/api#setmessagereaction\n   */\n  setMessageReaction(chatId, messageId, form = {}) {\n    form.chat_id = chatId;\n    form.message_id = messageId;\n    if (form.reaction) {\n      form.reaction = stringify(form.reaction);\n    }\n    return this._request('setMessageReaction', { form });\n  }\n\n  /**\n   * Use this method to get a list of profile pictures for a user.\n   * Returns a [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object.\n   * This method has an [older, compatible signature][getUserProfilePhotos-v0.25.0]\n   * that is being deprecated.\n   *\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}  Returns a [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object\n   * @see https://core.telegram.org/bots/api#getuserprofilephotos\n   */\n  getUserProfilePhotos(userId, form = {}) {\n    /* The older method signature was getUserProfilePhotos(userId, offset, limit).\n     * We need to ensure backwards-compatibility while maintaining\n     * consistency of the method signatures throughout the library */\n    if (typeof form !== 'object') {\n      /* eslint-disable no-param-reassign, prefer-rest-params */\n      deprecate('The method signature getUserProfilePhotos(userId, offset, limit) has been deprecated since v0.25.0');\n      form = {\n        offset: arguments[1],\n        limit: arguments[2],\n      };\n      /* eslint-enable no-param-reassign, prefer-rest-params */\n    }\n    form.user_id = userId;\n    return this._request('getUserProfilePhotos', { form });\n  }\n\n  /**\n   * Get file.\n   * Use this method to get basic info about a file and prepare it for downloading.\n   *\n   * Attention: **link will be valid for 1 hour.**\n   *\n   * @param  {String} fileId  File identifier to get info about\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, a [File](https://core.telegram.org/bots/api#file) object is returned\n   * @see https://core.telegram.org/bots/api#getfile\n   */\n  getFile(fileId, form = {}) {\n    form.file_id = fileId;\n    return this._request('getFile', { form });\n  }\n\n  /**\n    * Use this method to ban a user in a group, a supergroup or a channel.\n    * In the case of supergroups and channels, the user will not be able to\n    * return to the chat on their own using invite links, etc., unless unbanned first..\n    *\n    * The **bot must be an administrator in the group, supergroup or a channel** for this to work.\n    *\n    *\n    * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Number} userId  Unique identifier of the target user\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success.\n    * @see https://core.telegram.org/bots/api#banchatmember\n    */\n  banChatMember(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('banChatMember', { form });\n  }\n\n  /**\n  * Use this method to unban a previously kicked user in a supergroup.\n  * The user will not return to the group automatically, but will be\n  * able to join via link, etc.\n  *\n  * The **bot must be an administrator** in the supergroup or channel for this to work.\n  *\n  * **By default**, this method guarantees that after the call the user is not a member of the chat, but will be able to join it.\n  * So **if the user is a member of the chat they will also be removed from the chat**. If you don't want this, use the parameter *only_if_banned*\n  *\n  * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {Number} userId  Unique identifier of the target user\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#unbanchatmember\n  */\n  unbanChatMember(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('unbanChatMember', { form });\n  }\n\n  /**\n  * Use this method to restrict a user in a supergroup.\n  * The bot **must be an administrator in the supergroup** for this to work\n  * and must have the appropriate admin rights. Pass True for all boolean parameters\n  * to lift restrictions from a user. Returns True on success.\n  *\n  * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {Number} userId Unique identifier of the target user\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#restrictchatmember\n  */\n  restrictChatMember(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('restrictChatMember', { form });\n  }\n\n  /**\n   * Use this method to promote or demote a user in a supergroup or a channel.\n   * The bot **must be an administrator** in the chat for this to work\n   * and must have the appropriate admin rights. Pass False for all boolean parameters to demote a user.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} userId\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success.\n   * @see https://core.telegram.org/bots/api#promotechatmember\n   */\n  promoteChatMember(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('promoteChatMember', { form });\n  }\n\n  /**\n   * Use this method to set a custom title for an administrator in a supergroup promoted by the bot.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} userId Unique identifier of the target user\n   * @param  {String} customTitle New custom title for the administrator; 0-16 characters, emoji are not allowed\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatadministratorcustomtitle\n   */\n  setChatAdministratorCustomTitle(chatId, userId, customTitle, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    form.custom_title = customTitle;\n    return this._request('setChatAdministratorCustomTitle', { form });\n  }\n\n\n  /**\n   * Use this method to ban a channel chat in a supergroup or a channel.\n   *\n   * Until the chat is [unbanned](https://core.telegram.org/bots/api#unbanchatsenderchat), the owner of the banned chat won't be able to send messages on behalf of any of their channels.\n   * The bot **must be an administrator in the supergroup or channel** for this to work and must have the appropriate administrator rights\n   *\n   * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} senderChatId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success.\n   * @see https://core.telegram.org/bots/api#banchatsenderchat\n   */\n  banChatSenderChat(chatId, senderChatId, form = {}) {\n    form.chat_id = chatId;\n    form.sender_chat_id = senderChatId;\n    return this._request('banChatSenderChat', { form });\n  }\n\n  /**\n  * Use this method to unban a previously banned channel chat in a supergroup or channel.\n  *\n  * The bot **must be an administrator** for this to work and must have the appropriate administrator rights.\n  *\n  * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {Number} senderChatId Unique identifier of the target user\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#unbanchatsenderchat\n  */\n  unbanChatSenderChat(chatId, senderChatId, form = {}) {\n    form.chat_id = chatId;\n    form.sender_chat_id = senderChatId;\n    return this._request('unbanChatSenderChat', { form });\n  }\n\n  /**\n   * Use this method to set default chat permissions for all members.\n   *\n   * The bot **must be an administrator in the group or a supergroup** for this to\n   * work and **must have the `can_restrict_members` admin rights.**\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Array} chatPermissions New default chat permissions\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatpermissions\n   */\n  setChatPermissions(chatId, chatPermissions, form = {}) {\n    form.chat_id = chatId;\n    form.permissions = stringify(chatPermissions);\n    return this._request('setChatPermissions', { form });\n  }\n\n  /**\n   * Use this method to generate a new primary invite link for a chat. **Any previously generated primary link is revoked**.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate administrator rights.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Exported invite link as String on success.\n   * @see https://core.telegram.org/bots/api#exportchatinvitelink\n   */\n  exportChatInviteLink(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('exportChatInviteLink', { form });\n  }\n\n  /**\n   * Use this method to create an additional invite link for a chat.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * The link generated with this method can be revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api#revokechatinvitelink)\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Object} The new invite link as [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n   * @see https://core.telegram.org/bots/api#createchatinvitelink\n   */\n  createChatInviteLink(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('createChatInviteLink', { form });\n  }\n\n  /**\n   * Use this method to edit a non-primary invite link created by the bot.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} inviteLink Text with the invite link to edit\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} The edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n   * @see https://core.telegram.org/bots/api#editchatinvitelink\n   */\n  editChatInviteLink(chatId, inviteLink, form = {}) {\n    form.chat_id = chatId;\n    form.invite_link = inviteLink;\n    return this._request('editChatInviteLink', { form });\n  }\n\n  /**\n   * Use this method to revoke an invite link created by the bot.\n   * Note: If the primary link is revoked, a new link is automatically generated\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} inviteLink The invite link to revoke\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} The revoked invite link as [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n   * @see https://core.telegram.org/bots/api#revokechatinvitelink\n   */\n  revokeChatInviteLink(chatId, inviteLink, form = {}) {\n    form.chat_id = chatId;\n    form.invite_link = inviteLink;\n    return this._request('revokeChatInviteLink', { form });\n  }\n\n  /**\n   * Use this method to approve a chat join request.\n   *\n   * The bot **must be an administrator in the chat** for this to work and **must have the `can_invite_users` administrator right.**\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#approvechatjoinrequest\n   */\n  approveChatJoinRequest(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('approveChatJoinRequest', { form });\n  }\n\n  /**\n   * Use this method to decline a chat join request.\n   *\n   * The bot **must be an administrator in the chat** for this to work and **must have the `can_invite_users` administrator right**.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#declinechatjoinrequest\n   */\n  declineChatJoinRequest(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('declineChatJoinRequest', { form });\n  }\n\n  /**\n   * Use this method to set a new profile photo for the chat. **Photos can't be changed for private chats**.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {stream.Stream|Buffer} photo A file path or a Stream.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatphoto\n   */\n  setChatPhoto(chatId, photo, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('photo', photo, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.photo = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('setChatPhoto', opts);\n  }\n\n  /**\n  * Use this method to delete a chat photo. **Photos can't be changed for private chats**.\n  *\n  * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n  *\n  * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#deletechatphoto\n  */\n  deleteChatPhoto(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('deleteChatPhoto', { form });\n  }\n\n  /**\n   * Use this method to change the title of a chat. **Titles can't be changed for private chats**.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} title New chat title, 1-255 characters\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchattitle\n   */\n  setChatTitle(chatId, title, form = {}) {\n    form.chat_id = chatId;\n    form.title = title;\n    return this._request('setChatTitle', { form });\n  }\n\n  /**\n   * Use this method to change the description of a group, a supergroup or a channel.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} description New chat title, 0-255 characters\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatdescription\n   */\n  setChatDescription(chatId, description, form = {}) {\n    form.chat_id = chatId;\n    form.description = description;\n    return this._request('setChatDescription', { form });\n  }\n\n  /**\n   * Use this method to pin a message in a supergroup.\n   *\n   * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n   * right in a supergroup or `can_edit_messages` administrator right in a channel.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} messageId Identifier of a message to pin\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#pinchatmessage\n   */\n  pinChatMessage(chatId, messageId, form = {}) {\n    form.chat_id = chatId;\n    form.message_id = messageId;\n    return this._request('pinChatMessage', { form });\n  }\n\n  /**\n   * Use this method to remove a message from the list of pinned messages in a chat\n   *\n   * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n   * right in a supergroup or `can_edit_messages` administrator right in a channel.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#unpinchatmessage\n   */\n  unpinChatMessage(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('unpinChatMessage', { form });\n  }\n\n  /**\n  * Use this method to clear the list of pinned messages in a chat.\n  *\n  * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n  * right in a supergroup or `can_edit_messages` administrator right in a channel.\n  *\n  * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#unpinallchatmessages\n  */\n  unpinAllChatMessages(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('unpinAllChatMessages', { form });\n  }\n\n  /**\n   * Use this method for your bot to leave a group, supergroup or channel\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#leavechat\n   */\n  leaveChat(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('leaveChat', { form });\n  }\n\n  /**\n   * Use this method to get up to date information about the chat\n   * (current name of the user for one-on-one conversations, current\n   * username of a user, group or channel, etc.).\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`) or channel\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} [ChatFullInfo](https://core.telegram.org/bots/api#chatfullinfo) object on success\n   * @see https://core.telegram.org/bots/api#getchat\n   */\n  getChat(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('getChat', { form });\n  }\n\n  /**\n   * Use this method to get a list of administrators in a chat\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, returns an Array of [ChatMember](https://core.telegram.org/bots/api#chatmember) objects that contains information about all chat administrators except other bots.\n   * If the chat is a group or a supergroup and no administrators were appointed, only the creator will be returned\n   * @see https://core.telegram.org/bots/api#getchatadministrators\n   */\n  getChatAdministrators(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('getChatAdministrators', { form });\n  }\n\n  /**\n  * Use this method to get the number of members in a chat.\n  *\n  * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} Int on success\n  * @see https://core.telegram.org/bots/api#getchatmembercount\n  */\n  getChatMemberCount(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('getChatMemberCount', { form });\n  }\n\n  /**\n   * Use this method to get information about a member of a chat.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} [ChatMember](https://core.telegram.org/bots/api#chatmember) object on success\n   * @see https://core.telegram.org/bots/api#getchatmember\n   */\n  getChatMember(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('getChatMember', { form });\n  }\n\n  /**\n   * Use this method to set a new group sticker set for a supergroup.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate administrator rights.\n   *\n   * **Note:** Use the field `can_set_sticker_set` optionally returned in [getChat](https://core.telegram.org/bots/api#getchat) requests to check if the bot can use this method.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param  {String} stickerSetName Name of the sticker set to be set as the group sticker set\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatstickerset\n   */\n  setChatStickerSet(chatId, stickerSetName, form = {}) {\n    form.chat_id = chatId;\n    form.sticker_set_name = stickerSetName;\n    return this._request('setChatStickerSet', { form });\n  }\n\n\n  /**\n   * Use this method to delete a group sticker set from a supergroup.\n   *\n   * Use the field `can_set_sticker_set` optionally returned in [getChat](https://core.telegram.org/bots/api#getchat) requests to check if the bot can use this method.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#deletechatstickerset\n   */\n  deleteChatStickerSet(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('deleteChatStickerSet', { form });\n  }\n\n  /**\n   * Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Array of [Sticker](https://core.telegram.org/bots/api#sticker) objects\n   * @see https://core.telegram.org/bots/api#getforumtopiciconstickers\n   */\n  getForumTopicIconStickers(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('getForumTopicIconStickers', { form });\n  }\n\n  /**\n   * Use this method to create a topic in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n   *\n   * Returns information about the created topic as a [ForumTopic](https://core.telegram.org/bots/api#forumtopic) object.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param  {String} name Topic name, 1-128 characters\n   * @param  {Object} [options] Additional Telegram query options\n   * @see https://core.telegram.org/bots/api#createforumtopic\n   */\n  createForumTopic(chatId, name, form = {}) {\n    form.chat_id = chatId;\n    form.name = name;\n    return this._request('createForumTopic', { form });\n  }\n\n  /**\n   * Use this method to edit name and icon of a topic in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have can_manage_topics administrator rights, unless it is the creator of the topic.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#editforumtopic\n   */\n  editForumTopic(chatId, messageThreadId, form = {}) {\n    form.chat_id = chatId;\n    form.message_thread_id = messageThreadId;\n    return this._request('editForumTopic', { form });\n  }\n\n  /**\n   * Use this method to close an open topic in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#closeforumtopic\n   */\n  closeForumTopic(chatId, messageThreadId, form = {}) {\n    form.chat_id = chatId;\n    form.message_thread_id = messageThreadId;\n    return this._request('closeForumTopic', { form });\n  }\n\n  /**\n   * Use this method to reopen a closed topic in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#reopenforumtopic\n   */\n  reopenForumTopic(chatId, messageThreadId, form = {}) {\n    form.chat_id = chatId;\n    form.message_thread_id = messageThreadId;\n    return this._request('reopenForumTopic', { form });\n  }\n\n  /**\n   * Use this method to delete a forum topic along with all its messages in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have the can_delete_messages administrator rights.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#deleteforumtopic\n   */\n  deleteForumTopic(chatId, messageThreadId, form = {}) {\n    form.chat_id = chatId;\n    form.message_thread_id = messageThreadId;\n    return this._request('deleteForumTopic', { form });\n  }\n\n  /**\n   * Use this method to clear the list of pinned messages in a forum topic.\n   * The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#unpinallforumtopicmessages\n   */\n  unpinAllForumTopicMessages(chatId, messageThreadId, form = {}) {\n    form.chat_id = chatId;\n    form.message_thread_id = messageThreadId;\n    return this._request('unpinAllForumTopicMessages', { form });\n  }\n\n  /**\n  * Use this method to edit the name of the 'General' topic in a forum supergroup chat.\n  * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n  * The topic will be automatically unhidden if it was hidden.\n  *\n  * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n  * @param {String} name New topic name, 1-128 characters\n  * @param {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#editgeneralforumtopic\n  */\n  editGeneralForumTopic(chatId, name, form = {}) {\n    form.chat_id = chatId;\n    form.name = name;\n    return this._request('editGeneralForumTopic', { form });\n  }\n\n  /**\n  * Use this method to close an open 'General' topic in a forum supergroup chat.\n  * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n  * The topic will be automatically unhidden if it was hidden.\n  *\n  * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n  * @param {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#closegeneralforumtopic\n  */\n  closeGeneralForumTopic(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('closeGeneralForumTopic', { form });\n  }\n\n  /**\n  * Use this method to reopen a closed 'General' topic in a forum supergroup chat.\n  * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n  * The topic will be automatically unhidden if it was hidden.\n  *\n  * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n  * @param {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#reopengeneralforumtopic\n  */\n  reopenGeneralForumTopic(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('reopenGeneralForumTopic', { form });\n  }\n\n  /**\n  * Use this method to hide the 'General' topic in a forum supergroup chat.\n  * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n  * The topic will be automatically closed if it was open.\n  *\n  * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n  * @param {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#hidegeneralforumtopic\n  */\n  hideGeneralForumTopic(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('hideGeneralForumTopic', { form });\n  }\n\n  /**\n   * Use this method to unhide the 'General' topic in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#unhidegeneralforumtopic\n   */\n  unhideGeneralForumTopic(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('unhideGeneralForumTopic', { form });\n  }\n\n  /**\n   * Use this method to clear the list of pinned messages in a General forum topic.\n   * The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#unpinallgeneralforumtopicmessages\n   */\n  unpinAllGeneralForumTopicMessages(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('unhideGeneralForumTopic', { form });\n  }\n\n  /**\n   * Use this method to send answers to callback queries sent from\n   * [inline keyboards](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating).\n   *\n   * The answer will be displayed to the user as a notification at the top of the chat screen or as an alert.\n   *\n   * This method has **older, compatible signatures ([1][answerCallbackQuery-v0.27.1])([2][answerCallbackQuery-v0.29.0])**\n   * that are being deprecated.\n   *\n   * @param  {String} callbackQueryId Unique identifier for the query to be answered\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#answercallbackquery\n   */\n  answerCallbackQuery(callbackQueryId, form = {}) {\n    /* The older method signature (in/before v0.27.1) was answerCallbackQuery(callbackQueryId, text, showAlert).\n     * We need to ensure backwards-compatibility while maintaining\n     * consistency of the method signatures throughout the library */\n    if (typeof form !== 'object') {\n      /* eslint-disable no-param-reassign, prefer-rest-params */\n      deprecate('The method signature answerCallbackQuery(callbackQueryId, text, showAlert) has been deprecated since v0.27.1');\n      form = {\n        callback_query_id: arguments[0],\n        text: arguments[1],\n        show_alert: arguments[2],\n      };\n      /* eslint-enable no-param-reassign, prefer-rest-params */\n    }\n    /* The older method signature (in/before v0.29.0) was answerCallbackQuery([options]).\n     * We need to ensure backwards-compatibility while maintaining\n     * consistency of the method signatures throughout the library. */\n    if (typeof callbackQueryId === 'object') {\n      /* eslint-disable no-param-reassign, prefer-rest-params */\n      deprecate('The method signature answerCallbackQuery([options]) has been deprecated since v0.29.0');\n      form = callbackQueryId;\n      /* eslint-enable no-param-reassign, prefer-rest-params */\n    } else {\n      form.callback_query_id = callbackQueryId;\n    }\n    return this._request('answerCallbackQuery', { form });\n  }\n\n  /**\n   * Use this method to get the list of boosts added to a chat by a use.\n   * Requires administrator rights in the chat\n   *\n   * @param  {Number|String} chatId  Unique identifier for the group/channel\n   * @param  {Number} user_id Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, returns a [UserChatBoosts](https://core.telegram.org/bots/api#userchatboosts) object\n   * @see https://core.telegram.org/bots/api#getuserchatboosts\n   */\n  getUserChatBoosts(chatId, pollId, form = {}) {\n    form.chat_id = chatId;\n    form.message_id = pollId;\n    return this._request('getUserChatBoosts', { form });\n  }\n\n  /**\n   * Use this method to get information about the connection of the bot with a business account\n   *\n   * @param  {Number|String} businessConnectionId  Unique identifier for the group/channel\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, returns [BusinessConnection](https://core.telegram.org/bots/api#businessconnection) object\n   * @see https://core.telegram.org/bots/api#getbusinessconnection\n   */\n  getBusinessConnection(businessConnectionId, form = {}) {\n    form.business_connection_id = businessConnectionId;\n    return this._request('getBusinessConnection', { form });\n  }\n\n  /**\n   * Use this method to change the list of the bot's commands.\n   *\n   * See https://core.telegram.org/bots#commands for more details about bot commands\n   *\n   * @param  {Array} commands  List of bot commands to be set as the list of the [bot's commands](https://core.telegram.org/bots/api#botcommand). At most 100 commands can be specified.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setmycommands\n   */\n  setMyCommands(commands, form = {}) {\n    form.commands = stringify(commands);\n\n    if (form.scope) {\n      form.scope = stringify(form.scope);\n    }\n\n    return this._request('setMyCommands', { form });\n  }\n\n  /**\n   * Use this method to delete the list of the bot's commands for the given scope and user language.\n   *\n   *  After deletion, [higher level commands](https://core.telegram.org/bots/api#determining-list-of-commands) will be shown to affected users.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#deletemycommands\n   */\n  deleteMyCommands(form = {}) {\n    return this._request('deleteMyCommands', { form });\n  }\n\n\n  /**\n   * Use this method to get the current list of the bot's commands for the given scope and user language.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Array of [BotCommand](https://core.telegram.org/bots/api#botcommand) on success. If commands aren't set, an empty list is returned.\n   * @see https://core.telegram.org/bots/api#getmycommands\n   */\n  getMyCommands(form = {}) {\n    if (form.scope) {\n      form.scope = stringify(form.scope);\n    }\n    return this._request('getMyCommands', { form });\n  }\n\n  /**\n   * Use this method to change the bot's name.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setmyname\n   */\n  setMyName(form = {}) {\n    return this._request('setMyName', { form });\n  }\n\n  /**\n   * Use this method to get the current bot name for the given user language.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} [BotName](https://core.telegram.org/bots/api#botname) on success\n   * @see https://core.telegram.org/bots/api#getmyname\n   */\n  getMyName(form = {}) {\n    return this._request('getMyName', { form });\n  }\n\n  /**\n   * Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty.\n   *\n   * Returns True on success.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setmydescription\n   */\n  setMyDescription(form = {}) {\n    return this._request('setMyDescription', { form });\n  }\n\n  /**\n   * Use this method to get the current bot description for the given user language.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Returns [BotDescription](https://core.telegram.org/bots/api#botdescription) on success.\n   * @see https://core.telegram.org/bots/api#getmydescription\n   */\n  getMyDescription(form = {}) {\n    return this._request('getMyDescription', { form });\n  }\n\n  /**\n   * Use this method to change the bot's short description, which is shown on the bot's profile page\n   * and is sent together with the link when users share the bot.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Returns True on success.\n   * @see https://core.telegram.org/bots/api#setmyshortdescription\n   */\n  setMyShortDescription(form = {}) {\n    return this._request('setMyShortDescription', { form });\n  }\n\n  /**\n   * Use this method to get the current bot short description for the given user language.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Returns [BotShortDescription](https://core.telegram.org/bots/api#botshortdescription) on success.\n   * @see https://core.telegram.org/bots/api#getmyshortdescription\n   */\n  getMyShortDescription(form = {}) {\n    return this._request('getMyShortDescription', { form });\n  }\n\n  /**\n   * Use this method to change the bot's menu button in a private chat, or the default menu button.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatmenubutton\n   */\n  setChatMenuButton(form = {}) {\n    return this._request('setChatMenuButton', { form });\n  }\n\n  /**\n   * Use this method to get the current value of the bot's menu button in a private chat, or the default menu button.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} [MenuButton](https://core.telegram.org/bots/api#menubutton) on success\n   * @see https://core.telegram.org/bots/api#getchatmenubutton\n   */\n  getChatMenuButton(form = {}) {\n    return this._request('getChatMenuButton', { form });\n  }\n\n  /**\n   * Use this method to change the default administrator rights requested by the bot when it's added as an administrator to groups or channels.\n   *\n   * These rights will be suggested to users, but they are are free to modify the list before adding the bot.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#getchatmenubutton\n   */\n  setMyDefaultAdministratorRights(form = {}) {\n    return this._request('setMyDefaultAdministratorRights', { form });\n  }\n\n  /**\n   * Use this method to get the current default administrator rights of the bot.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} [ChatAdministratorRights](https://core.telegram.org/bots/api#chatadministratorrights) on success\n   * @see https://core.telegram.org/bots/api#getmydefaultadministratorrights\n   */\n  getMyDefaultAdministratorRights(form = {}) {\n    return this._request('getMyDefaultAdministratorRights', { form });\n  }\n\n  /**\n   * Use this method to edit text or [game](https://core.telegram.org/bots/api#games) messages sent by the bot or via the bot (for inline bots).\n   *\n   * Note: that **you must provide one of chat_id, message_id, or inline_message_id** in your request.\n   *\n   * @param  {String} text  New text of the message\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n   * @see https://core.telegram.org/bots/api#editmessagetext\n   */\n  editMessageText(text, form = {}) {\n    form.text = text;\n    return this._request('editMessageText', { form });\n  }\n\n  /**\n   * Use this method to edit captions of messages sent by the bot or via the bot (for inline bots).\n   *\n   * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n   *\n   * @param  {String} caption  New caption of the message\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n   * @see https://core.telegram.org/bots/api#editmessagecaption\n   */\n  editMessageCaption(caption, form = {}) {\n    form.caption = caption;\n    return this._request('editMessageCaption', { form });\n  }\n\n  /**\n   * Use this method to edit animation, audio, document, photo, or video messages.\n   *\n   * If a message is a part of a message album, then it can be edited only to a photo or a video.\n   *\n   * Otherwise, message type can be changed arbitrarily. When inline message is edited, new file can't be uploaded.\n   * Use previously uploaded file via its file_id or specify a URL.\n   *\n   * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n   *\n   * @param  {Object} media  A JSON-serialized object for a new media content of the message\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n   * @see https://core.telegram.org/bots/api#editmessagemedia\n   */\n  editMessageMedia(media, form = {}) {\n    const regexAttach = /attach:\\/\\/.+/;\n\n    if (typeof media.media === 'string' && regexAttach.test(media.media)) {\n      const opts = {\n        qs: form,\n      };\n\n      opts.formData = {};\n\n      const payload = Object.assign({}, media);\n      delete payload.media;\n\n      try {\n        const attachName = String(0);\n        const [formData] = this._formatSendData(\n          attachName,\n          media.media.replace('attach://', ''),\n          media.fileOptions\n        );\n\n        if (formData) {\n          opts.formData[attachName] = formData[attachName];\n          payload.media = `attach://${attachName}`;\n        } else {\n          throw new errors.FatalError(`Failed to process the replacement action for your ${media.type}`);\n        }\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n\n      opts.qs.media = stringify(payload);\n\n      return this._request('editMessageMedia', opts);\n    }\n\n    form.media = stringify(media);\n\n    return this._request('editMessageMedia', { form });\n  }\n\n  /**\n   * Use this method to edit only the reply markup of messages sent by the bot or via the bot (for inline bots).\n   *\n   * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n   *\n   * @param  {Object} replyMarkup  A JSON-serialized object for an inline keyboard.\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n   * @see https://core.telegram.org/bots/api#editmessagetext\n   */\n  editMessageReplyMarkup(replyMarkup, form = {}) {\n    form.reply_markup = replyMarkup;\n    return this._request('editMessageReplyMarkup', { form });\n  }\n\n\n  /**\n   * Use this method to stop a poll which was sent by the bot.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the group/channel\n   * @param  {Number} pollId Identifier of the original message with the poll\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the stopped [Poll](https://core.telegram.org/bots/api#poll) is returned\n   * @see https://core.telegram.org/bots/api#stoppoll\n   */\n  stopPoll(chatId, pollId, form = {}) {\n    form.chat_id = chatId;\n    form.message_id = pollId;\n    return this._request('stopPoll', { form });\n  }\n\n  /**\n   * Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS,\n   * or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers.\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} sticker A file path, Stream or Buffer.\n   * Can also be a `file_id` previously uploaded. Stickers are WebP format files.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n   * @see https://core.telegram.org/bots/api#sendsticker\n   */\n  sendSticker(chatId, sticker, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('sticker', sticker, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.sticker = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendSticker', opts);\n  }\n\n  /**\n   * Use this method to get a sticker set.\n   *\n   * @param  {String} name Name of the sticker set\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, a [StickerSet](https://core.telegram.org/bots/api#stickerset) object is returned\n   * @see https://core.telegram.org/bots/api#getstickerset\n   */\n  getStickerSet(name, form = {}) {\n    form.name = name;\n    return this._request('getStickerSet', { form });\n  }\n\n  /**\n   * Use this method to get information about custom emoji stickers by their identifiers.\n   *\n   * @param  {Array} custom_emoji_ids List of custom emoji identifiers. At most 200 custom emoji identifiers can be specified.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Array of [Sticker](https://core.telegram.org/bots/api#sticker) objects.\n   * @see https://core.telegram.org/bots/api#getcustomemojistickers\n   */\n  getCustomEmojiStickers(customEmojiIds, form = {}) {\n    form.custom_emoji_ids = stringify(customEmojiIds);\n    return this._request('getCustomEmojiStickers', { form });\n  }\n\n  /**\n   * Use this method to upload a file with a sticker for later use in *createNewStickerSet* and *addStickerToSet* methods (can be used multiple\n   * times).\n   *\n   * @param  {Number} userId User identifier of sticker file owner\n   * @param  {String|stream.Stream|Buffer} sticker A file path or a Stream with the sticker in .WEBP, .PNG, .TGS, or .WEBM format. Can also be a `file_id` previously uploaded.\n   * @param {String} stickerFormat Allow values:  `static`, `animated` or `video`\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, a [File](https://core.telegram.org/bots/api#file) object is returned\n   * @see https://core.telegram.org/bots/api#uploadstickerfile\n   */\n  uploadStickerFile(userId, sticker, stickerFormat = 'static', options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.user_id = userId;\n    opts.qs.sticker_format = stickerFormat;\n\n    try {\n      const sendData = this._formatSendData('sticker', sticker, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.sticker = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('uploadStickerFile', opts);\n  }\n\n  /**\n   * Use this method to create new sticker set owned by a user.\n   *\n   * The bot will be able to edit the created sticker set.\n   *\n   * You must use exactly one of the fields *png_sticker*, *tgs_sticker*, or *webm_sticker*\n   *\n   * @param  {Number} userId User identifier of created sticker set owner\n   * @param  {String} name Short name of sticker set, to be used in `t.me/addstickers/` URLs (e.g.,   *\"animals\"*). Can contain only english letters, digits and underscores.\n   *  Must begin with a letter, can't contain consecutive underscores and must end in `\"_by_<bot_username>\"`. `<bot_username>` is case insensitive. 1-64 characters.\n   * @param  {String} title Sticker set title, 1-64 characters\n   * @param  {String|stream.Stream|Buffer} pngSticker Png image with the sticker, must be up to 512 kilobytes in size,\n   *  dimensions must not exceed 512px, and either width or height must be exactly 512px.\n   * @param  {String} emojis One or more emoji corresponding to the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise}  True on success\n   * @see https://core.telegram.org/bots/api#createnewstickerset\n   */\n  createNewStickerSet(userId, name, title, pngSticker, emojis, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.user_id = userId;\n    opts.qs.name = name;\n    opts.qs.title = title;\n    opts.qs.emojis = emojis;\n    opts.qs.mask_position = stringify(options.mask_position);\n    try {\n      const sendData = this._formatSendData('png_sticker', pngSticker, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.png_sticker = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('createNewStickerSet', opts);\n  }\n\n  /**\n   * Use this method to add a new sticker to a set created by the bot.\n   *\n   * You must use exactly one of the fields *png_sticker*, *tgs_sticker*, or *webm_sticker*\n   *\n   * Animated stickers can be added to animated sticker sets and only to them\n   *\n   * Note:\n   * - Emoji sticker sets can have up to 200 sticker\n   * - Static or Animated sticker sets can have up to 120 stickers\n   *\n   * @param  {Number} userId User identifier of sticker set owner\n   * @param  {String} name Sticker set name\n   * @param  {String|stream.Stream|Buffer} sticker Png image with the sticker (must be up to 512 kilobytes in size,\n   * dimensions must not exceed 512px, and either width or height must be exactly 512px, [TGS animation](https://core.telegram.org/stickers#animated-sticker-requirements)\n   * with the sticker or [WEBM video](https://core.telegram.org/stickers#video-sticker-requirements) with the sticker.\n   * @param  {String} emojis One or more emoji corresponding to the sticker\n   * @param  {String} stickerType Allow values: `png_sticker`, `tgs_sticker`, or `webm_sticker`.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise}  True on success\n   * @see https://core.telegram.org/bots/api#addstickertoset\n   */\n  addStickerToSet(userId, name, sticker, emojis, stickerType = 'png_sticker', options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.user_id = userId;\n    opts.qs.name = name;\n    opts.qs.emojis = emojis;\n    opts.qs.mask_position = stringify(options.mask_position);\n\n    if (typeof stickerType !== 'string' || ['png_sticker', 'tgs_sticker', 'webm_sticker'].indexOf(stickerType) === -1) {\n      return Promise.reject(new Error('stickerType must be a string and the allow types is: png_sticker, tgs_sticker, webm_sticker'));\n    }\n\n    try {\n      const sendData = this._formatSendData(stickerType, sticker, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs[stickerType] = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('addStickerToSet', opts);\n  }\n\n  /**\n   * Use this method to move a sticker in a set created by the bot to a specific position.\n   *\n   * @param  {String} sticker File identifier of the sticker\n   * @param  {Number} position New sticker position in the set, zero-based\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickerpositioninset\n   */\n  setStickerPositionInSet(sticker, position, form = {}) {\n    form.sticker = sticker;\n    form.position = position;\n    return this._request('setStickerPositionInSet', { form });\n  }\n\n  /**\n   * Use this method to delete a sticker from a set created by the bot.\n   *\n   * @param  {String} sticker File identifier of the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#deletestickerfromset\n   * @todo Add tests for this method!\n   */\n  deleteStickerFromSet(sticker, form = {}) {\n    form.sticker = sticker;\n    return this._request('deleteStickerFromSet', { form });\n  }\n\n  /**\n   * Use this method to replace an existing sticker in a sticker set with a new one\n   *\n   * @param  {Number} user_id User identifier of the sticker set owner\n   * @param  {String} name Sticker set name\n   * @param  {String} sticker File identifier of the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#replacestickerinset\n   * @todo Add tests for this method!\n   */\n  replaceStickerInSet(userId, name, oldSticker, form = {}) {\n    form.user_id = userId;\n    form.name = name;\n    form.old_sticker = oldSticker;\n    return this._request('deleteStickerFromSet', { form });\n  }\n\n\n  /**\n   * Use this method to change the list of emoji assigned to a regular or custom emoji sticker.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} sticker File identifier of the sticker\n   * @param { Array } emojiList A JSON-serialized list of 1-20 emoji associated with the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickeremojilist\n   */\n  setStickerEmojiList(sticker, emojiList, form = {}) {\n    form.sticker = sticker;\n    form.emoji_list = stringify(emojiList);\n    return this._request('setStickerEmojiList', { form });\n  }\n\n  /**\n   * Use this method to change the list of emoji assigned to a `regular` or `custom emoji` sticker.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} sticker File identifier of the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickerkeywords\n   */\n  setStickerKeywords(sticker, form = {}) {\n    form.sticker = sticker;\n    if (form.keywords) {\n      form.keywords = stringify(form.keywords);\n    }\n    return this._request('setStickerKeywords', { form });\n  }\n\n  /**\n   * Use this method to change the [mask position](https://core.telegram.org/bots/api#maskposition) of a mask sticker.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} sticker File identifier of the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickermaskposition\n   */\n  setStickerMaskPosition(sticker, form = {}) {\n    form.sticker = sticker;\n    if (form.mask_position) {\n      form.mask_position = stringify(form.mask_position);\n    }\n    return this._request('setStickerMaskPosition', { form });\n  }\n\n  /**\n   * Use this method to set the title of a created sticker set.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} name Sticker set name\n   * @param  {String} title Sticker set title, 1-64 characters\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickersettitle\n   */\n  setStickerSetTitle(name, title, form = {}) {\n    form.name = name;\n    form.title = title;\n    return this._request('setStickerSetTitle', { form });\n  }\n\n  /**\n   * Use this method to add a thumb to a set created by the bot.\n   *\n   * Animated thumbnails can be set for animated sticker sets only. Video thumbnails can be set only for video sticker sets only\n   *\n   * @param  {Number} userId User identifier of sticker set owner\n   * @param  {String} name Sticker set name\n   * @param  {String|stream.Stream|Buffer} thumbnail A .WEBP or .PNG image with the thumbnail,\n   * must be up to 128 kilobytes in size and have width and height exactly 100px,\n   * a TGS animation with the thumbnail up to 32 kilobytes in size or a WEBM video with the thumbnail up to 32 kilobytes in size.\n   *\n   * Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram\n   * to get a file from the Internet, or upload a new one. Animated sticker set thumbnails can't be uploaded via HTTP URL.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickersetthumbnail\n   */\n  setStickerSetThumbnail(userId, name, thumbnail, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.user_id = userId;\n    opts.qs.name = name;\n    opts.qs.mask_position = stringify(options.mask_position);\n    try {\n      const sendData = this._formatSendData('thumbnail', thumbnail, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.thumbnail = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('setStickerSetThumbnail', opts);\n  }\n\n\n  /**\n   * Use this method to set the thumbnail of a custom emoji sticker set.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} name Sticker set name\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setcustomemojistickersetthumbnail\n   */\n  setCustomEmojiStickerSetThumbnail(name, form = {}) {\n    form.name = name;\n    return this._request('setCustomEmojiStickerSetThumbnail', { form });\n  }\n\n  /**\n   * Use this method to delete a sticker set that was created by the bot.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} name Sticker set name\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#deletestickerset\n   */\n  deleteStickerSet(name, form = {}) {\n    form.name = name;\n    return this._request('deleteStickerSet', { form });\n  }\n\n  /**\n   * Send answers to an inline query.\n   *\n   * Note: No more than 50 results per query are allowed.\n   *\n   * @param  {String} inlineQueryId Unique identifier of the query\n   * @param  {InlineQueryResult[]} results An array of results for the inline query\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, True is returned\n   * @see https://core.telegram.org/bots/api#answerinlinequery\n   */\n  answerInlineQuery(inlineQueryId, results, form = {}) {\n    form.inline_query_id = inlineQueryId;\n    form.results = stringify(results);\n    return this._request('answerInlineQuery', { form });\n  }\n\n  /**\n   * Use this method to set the result of an interaction with a [Web App](https://core.telegram.org/bots/webapps)\n   * and send a corresponding message on behalf of the user to the chat from which the query originated.\n   *\n   * @param  {String} webAppQueryId Unique identifier for the query to be answered\n   * @param  {InlineQueryResult} result object that represents one result of an inline query\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, a [SentWebAppMessage](https://core.telegram.org/bots/api#sentwebappmessage) object is returned\n   * @see https://core.telegram.org/bots/api#answerwebappquery\n   */\n  answerWebAppQuery(webAppQueryId, result, form = {}) {\n    form.web_app_query_id = webAppQueryId;\n    form.result = stringify(result);\n    return this._request('answerWebAppQuery', { form });\n  }\n\n  /**\n   * Use this method to send an invoice.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} title Product name, 1-32 characters\n   * @param  {String} description Product description, 1-255 characters\n   * @param  {String} payload Bot defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.\n   * @param  {String} providerToken Payments provider token, obtained via `@BotFather`\n   * @param  {String} currency Three-letter ISO 4217 currency code\n   * @param  {Array} prices Breakdown of prices\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n   * @see https://core.telegram.org/bots/api#sendinvoice\n   */\n  sendInvoice(chatId, title, description, payload, providerToken, currency, prices, form = {}) {\n    form.chat_id = chatId;\n    form.title = title;\n    form.description = description;\n    form.payload = payload;\n    form.provider_token = providerToken;\n    form.currency = currency;\n    form.prices = stringify(prices);\n    form.provider_data = stringify(form.provider_data);\n    if (form.suggested_tip_amounts) {\n      form.suggested_tip_amounts = stringify(form.suggested_tip_amounts);\n    }\n    return this._request('sendInvoice', { form });\n  }\n\n  /**\n  * Use this method to create a link for an invoice.\n  *\n  * @param {String} title Product name, 1-32 characters\n  * @param {String} description Product description, 1-255 characters\n  * @param {String} payload Bot defined invoice payload\n  * @param {String} providerToken Payment provider token\n  * @param {String} currency Three-letter ISO 4217 currency code\n  * @param {Array} prices Breakdown of prices\n  * @param {Object} [options] Additional Telegram query options\n  * @returns {Promise} The created invoice link as String on success.\n  * @see https://core.telegram.org/bots/api#createinvoicelink\n  */\n  createInvoiceLink(title, description, payload, providerToken, currency, prices, form = {}) {\n    form.title = title;\n    form.description = description;\n    form.payload = payload;\n    form.provider_token = providerToken;\n    form.currency = currency;\n    form.prices = stringify(prices);\n    return this._request('createInvoiceLink', { form });\n  }\n\n  /**\n  * Use this method to reply to shipping queries.\n  *\n  * If you sent an invoice requesting a shipping address and the parameter is_flexible was specified,\n  * the Bot API will send an [Update](https://core.telegram.org/bots/api#update) with a shipping_query field to the bot\n  *\n  * @param  {String} shippingQueryId  Unique identifier for the query to be answered\n  * @param  {Boolean} ok Specify if delivery of the product is possible\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} On success, True is returned\n  * @see https://core.telegram.org/bots/api#answershippingquery\n  */\n  answerShippingQuery(shippingQueryId, ok, form = {}) {\n    form.shipping_query_id = shippingQueryId;\n    form.ok = ok;\n    form.shipping_options = stringify(form.shipping_options);\n    return this._request('answerShippingQuery', { form });\n  }\n\n  /**\n   * Use this method to respond to such pre-checkout queries\n   *\n   * Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of\n   * an [Update](https://core.telegram.org/bots/api#update) with the field *pre_checkout_query*.\n   *\n   * **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.\n   *\n   * @param  {String} preCheckoutQueryId  Unique identifier for the query to be answered\n   * @param  {Boolean} ok Specify if every order details are ok\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, True is returned\n   * @see https://core.telegram.org/bots/api#answerprecheckoutquery\n   */\n  answerPreCheckoutQuery(preCheckoutQueryId, ok, form = {}) {\n    form.pre_checkout_query_id = preCheckoutQueryId;\n    form.ok = ok;\n    return this._request('answerPreCheckoutQuery', { form });\n  }\n\n  /**\n   * Use this method to send a game.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} gameShortName name of the game to be sent. Set up your games via `@BotFather`.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n   * @see https://core.telegram.org/bots/api#sendgame\n   */\n  sendGame(chatId, gameShortName, form = {}) {\n    form.chat_id = chatId;\n    form.game_short_name = gameShortName;\n    return this._request('sendGame', { form });\n  }\n\n  /**\n   * Use this method to set the score of the specified user in a game message.\n   *\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Number} score New score value, must be non-negative\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, if the message is not an inline message, the [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n   * @see https://core.telegram.org/bots/api#setgamescore\n   */\n  setGameScore(userId, score, form = {}) {\n    form.user_id = userId;\n    form.score = score;\n    return this._request('setGameScore', { form });\n  }\n\n  /**\n   * Use this method to get data for high score tables.\n   *\n   * Will return the score of the specified user and several of their neighbors in a game.\n   *\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, returns an Array of [GameHighScore](https://core.telegram.org/bots/api#gamehighscore) objects\n   * @see https://core.telegram.org/bots/api#getgamehighscores\n   */\n  getGameHighScores(userId, form = {}) {\n    form.user_id = userId;\n    return this._request('getGameHighScores', { form });\n  }\n\n\n  /**\n * Use this method to delete a message, including service messages, with the following limitations:\n * - A message can only be deleted if it was sent less than 48 hours ago.\n * - A dice message can only be deleted if it was sent more than 24 hours ago.\n * - Bots can delete outgoing messages in groups and supergroups.\n * - Bots can delete incoming messages in groups, supergroups and channels.\n * - Bots granted `can_post_messages` permissions can delete outgoing messages in channels.\n * - If the bot is an administrator of a group, it can delete any message there.\n * - If the bot has `can_delete_messages` permission in a supergroup, it can delete any message there.\n *\n * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n * @param  {Number} messageId  Unique identifier of the target message\n * @param  {Object} [options] Additional Telegram query options\n * @return {Promise} True on success\n * @see https://core.telegram.org/bots/api#deletemessage\n */\n  deleteMessage(chatId, messageId, form = {}) {\n    form.chat_id = chatId;\n    form.message_id = messageId;\n    return this._request('deleteMessage', { form });\n  }\n\n  /**\n   * Use this method to delete multiple messages simultaneously. If some of the specified messages can't be found, they are skipped.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n   * @param  {Array<Number|String>} messageIds  Identifiers of 1-100 messages to delete. See deleteMessage for limitations on which messages can be deleted\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise<Boolean>} True on success\n   * @see https://core.telegram.org/bots/api#deletemessages\n   */\n  deleteMessages(chatId, messageIds, form = {}) {\n    form.chat_id = chatId;\n    form.message_ids = stringify(messageIds);\n    return this._request('deleteMessages', { form });\n  }\n\n}\n\nmodule.exports = TelegramBot;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL3NyYy90ZWxlZ3JhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHNIQUF5QyxJQUFJOztBQUU3QyxlQUFlLG1CQUFPLENBQUMsMEVBQVU7QUFDakMsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW1CO0FBQ3RELDJCQUEyQixtQkFBTyxDQUFDLDRGQUFtQjtBQUN0RCxjQUFjLG1CQUFPLENBQUMseUZBQU87QUFDN0IscUJBQXFCLG1CQUFPLENBQUMsa0VBQWU7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsMERBQVc7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMseUZBQTBCO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLHdFQUFrQjtBQUNsRCxXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQywrQ0FBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxnREFBTTtBQUMzQixrQkFBa0IseUdBQTRCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFD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QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCLGNBQWMsc0JBQXNCO0FBQ3BDLGNBQWMsUUFBUTtBQUN0QixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG9saXN0LXdlYi8uL25vZGVfbW9kdWxlcy9ub2RlLXRlbGVncmFtLWJvdC1hcGkvc3JjL3RlbGVncmFtLmpzP2UwYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbXNcbnJlcXVpcmUoJ2FycmF5LnByb3RvdHlwZS5maW5kaW5kZXgnKS5zaGltKCk7IC8vIGZvciBOb2RlLmpzIHYwLnhcblxuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFRlbGVncmFtQm90V2ViSG9vayA9IHJlcXVpcmUoJy4vdGVsZWdyYW1XZWJIb29rJyk7XG5jb25zdCBUZWxlZ3JhbUJvdFBvbGxpbmcgPSByZXF1aXJlKCcuL3RlbGVncmFtUG9sbGluZycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdub2RlLXRlbGVncmFtLWJvdC1hcGknKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcbmNvbnN0IGZpbGVUeXBlID0gcmVxdWlyZSgnZmlsZS10eXBlJyk7XG5jb25zdCByZXF1ZXN0ID0gcmVxdWlyZSgnQGN5cHJlc3MvcmVxdWVzdC1wcm9taXNlJyk7XG5jb25zdCBzdHJlYW1lZFJlcXVlc3QgPSByZXF1aXJlKCdAY3lwcmVzcy9yZXF1ZXN0Jyk7XG5jb25zdCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IG1pbWUgPSByZXF1aXJlKCdtaW1lJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgVVJMID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwdW1wID0gcmVxdWlyZSgncHVtcCcpO1xuY29uc3QgZGVwcmVjYXRlID0gcmVxdWlyZSgnLi91dGlscycpLmRlcHJlY2F0ZTtcblxuY29uc3QgX21lc3NhZ2VUeXBlcyA9IFtcbiAgJ3RleHQnLFxuICAnYW5pbWF0aW9uJyxcbiAgJ2F1ZGlvJyxcbiAgJ2NoYW5uZWxfY2hhdF9jcmVhdGVkJyxcbiAgJ2NvbnRhY3QnLFxuICAnZGVsZXRlX2NoYXRfcGhvdG8nLFxuICAnZGljZScsXG4gICdkb2N1bWVudCcsXG4gICdnYW1lJyxcbiAgJ2dyb3VwX2NoYXRfY3JlYXRlZCcsXG4gICdpbnZvaWNlJyxcbiAgJ2xlZnRfY2hhdF9tZW1iZXInLFxuICAnbG9jYXRpb24nLFxuICAnbWlncmF0ZV9mcm9tX2NoYXRfaWQnLFxuICAnbWlncmF0ZV90b19jaGF0X2lkJyxcbiAgJ25ld19jaGF0X21lbWJlcnMnLFxuICAnbmV3X2NoYXRfcGhvdG8nLFxuICAnbmV3X2NoYXRfdGl0bGUnLFxuICAncGFzc3BvcnRfZGF0YScsXG4gICdwaG90bycsXG4gICdwaW5uZWRfbWVzc2FnZScsXG4gICdwb2xsJyxcbiAgJ3N0aWNrZXInLFxuICAnc3VjY2Vzc2Z1bF9wYXltZW50JyxcbiAgJ3N1cGVyZ3JvdXBfY2hhdF9jcmVhdGVkJyxcbiAgJ3ZpZGVvJyxcbiAgJ3ZpZGVvX25vdGUnLFxuICAndm9pY2UnLFxuICAndmlkZW9fY2hhdF9zdGFydGVkJyxcbiAgJ3ZpZGVvX2NoYXRfZW5kZWQnLFxuICAndmlkZW9fY2hhdF9wYXJ0aWNpcGFudHNfaW52aXRlZCcsXG4gICd2aWRlb19jaGF0X3NjaGVkdWxlZCcsXG4gICdtZXNzYWdlX2F1dG9fZGVsZXRlX3RpbWVyX2NoYW5nZWQnLFxuICAnY2hhdF9pbnZpdGVfbGluaycsXG4gICdjaGF0X21lbWJlcl91cGRhdGVkJyxcbiAgJ3dlYl9hcHBfZGF0YScsXG4gICdtZXNzYWdlX3JlYWN0aW9uJ1xuXTtcblxuY29uc3QgX2RlcHJlY2F0ZWRNZXNzYWdlVHlwZXMgPSBbXG4gICduZXdfY2hhdF9wYXJ0aWNpcGFudCcsICdsZWZ0X2NoYXRfcGFydGljaXBhbnQnXG5dO1xuXG4vKipcbiAqIEpTT04tc2VyaWFsaXplIGRhdGEuIElmIHRoZSBwcm92aWRlZCBkYXRhIGlzIGFscmVhZHkgYSBTdHJpbmcsXG4gKiByZXR1cm4gaXQgYXMgaXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7Kn0gZGF0YVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xufVxuXG5cbmNsYXNzIFRlbGVncmFtQm90IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIFRoZSBkaWZmZXJlbnQgZXJyb3JzIHRoZSBsaWJyYXJ5IHVzZXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGVycm9ycygpIHtcbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlcyBvZiBtZXNzYWdlIHVwZGF0ZXMgdGhlIGxpYnJhcnkgaGFuZGxlcy5cbiAgICogQHR5cGUge1N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIGdldCBtZXNzYWdlVHlwZXMoKSB7XG4gICAgcmV0dXJuIF9tZXNzYWdlVHlwZXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIFtldmVudF0oaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjZXZlbnRzKS5cbiAgICogVGhpcyBpcyB0aGUgdXN1YWwgYGVtaXR0ZXIub24oKWAgbWV0aG9kLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNldmVudHN8QXZhaWxhYmxlIGV2ZW50c31cbiAgICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19lbWl0dGVyX29uX2V2ZW50bmFtZV9saXN0ZW5lclxuICAgKi9cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKF9kZXByZWNhdGVkTWVzc2FnZVR5cGVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgY29uc3QgdXJsID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI2V2ZW50cyc7XG4gICAgICBkZXByZWNhdGUoYEV2ZW50cyAke19kZXByZWNhdGVkTWVzc2FnZVR5cGVzLmpvaW4oJywnKX0gYXJlIGRlcHJlY2F0ZWQuIFNlZSB0aGUgdXBkYXRlZCBsaXN0IG9mIGV2ZW50czogJHt1cmx9YCk7XG4gICAgfVxuICAgIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQm90aCByZXF1ZXN0IG1ldGhvZCB0byBvYnRhaW4gbWVzc2FnZXMgYXJlIGltcGxlbWVudGVkLiBUbyB1c2Ugc3RhbmRhcmQgcG9sbGluZywgc2V0IGBwb2xsaW5nOiB0cnVlYFxuICAgKiBvbiBgb3B0aW9uc2AuIE5vdGljZSB0aGF0IFt3ZWJIb29rXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHdlYmhvb2spIHdpbGwgbmVlZCBhIFNTTCBjZXJ0aWZpY2F0ZS5cbiAgICogRW1pdHMgYG1lc3NhZ2VgIHdoZW4gYSBtZXNzYWdlIGFycml2ZXMuXG4gICAqXG4gICAqIEBjbGFzcyBUZWxlZ3JhbUJvdFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIEJvdCBUb2tlblxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IFtvcHRpb25zLnBvbGxpbmc9ZmFsc2VdIFNldCB0cnVlIHRvIGVuYWJsZSBwb2xsaW5nIG9yIHNldCBvcHRpb25zLlxuICAgKiAgSWYgYSBXZWJIb29rIGhhcyBiZWVuIHNldCwgaXQgd2lsbCBiZSBkZWxldGVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW29wdGlvbnMucG9sbGluZy50aW1lb3V0PTEwXSAqRGVwcmVjYXRlZC4gVXNlIGBvcHRpb25zLnBvbGxpbmcucGFyYW1zYCBpbnN0ZWFkKi5cbiAgICogIFRpbWVvdXQgaW4gc2Vjb25kcyBmb3IgbG9uZyBwb2xsaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRlc3RFbnZpcm9ubWVudD1mYWxzZV0gU2V0IHRydWUgdG8gIHdvcmsgd2l0aCB0ZXN0IGVudmlyb21lbnQuXG4gICAqIFdoZW4gd29ya2luZyB3aXRoIHRoZSB0ZXN0IGVudmlyb25tZW50LCB5b3UgbWF5IHVzZSBIVFRQIGxpbmtzIHdpdGhvdXQgVExTIHRvIHRlc3QgeW91ciBXZWIgQXBwLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtvcHRpb25zLnBvbGxpbmcuaW50ZXJ2YWw9MzAwXSBJbnRlcnZhbCBiZXR3ZWVuIHJlcXVlc3RzIGluIG1pbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucG9sbGluZy5hdXRvU3RhcnQ9dHJ1ZV0gU3RhcnQgcG9sbGluZyBpbW1lZGlhdGVseVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9sbGluZy5wYXJhbXNdIFBhcmFtZXRlcnMgdG8gYmUgdXNlZCBpbiBwb2xsaW5nIEFQSSByZXF1ZXN0cy5cbiAgICogIFNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHVwZGF0ZXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMucG9sbGluZy5wYXJhbXMudGltZW91dD0xMF0gVGltZW91dCBpbiBzZWNvbmRzIGZvciBsb25nIHBvbGxpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IFtvcHRpb25zLndlYkhvb2s9ZmFsc2VdIFNldCB0cnVlIHRvIGVuYWJsZSBXZWJIb29rIG9yIHNldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53ZWJIb29rLmhvc3Q9XCIwLjAuMC4wXCJdIEhvc3QgdG8gYmluZCB0b1xuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2ViSG9vay5wb3J0PTg0NDNdIFBvcnQgdG8gYmluZCB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2ViSG9vay5rZXldIFBhdGggdG8gZmlsZSB3aXRoIFBFTSBwcml2YXRlIGtleSBmb3Igd2ViSG9vayBzZXJ2ZXIuXG4gICAqICBUaGUgZmlsZSBpcyByZWFkICoqc3luY2hyb25vdXNseSoqIVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2ViSG9vay5jZXJ0XSBQYXRoIHRvIGZpbGUgd2l0aCBQRU0gY2VydGlmaWNhdGUgKHB1YmxpYykgZm9yIHdlYkhvb2sgc2VydmVyLlxuICAgKiAgVGhlIGZpbGUgaXMgcmVhZCAqKnN5bmNocm9ub3VzbHkqKiFcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndlYkhvb2sucGZ4XSBQYXRoIHRvIGZpbGUgd2l0aCBQRlggcHJpdmF0ZSBrZXkgYW5kIGNlcnRpZmljYXRlIGNoYWluIGZvciB3ZWJIb29rIHNlcnZlci5cbiAgICogIFRoZSBmaWxlIGlzIHJlYWQgKipzeW5jaHJvbm91c2x5KiohXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2ViSG9vay5hdXRvT3Blbj10cnVlXSBPcGVuIHdlYkhvb2sgaW1tZWRpYXRlbHlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLndlYkhvb2suaHR0cHNdIE9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIGBodHRwcy5jcmVhdGVTZXJ2ZXIoKWAuXG4gICAqICBOb3RlIHRoYXQgYG9wdGlvbnMud2ViSG9vay5rZXlgLCBgb3B0aW9ucy53ZWJIb29rLmNlcnRgIGFuZCBgb3B0aW9ucy53ZWJIb29rLnBmeGAsIGlmIHByb3ZpZGVkLCB3aWxsIGJlXG4gICAqICB1c2VkIHRvIG92ZXJyaWRlIGBrZXlgLCBgY2VydGAgYW5kIGBwZnhgIGluIHRoaXMgb2JqZWN0LCByZXNwZWN0aXZlbHkuXG4gICAqICBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwcy5odG1sI2h0dHBzX2h0dHBzX2NyZWF0ZXNlcnZlcl9vcHRpb25zX3JlcXVlc3RsaXN0ZW5lciBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndlYkhvb2suaGVhbHRoRW5kcG9pbnQ9XCIvaGVhbHRoelwiXSBBbiBlbmRwb2ludCBmb3IgaGVhbHRoIGNoZWNrcyB0aGF0IGFsd2F5cyByZXNwb25kcyB3aXRoIDIwMCBPS1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9ubHlGaXJzdE1hdGNoPWZhbHNlXSBTZXQgdG8gdHJ1ZSB0byBzdG9wIGFmdGVyIGZpcnN0IG1hdGNoLiBPdGhlcndpc2UsIGFsbCByZWdleHBzIGFyZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucmVxdWVzdF0gT3B0aW9ucyB3aGljaCB3aWxsIGJlIGFkZGVkIGZvciBhbGwgcmVxdWVzdHMgdG8gdGVsZWdyYW0gYXBpLlxuICAgKiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZXF1ZXN0L3JlcXVlc3QjcmVxdWVzdG9wdGlvbnMtY2FsbGJhY2sgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5iYXNlQXBpVXJsPVwiaHR0cHM6Ly9hcGkudGVsZWdyYW0ub3JnXCJdIEFQSSBCYXNlIFVSbDsgdXNlZnVsIGZvciBwcm94eWluZyBhbmQgdGVzdGluZ1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbGVwYXRoPXRydWVdIEFsbG93IHBhc3NpbmcgZmlsZS1wYXRocyBhcyBhcmd1bWVudHMgd2hlbiBzZW5kaW5nIGZpbGVzLFxuICAgKiAgc3VjaCBhcyBwaG90b3MgdXNpbmcgYFRlbGVncmFtQm90I3NlbmRQaG90bygpYC4gU2VlIFt1c2FnZSBpbmZvcm1hdGlvbl1bdXNhZ2Utc2VuZGluZy1maWxlcy1wZXJmb3JtYW5jZV1cbiAgICogIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoaXMgb3B0aW9uIGFuZCBpdHMgY29uc2VxdWVuY2VzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJhZFJlamVjdGlvbj1mYWxzZV0gU2V0IHRvIGB0cnVlYFxuICAgKiAgKippZiBhbmQgb25seSBpZioqIHRoZSBOb2RlLmpzIHZlcnNpb24geW91J3JlIHVzaW5nIHRlcm1pbmF0ZXMgdGhlXG4gICAqICBwcm9jZXNzIG9uIHVuaGFuZGxlZCByZWplY3Rpb25zLiBUaGlzIG9wdGlvbiBpcyBvbmx5IGZvclxuICAgKiAgKmZvcndhcmQtY29tcGF0aWJpbGl0eSBwdXJwb3NlcyouXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaVxuICAgKi9cbiAgY29uc3RydWN0b3IodG9rZW4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5vcHRpb25zLnBvbGxpbmcgPSAodHlwZW9mIG9wdGlvbnMucG9sbGluZyA9PT0gJ3VuZGVmaW5lZCcpID8gZmFsc2UgOiBvcHRpb25zLnBvbGxpbmc7XG4gICAgdGhpcy5vcHRpb25zLndlYkhvb2sgPSAodHlwZW9mIG9wdGlvbnMud2ViSG9vayA9PT0gJ3VuZGVmaW5lZCcpID8gZmFsc2UgOiBvcHRpb25zLndlYkhvb2s7XG4gICAgdGhpcy5vcHRpb25zLmJhc2VBcGlVcmwgPSBvcHRpb25zLmJhc2VBcGlVcmwgfHwgJ2h0dHBzOi8vYXBpLnRlbGVncmFtLm9yZyc7XG4gICAgdGhpcy5vcHRpb25zLmZpbGVwYXRoID0gKHR5cGVvZiBvcHRpb25zLmZpbGVwYXRoID09PSAndW5kZWZpbmVkJykgPyB0cnVlIDogb3B0aW9ucy5maWxlcGF0aDtcbiAgICB0aGlzLm9wdGlvbnMuYmFkUmVqZWN0aW9uID0gKHR5cGVvZiBvcHRpb25zLmJhZFJlamVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpID8gZmFsc2UgOiBvcHRpb25zLmJhZFJlamVjdGlvbjtcbiAgICB0aGlzLl90ZXh0UmVnZXhwQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5fcmVwbHlMaXN0ZW5lcklkID0gMDtcbiAgICB0aGlzLl9yZXBseUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3BvbGxpbmcgPSBudWxsO1xuICAgIHRoaXMuX3dlYkhvb2sgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMucG9sbGluZykge1xuICAgICAgY29uc3QgYXV0b1N0YXJ0ID0gb3B0aW9ucy5wb2xsaW5nLmF1dG9TdGFydDtcbiAgICAgIGlmICh0eXBlb2YgYXV0b1N0YXJ0ID09PSAndW5kZWZpbmVkJyB8fCBhdXRvU3RhcnQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy53ZWJIb29rKSB7XG4gICAgICBjb25zdCBhdXRvT3BlbiA9IG9wdGlvbnMud2ViSG9vay5hdXRvT3BlbjtcbiAgICAgIGlmICh0eXBlb2YgYXV0b09wZW4gPT09ICd1bmRlZmluZWQnIHx8IGF1dG9PcGVuID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMub3BlbldlYkhvb2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHVybCB3aXRoIGJvdCB0b2tlbiBhbmQgcHJvdmlkZWQgcGF0aC9tZXRob2QgeW91IHdhbnQgdG8gYmUgZ290L2V4ZWN1dGVkIGJ5IGJvdFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGhcbiAgICogQHJldHVybiB7U3RyaW5nfSB1cmxcbiAgICogQHByaXZhdGVcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21ha2luZy1yZXF1ZXN0c1xuICAgKi9cbiAgX2J1aWxkVVJMKF9wYXRoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5iYXNlQXBpVXJsfS9ib3Qke3RoaXMudG9rZW59JHt0aGlzLm9wdGlvbnMudGVzdEVudmlyb25tZW50ID8gJy90ZXN0JyA6ICcnfS8ke19wYXRofWA7XG4gIH1cblxuICAvKipcbiAgICogRml4ICdyZXBseV9tYXJrdXAnIHBhcmFtZXRlciBieSBtYWtpbmcgaXQgSlNPTi1zZXJpYWxpemVkLCBhc1xuICAgKiByZXF1aXJlZCBieSB0aGUgVGVsZWdyYW0gQm90IEFQSVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdDsgZWl0aGVyICdmb3JtJyBvciAncXMnXG4gICAqIEBwcml2YXRlXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kbWVzc2FnZVxuICAgKi9cbiAgX2ZpeFJlcGx5TWFya3VwKG9iaikge1xuICAgIGNvbnN0IHJlcGx5TWFya3VwID0gb2JqLnJlcGx5X21hcmt1cDtcbiAgICBpZiAocmVwbHlNYXJrdXAgJiYgdHlwZW9mIHJlcGx5TWFya3VwICE9PSAnc3RyaW5nJykge1xuICAgICAgb2JqLnJlcGx5X21hcmt1cCA9IHN0cmluZ2lmeShyZXBseU1hcmt1cCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpeCAnZW50aXRpZXMnIG9yICdjYXB0aW9uX2VudGl0aWVzJyBvciAnZXhwbGFuYXRpb25fZW50aXRpZXMnIHBhcmFtZXRlciBieSBtYWtpbmcgaXQgSlNPTi1zZXJpYWxpemVkLCBhc1xuICAgKiByZXF1aXJlZCBieSB0aGUgVGVsZWdyYW0gQm90IEFQSVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdDtcbiAgICogQHByaXZhdGVcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRtZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjb3B5bWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHBvbGxcbiAgICovXG4gIF9maXhFbnRpdGllc0ZpZWxkKG9iaikge1xuICAgIGNvbnN0IGVudGl0aWVzID0gb2JqLmVudGl0aWVzO1xuICAgIGNvbnN0IGNhcHRpb25FbnRpdGllcyA9IG9iai5jYXB0aW9uX2VudGl0aWVzO1xuICAgIGNvbnN0IGV4cGxhbmF0aW9uRW50aXRpZXMgPSBvYmouZXhwbGFuYXRpb25fZW50aXRpZXM7XG4gICAgaWYgKGVudGl0aWVzICYmIHR5cGVvZiBlbnRpdGllcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG9iai5lbnRpdGllcyA9IHN0cmluZ2lmeShlbnRpdGllcyk7XG4gICAgfVxuXG4gICAgaWYgKGNhcHRpb25FbnRpdGllcyAmJiB0eXBlb2YgY2FwdGlvbkVudGl0aWVzICE9PSAnc3RyaW5nJykge1xuICAgICAgb2JqLmNhcHRpb25fZW50aXRpZXMgPSBzdHJpbmdpZnkoY2FwdGlvbkVudGl0aWVzKTtcbiAgICB9XG5cbiAgICBpZiAoZXhwbGFuYXRpb25FbnRpdGllcyAmJiB0eXBlb2YgZXhwbGFuYXRpb25FbnRpdGllcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG9iai5leHBsYW5hdGlvbl9lbnRpdGllcyA9IHN0cmluZ2lmeShleHBsYW5hdGlvbkVudGl0aWVzKTtcbiAgICB9XG4gIH1cblxuICBfZml4QWRkRmlsZVRodW1ibmFpbChvcHRpb25zLCBvcHRzKSB7XG4gICAgaWYgKG9wdGlvbnMudGh1bWIpIHtcbiAgICAgIGlmIChvcHRzLmZvcm1EYXRhID09PSBudWxsKSB7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSB7fTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0YWNoTmFtZSA9ICdwaG90byc7XG4gICAgICBjb25zdCBbZm9ybURhdGFdID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoYXR0YWNoTmFtZSwgb3B0aW9ucy50aHVtYi5yZXBsYWNlKCdhdHRhY2g6Ly8nLCAnJykpO1xuXG4gICAgICBpZiAoZm9ybURhdGEpIHtcbiAgICAgICAgb3B0cy5mb3JtRGF0YVthdHRhY2hOYW1lXSA9IGZvcm1EYXRhW2F0dGFjaE5hbWVdO1xuICAgICAgICBvcHRzLnFzLnRodW1ibmFpbCA9IGBhdHRhY2g6Ly8ke2F0dGFjaE5hbWV9YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRml4ICdyZXBseV9wYXJhbWV0ZXJzJyBwYXJhbWV0ZXIgYnkgbWFraW5nIGl0IEpTT04tc2VyaWFsaXplZCwgYXNcbiAgICogcmVxdWlyZWQgYnkgdGhlIFRlbGVncmFtIEJvdCBBUElcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3Q7IGVpdGhlciAnZm9ybScgb3IgJ3FzJ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZG1lc3NhZ2VcbiAgICovXG4gIF9maXhSZXBseVBhcmFtZXRlcnMob2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSgncmVwbHlfcGFyYW1ldGVycycpICYmIHR5cGVvZiBvYmoucmVwbHlfcGFyYW1ldGVycyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG9iai5yZXBseV9wYXJhbWV0ZXJzID0gc3RyaW5naWZ5KG9iai5yZXBseV9wYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSByZXF1ZXN0IGFnYWluc3QgdGhlIEFQSVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IF9wYXRoIEFQSSBlbmRwb2ludFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgX3JlcXVlc3QoX3BhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy50b2tlbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnMuRmF0YWxFcnJvcignVGVsZWdyYW0gQm90IFRva2VuIG5vdCBwcm92aWRlZCEnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXF1ZXN0KSB7XG4gICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy5yZXF1ZXN0KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5mb3JtKSB7XG4gICAgICB0aGlzLl9maXhSZXBseU1hcmt1cChvcHRpb25zLmZvcm0pO1xuICAgICAgdGhpcy5fZml4RW50aXRpZXNGaWVsZChvcHRpb25zLmZvcm0pO1xuICAgICAgdGhpcy5fZml4UmVwbHlQYXJhbWV0ZXJzKG9wdGlvbnMuZm9ybSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnFzKSB7XG4gICAgICB0aGlzLl9maXhSZXBseU1hcmt1cChvcHRpb25zLnFzKTtcbiAgICAgIHRoaXMuX2ZpeFJlcGx5UGFyYW1ldGVycyhvcHRpb25zLnFzKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLm1ldGhvZCA9ICdQT1NUJztcbiAgICBvcHRpb25zLnVybCA9IHRoaXMuX2J1aWxkVVJMKF9wYXRoKTtcbiAgICBvcHRpb25zLnNpbXBsZSA9IGZhbHNlO1xuICAgIG9wdGlvbnMucmVzb2x2ZVdpdGhGdWxsUmVzcG9uc2UgPSB0cnVlO1xuICAgIG9wdGlvbnMuZm9yZXZlciA9IHRydWU7XG4gICAgZGVidWcoJ0hUVFAgcmVxdWVzdDogJWonLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVxdWVzdChvcHRpb25zKVxuICAgICAgLnRoZW4ocmVzcCA9PiB7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSByZXNwLmJvZHkgPSBKU09OLnBhcnNlKHJlc3AuYm9keSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuUGFyc2VFcnJvcihgRXJyb3IgcGFyc2luZyByZXNwb25zZTogJHtyZXNwLmJvZHl9YCwgcmVzcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5vaykge1xuICAgICAgICAgIHJldHVybiBkYXRhLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuVGVsZWdyYW1FcnJvcihgJHtkYXRhLmVycm9yX2NvZGV9ICR7ZGF0YS5kZXNjcmlwdGlvbn1gLCByZXNwKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgLy8gVE9ETzogd2h5IGNhbid0IHdlIGRvIGBlcnJvciBpbnN0YW5jZW9mIGVycm9ycy5CYXNlRXJyb3JgP1xuICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2UpIHRocm93IGVycm9yO1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkZhdGFsRXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0IGRhdGEgdG8gYmUgdXBsb2FkZWQ7IGhhbmRsZXMgZmlsZSBwYXRocywgc3RyZWFtcyBhbmQgYnVmZmVyc1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBkYXRhXG4gICAqIEBwYXJhbSAge09iamVjdH0gZmlsZU9wdGlvbnMgRmlsZSBvcHRpb25zXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW2ZpbGVPcHRpb25zLmZpbGVuYW1lXSBGaWxlIG5hbWVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbZmlsZU9wdGlvbnMuY29udGVudFR5cGVdIENvbnRlbnQgdHlwZSAoaS5lLiBNSU1FKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gZm9ybWF0dGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0gZm9ybWF0dGVkWzBdIGZvcm1EYXRhXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZm9ybWF0dGVkWzFdIGZpbGVJZFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIEJ1ZmZlciBmaWxlIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAgICogQHNlZSBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2ZpbGUtdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Zvcm1hdFNlbmREYXRhKHR5cGUsIGRhdGEsIGZpbGVPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBkZXByZWNhdGlvbk1lc3NhZ2UgPVxuICAgICAgJ1NlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzJyArXG4gICAgICAnIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyBzZW5kaW5nIGZpbGVzIGhhcyBiZWVuIGltcHJvdmVkIGFuZCcgK1xuICAgICAgJyBvbiBob3cgdG8gZGlzYWJsZSB0aGlzIGRlcHJlY2F0aW9uIG1lc3NhZ2UgYWx0b2dldGhlci4nO1xuICAgIGxldCBmaWxlZGF0YSA9IGRhdGE7XG4gICAgbGV0IGZpbGVuYW1lID0gZmlsZU9wdGlvbnMuZmlsZW5hbWU7XG4gICAgbGV0IGNvbnRlbnRUeXBlID0gZmlsZU9wdGlvbnMuY29udGVudFR5cGU7XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIHN0cmVhbS5TdHJlYW0pIHtcbiAgICAgIGlmICghZmlsZW5hbWUgJiYgZGF0YS5wYXRoKSB7XG4gICAgICAgIC8vIFdpbGwgYmUgJ251bGwnIGlmIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCAnZGF0YS5wYXRoJyA9PT0gJy8/aWQ9MTIzJyBmcm9tICdyZXF1ZXN0KFwiaHR0cHM6Ly9leGFtcGxlLmNvbS8/aWQ9MTIzXCIpJ1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwucGFyc2UocGF0aC5iYXNlbmFtZShkYXRhLnBhdGgudG9TdHJpbmcoKSkpO1xuICAgICAgICBpZiAodXJsLnBhdGhuYW1lKSB7XG4gICAgICAgICAgZmlsZW5hbWUgPSBxcy51bmVzY2FwZSh1cmwucGF0aG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGlmICghZmlsZW5hbWUgJiYgIXByb2Nlc3MuZW52Lk5UQkFfRklYXzM1MCkge1xuICAgICAgICBkZXByZWNhdGUoYEJ1ZmZlcnMgd2lsbCBoYXZlIHRoZWlyIGZpbGVuYW1lcyBkZWZhdWx0IHRvIFwiZmlsZW5hbWVcIiBpbnN0ZWFkIG9mIFwiZGF0YVwiLiAke2RlcHJlY2F0aW9uTWVzc2FnZX1gKTtcbiAgICAgICAgZmlsZW5hbWUgPSAnZGF0YSc7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgICAgIGNvbnN0IGZpbGV0eXBlID0gZmlsZVR5cGUoZGF0YSk7XG4gICAgICAgIGlmIChmaWxldHlwZSkge1xuICAgICAgICAgIGNvbnRlbnRUeXBlID0gZmlsZXR5cGUubWltZTtcbiAgICAgICAgICBjb25zdCBleHQgPSBmaWxldHlwZS5leHQ7XG4gICAgICAgICAgaWYgKGV4dCAmJiAhcHJvY2Vzcy5lbnYuTlRCQV9GSVhfMzUwKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IGAke2ZpbGVuYW1lfS4ke2V4dH1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghcHJvY2Vzcy5lbnYuTlRCQV9GSVhfMzUwKSB7XG4gICAgICAgICAgZGVwcmVjYXRlKGBBbiBlcnJvciB3aWxsIG5vIGxvbmdlciBiZSB0aHJvd24gaWYgZmlsZS10eXBlIG9mIGJ1ZmZlciBjb3VsZCBub3QgYmUgZGV0ZWN0ZWQuICR7ZGVwcmVjYXRpb25NZXNzYWdlfWApO1xuICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRmF0YWxFcnJvcignVW5zdXBwb3J0ZWQgQnVmZmVyIGZpbGUtdHlwZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZpbGVwYXRoICYmIGZzLmV4aXN0c1N5bmMoZGF0YSkpIHtcbiAgICAgICAgZmlsZWRhdGEgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGRhdGEpO1xuICAgICAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICAgICAgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW251bGwsIGRhdGFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW251bGwsIGRhdGFdO1xuICAgIH1cblxuICAgIGZpbGVuYW1lID0gZmlsZW5hbWUgfHwgJ2ZpbGVuYW1lJztcbiAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlIHx8IG1pbWUubG9va3VwKGZpbGVuYW1lKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTlRCQV9GSVhfMzUwKSB7XG4gICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXByZWNhdGUoYEluIHRoZSBmdXR1cmUsIGNvbnRlbnQtdHlwZSBvZiBmaWxlcyB5b3Ugc2VuZCB3aWxsIGRlZmF1bHQgdG8gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIi4gJHtkZXByZWNhdGlvbk1lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogQWRkIG1pc3NpbmcgZmlsZSBleHRlbnNpb24uXG5cbiAgICByZXR1cm4gW3tcbiAgICAgIFt0eXBlXToge1xuICAgICAgICB2YWx1ZTogZmlsZWRhdGEsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSwgbnVsbF07XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcG9sbGluZy5cbiAgICogUmVqZWN0cyByZXR1cm5lZCBwcm9taXNlIGlmIGEgV2ViSG9vayBpcyBiZWluZyB1c2VkIGJ5IHRoaXMgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnJlc3RhcnQ9dHJ1ZV0gQ29uc2VjdXRpdmUgY2FsbHMgdG8gdGhpcyBtZXRob2QgY2F1c2VzIHBvbGxpbmcgdG8gYmUgcmVzdGFydGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzdGFydFBvbGxpbmcob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuaGFzT3BlbldlYkhvb2soKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnMuRmF0YWxFcnJvcignUG9sbGluZyBhbmQgV2ViSG9vayBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlJykpO1xuICAgIH1cbiAgICBvcHRpb25zLnJlc3RhcnQgPSB0eXBlb2Ygb3B0aW9ucy5yZXN0YXJ0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBvcHRpb25zLnJlc3RhcnQ7XG4gICAgaWYgKCF0aGlzLl9wb2xsaW5nKSB7XG4gICAgICB0aGlzLl9wb2xsaW5nID0gbmV3IFRlbGVncmFtQm90UG9sbGluZyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BvbGxpbmcuc3RhcnQob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgb2YgYFRlbGVncmFtQm90I3N0YXJ0UG9sbGluZygpYC4gVGhpcyBpcyAqKmRlcHJlY2F0ZWQqKi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGluaXRQb2xsaW5nKCkge1xuICAgIGRlcHJlY2F0ZSgnVGVsZWdyYW1Cb3QjaW5pdFBvbGxpbmcoKSBpcyBkZXByZWNhdGVkLiBVc2UgVGVsZWdyYW1Cb3Qjc3RhcnRQb2xsaW5nKCkgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBwb2xsaW5nIGFmdGVyIHRoZSBsYXN0IHBvbGxpbmcgcmVxdWVzdCByZXNvbHZlcy5cbiAgICogTXVsdGlwbGUgaW52b2NhdGlvbnMgZG8gbm90aGluZyBpZiBwb2xsaW5nIGlzIGFscmVhZHkgc3RvcHBlZC5cbiAgICogUmV0dXJuaW5nIHRoZSBwcm9taXNlIG9mIHRoZSBsYXN0IHBvbGxpbmcgcmVxdWVzdCBpcyAqKmRlcHJlY2F0ZWQqKi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxdIENhbmNlbCBjdXJyZW50IHJlcXVlc3RcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb25dIFJlYXNvbiBmb3Igc3RvcHBpbmcgcG9sbGluZ1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgc3RvcFBvbGxpbmcob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5fcG9sbGluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9sbGluZy5zdG9wKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBsaW5rIGZvciBmaWxlLlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGxpbmsgZm9yIGZpbGUgZm9yIHN1YnNlcXVlbnQgdXNlLlxuICAgKiBBdHRlbnRpb246IGxpbmsgd2lsbCBiZSB2YWxpZCBmb3IgMSBob3VyLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhIHN1Z2FyIGV4dGVuc2lvbiBvZiB0aGUgKGdldEZpbGUpWyNnZXRmaWxlZmlsZWlkXSBtZXRob2QsXG4gICAqIHdoaWNoIHJldHVybnMganVzdCBwYXRoIHRvIGZpbGUgb24gcmVtb3RlIHNlcnZlciAoeW91IHdpbGwgaGF2ZSB0byBtYW51YWxseSBidWlsZCBmdWxsIHVyaSBhZnRlciB0aGF0KS5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBmaWxlSWQgIEZpbGUgaWRlbnRpZmllciB0byBnZXQgaW5mbyBhYm91dFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB3aGljaCB3aWxsIGhhdmUgICpmaWxlVVJJKiBpbiByZXNvbHZlIGNhbGxiYWNrXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRmaWxlXG4gICAqL1xuICBnZXRGaWxlTGluayhmaWxlSWQsIGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEZpbGUoZmlsZUlkLCBmb3JtKVxuICAgICAgLnRoZW4ocmVzcCA9PiBgJHt0aGlzLm9wdGlvbnMuYmFzZUFwaVVybH0vZmlsZS9ib3Qke3RoaXMudG9rZW59LyR7cmVzcC5maWxlX3BhdGh9YCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgcmVhZGFibGUgc3RyZWFtIGZvciBmaWxlLlxuICAgKlxuICAgKiBgZmlsZVN0cmVhbS5wYXRoYCBpcyB0aGUgc3BlY2lmaWVkIGZpbGUgSUQgaS5lLiBgZmlsZUlkYC5cbiAgICogYGZpbGVTdHJlYW1gIGVtaXRzIGV2ZW50IGBpbmZvYCBwYXNzaW5nIGEgc2luZ2xlIGFyZ3VtZW50IGkuZS5cbiAgICogYGluZm9gIHdpdGggdGhlIGludGVyZmFjZSBgeyB1cmkgfWAgd2hlcmUgYHVyaWAgaXMgdGhlIFVSSSBvZiB0aGVcbiAgICogZmlsZSBvbiBUZWxlZ3JhbSBzZXJ2ZXJzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhIHN1Z2FyIGV4dGVuc2lvbiBvZiB0aGUgW2dldEZpbGVMaW5rXSgjVGVsZWdyYW1Cb3QrZ2V0RmlsZUxpbmspIG1ldGhvZCxcbiAgICogd2hpY2ggcmV0dXJucyB0aGUgZnVsbCBVUkkgdG8gdGhlIGZpbGUgb24gcmVtb3RlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBmaWxlSWQgRmlsZSBpZGVudGlmaWVyIHRvIGdldCBpbmZvIGFib3V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJlYW0uUmVhZGFibGV9IGZpbGVTdHJlYW1cbiAgICovXG4gIGdldEZpbGVTdHJlYW0oZmlsZUlkLCBmb3JtID0ge30pIHtcbiAgICBjb25zdCBmaWxlU3RyZWFtID0gbmV3IHN0cmVhbS5QYXNzVGhyb3VnaCgpO1xuICAgIGZpbGVTdHJlYW0ucGF0aCA9IGZpbGVJZDtcbiAgICB0aGlzLmdldEZpbGVMaW5rKGZpbGVJZCwgZm9ybSlcbiAgICAgIC50aGVuKChmaWxlVVJJKSA9PiB7XG4gICAgICAgIGZpbGVTdHJlYW0uZW1pdCgnaW5mbycsIHtcbiAgICAgICAgICB1cmk6IGZpbGVVUkksXG4gICAgICAgIH0pO1xuICAgICAgICBwdW1wKHN0cmVhbWVkUmVxdWVzdChPYmplY3QuYXNzaWduKHsgdXJpOiBmaWxlVVJJIH0sIHRoaXMub3B0aW9ucy5yZXF1ZXN0KSksIGZpbGVTdHJlYW0pO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgZmlsZVN0cmVhbS5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgIHJldHVybiBmaWxlU3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyBmaWxlIGluIHRoZSBzcGVjaWZpZWQgZm9sZGVyLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhIHN1Z2FyIGV4dGVuc2lvbiBvZiB0aGUgW2dldEZpbGVTdHJlYW1dKCNUZWxlZ3JhbUJvdCtnZXRGaWxlU3RyZWFtKSBtZXRob2QsXG4gICAqIHdoaWNoIHJldHVybnMgYSByZWFkYWJsZSBmaWxlIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBmaWxlSWQgIEZpbGUgaWRlbnRpZmllciB0byBnZXQgaW5mbyBhYm91dFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRvd25sb2FkRGlyIEFic29sdXRlIHBhdGggdG8gdGhlIGZvbGRlciBpbiB3aGljaCBmaWxlIHdpbGwgYmUgc2F2ZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UsIHdoaWNoIHdpbGwgaGF2ZSAqZmlsZVBhdGgqIG9mIGRvd25sb2FkZWQgZmlsZSBpbiByZXNvbHZlIGNhbGxiYWNrXG4gICAqL1xuICBkb3dubG9hZEZpbGUoZmlsZUlkLCBkb3dubG9hZERpciwgZm9ybSA9IHt9KSB7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgbGV0IHJlamVjdDtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKGEsIGIpID0+IHtcbiAgICAgIHJlc29sdmUgPSBhO1xuICAgICAgcmVqZWN0ID0gYjtcbiAgICB9KTtcbiAgICBjb25zdCBmaWxlU3RyZWFtID0gdGhpcy5nZXRGaWxlU3RyZWFtKGZpbGVJZCwgZm9ybSk7XG4gICAgZmlsZVN0cmVhbS5vbignaW5mbycsIChpbmZvKSA9PiB7XG4gICAgICBjb25zdCBmaWxlTmFtZSA9IGluZm8udXJpLnNsaWNlKGluZm8udXJpLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgIC8vIFRPRE86IEVuc3VyZSBmaWxlTmFtZSBkb2Vzbid0IGNvbnRhaW5zIHNsYXNoZXNcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKGRvd25sb2FkRGlyLCBmaWxlTmFtZSk7XG4gICAgICBwdW1wKGZpbGVTdHJlYW0sIGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZpbGVQYXRoKSwgKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikgeyByZXR1cm4gcmVqZWN0KGVycm9yKTsgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlUGF0aCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBmaWxlU3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgUmVnRXhwIHRvIHRlc3QgYWdhaW5zdCBhbiBpbmNvbW1pbmcgdGV4dCBtZXNzYWdlLlxuICAgKiBAcGFyYW0gIHtSZWdFeHB9ICAgcmVnZXhwUmV4ZWN1dGVkIHdpdGggYGV4ZWNgLlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgIENhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggMiBwYXJhbWV0ZXJzLFxuICAgKiB0aGUgYG1zZ2AgYW5kIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIGByZWdleHAuZXhlY2Agb24gbWVzc2FnZSB0ZXh0LlxuICAgKi9cbiAgb25UZXh0KHJlZ2V4cCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl90ZXh0UmVnZXhwQ2FsbGJhY2tzLnB1c2goeyByZWdleHAsIGNhbGxiYWNrIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxpc3RlbmVyIHJlZ2lzdGVyZWQgd2l0aCBgb25UZXh0KClgLlxuICAgKiBAcGFyYW0gIHtSZWdFeHB9IHJlZ2V4cCBSZWdFeHAgdXNlZCBwcmV2aW91c2x5IGluIGBvblRleHQoKWBcbiAgICogQHJldHVybiB7T2JqZWN0fSBkZWxldGVkTGlzdGVuZXIgVGhlIHJlbW92ZWQgcmVwbHkgbGlzdGVuZXIgaWZcbiAgICogICBmb3VuZC4gVGhpcyBvYmplY3QgaGFzIGByZWdleHBgIGFuZCBgY2FsbGJhY2tgXG4gICAqICAgcHJvcGVydGllcy4gSWYgbm90IGZvdW5kLCByZXR1cm5zIGBudWxsYC5cbiAgICovXG4gIHJlbW92ZVRleHRMaXN0ZW5lcihyZWdleHApIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX3RleHRSZWdleHBDYWxsYmFja3MuZmluZEluZGV4KCh0ZXh0TGlzdGVuZXIpID0+IHtcbiAgICAgIHJldHVybiBTdHJpbmcodGV4dExpc3RlbmVyLnJlZ2V4cCkgPT09IFN0cmluZyhyZWdleHApO1xuICAgIH0pO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGV4dFJlZ2V4cENhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgd2l0aCBgb25UZXh0KClgLlxuICAgKi9cbiAgY2xlYXJUZXh0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX3RleHRSZWdleHBDYWxsYmFja3MgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHJlcGx5IHRvIHdhaXQgZm9yIGEgbWVzc2FnZSByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFRoZSBjaGF0IGlkIHdoZXJlIHRoZSBtZXNzYWdlIGNhbWVzIGZyb20uXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IG1lc3NhZ2VJZCBUaGUgbWVzc2FnZSBpZCB0byBiZSByZXBsaWVkLlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVwbHlcbiAgICogIG1lc3NhZ2UuXG4gICAqIEByZXR1cm4ge051bWJlcn0gaWQgVGhlIElEIG9mIHRoZSBpbnNlcnRlZCByZXBseSBsaXN0ZW5lci5cbiAgICovXG4gIG9uUmVwbHlUb01lc3NhZ2UoY2hhdElkLCBtZXNzYWdlSWQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaWQgPSArK3RoaXMuX3JlcGx5TGlzdGVuZXJJZDtcbiAgICB0aGlzLl9yZXBseUxpc3RlbmVycy5wdXNoKHtcbiAgICAgIGlkLFxuICAgICAgY2hhdElkLFxuICAgICAgbWVzc2FnZUlkLFxuICAgICAgY2FsbGJhY2tcbiAgICB9KTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHJlcGx5IHRoYXQgaGFzIGJlZW4gcHJldi4gcmVnaXN0ZXJlZCBmb3IgYSBtZXNzYWdlIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gICB7TnVtYmVyfSByZXBseUxpc3RlbmVySWQgVGhlIElEIG9mIHRoZSByZXBseSBsaXN0ZW5lci5cbiAgICogQHJldHVybiAge09iamVjdH0gZGVsZXRlZExpc3RlbmVyIFRoZSByZW1vdmVkIHJlcGx5IGxpc3RlbmVyIGlmXG4gICAqICAgZm91bmQuIFRoaXMgb2JqZWN0IGhhcyBgaWRgLCBgY2hhdElkYCwgYG1lc3NhZ2VJZGAgYW5kIGBjYWxsYmFja2BcbiAgICogICBwcm9wZXJ0aWVzLiBJZiBub3QgZm91bmQsIHJldHVybnMgYG51bGxgLlxuICAgKi9cbiAgcmVtb3ZlUmVwbHlMaXN0ZW5lcihyZXBseUxpc3RlbmVySWQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX3JlcGx5TGlzdGVuZXJzLmZpbmRJbmRleCgocmVwbHlMaXN0ZW5lcikgPT4ge1xuICAgICAgcmV0dXJuIHJlcGx5TGlzdGVuZXIuaWQgPT09IHJlcGx5TGlzdGVuZXJJZDtcbiAgICB9KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcGx5TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSlbMF07XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgcmVwbGllcyB0aGF0IGhhdmUgYmVlbiBwcmV2LiByZWdpc3RlcmVkIGZvciBhIG1lc3NhZ2UgcmVzcG9uc2UuXG4gICAqXG4gICAqIEByZXR1cm4gIHtBcnJheX0gZGVsZXRlZExpc3RlbmVycyBBbiBhcnJheSBvZiByZW1vdmVkIGxpc3RlbmVycy5cbiAgICovXG4gIGNsZWFyUmVwbHlMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fcmVwbHlMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBwb2xsaW5nLiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNQb2xsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2xsaW5nID8gdGhpcy5fcG9sbGluZy5pc1BvbGxpbmcoKSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gd2ViaG9vay5cbiAgICogTXVsdGlwbGUgaW52b2NhdGlvbnMgZG8gbm90aGluZyBpZiB3ZWJob29rIGlzIGFscmVhZHkgb3Blbi5cbiAgICogUmVqZWN0cyByZXR1cm5lZCBwcm9taXNlIGlmIFBvbGxpbmcgaXMgYmVpbmcgdXNlZCBieSB0aGlzIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgb3BlbldlYkhvb2soKSB7XG4gICAgaWYgKHRoaXMuaXNQb2xsaW5nKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3JzLkZhdGFsRXJyb3IoJ1dlYkhvb2sgYW5kIFBvbGxpbmcgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZScpKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl93ZWJIb29rKSB7XG4gICAgICB0aGlzLl93ZWJIb29rID0gbmV3IFRlbGVncmFtQm90V2ViSG9vayh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dlYkhvb2sub3BlbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIHdlYmhvb2sgYWZ0ZXIgY2xvc2luZyBhbGwgY3VycmVudCBjb25uZWN0aW9ucy5cbiAgICogTXVsdGlwbGUgaW52b2NhdGlvbnMgZG8gbm90aGluZyBpZiB3ZWJob29rIGlzIGFscmVhZHkgY2xvc2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlXG4gICAqL1xuICBjbG9zZVdlYkhvb2soKSB7XG4gICAgaWYgKCF0aGlzLl93ZWJIb29rKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93ZWJIb29rLmNsb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgdXNpbmcgd2ViaG9vayBhbmQgaXQgaXMgb3BlbiBpLmUuIGFjY2VwdHMgY29ubmVjdGlvbnMuXG4gICAqIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBoYXNPcGVuV2ViSG9vaygpIHtcbiAgICByZXR1cm4gdGhpcy5fd2ViSG9vayA/IHRoaXMuX3dlYkhvb2suaXNPcGVuKCkgOiBmYWxzZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYW4gdXBkYXRlOyBlbWl0dGluZyB0aGUgcHJvcGVyIGV2ZW50cyBhbmQgZXhlY3V0aW5nIHJlZ2V4cFxuICAgKiBjYWxsYmFja3MuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBzaG91bGQgeW91IGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAqIHdheSB0byBmZXRjaCB1cGRhdGVzLCBvdGhlciB0aGFuIHRob3NlIHByb3ZpZGVkIGJ5IFRlbGVncmFtQm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHVwZGF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXBkYXRlXG4gICAqL1xuICBwcm9jZXNzVXBkYXRlKHVwZGF0ZSkge1xuICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSAlaicsIHVwZGF0ZSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHVwZGF0ZS5tZXNzYWdlO1xuICAgIGNvbnN0IGVkaXRlZE1lc3NhZ2UgPSB1cGRhdGUuZWRpdGVkX21lc3NhZ2U7XG4gICAgY29uc3QgY2hhbm5lbFBvc3QgPSB1cGRhdGUuY2hhbm5lbF9wb3N0O1xuICAgIGNvbnN0IGVkaXRlZENoYW5uZWxQb3N0ID0gdXBkYXRlLmVkaXRlZF9jaGFubmVsX3Bvc3Q7XG4gICAgY29uc3QgYnVzaW5lc3NDb25uZWN0aW9uID0gdXBkYXRlLmJ1c2luZXNzX2Nvbm5lY3Rpb247XG4gICAgY29uc3QgYnVzaW5lc3NzTWVzc2FnZSA9IHVwZGF0ZS5idXNpbmVzc19tZXNzYWdlO1xuICAgIGNvbnN0IGVkaXRlZEJ1c2luZXNzTWVzc2FnZSA9IHVwZGF0ZS5lZGl0ZWRfYnVzaW5lc3NfbWVzc2FnZTtcbiAgICBjb25zdCBkZWxldGVkQnVzaW5lc3NNZXNzYWdlID0gdXBkYXRlLmRlbGV0ZWRfYnVzaW5lc3NfbWVzc2FnZXM7XG4gICAgY29uc3QgbWVzc2FnZVJlYWN0aW9uID0gdXBkYXRlLm1lc3NhZ2VfcmVhY3Rpb247XG4gICAgY29uc3QgbWVzc2FnZVJlYWN0aW9uQ291bnQgPSB1cGRhdGUubWVzc2FnZV9yZWFjdGlvbl9jb3VudDtcbiAgICBjb25zdCBpbmxpbmVRdWVyeSA9IHVwZGF0ZS5pbmxpbmVfcXVlcnk7XG4gICAgY29uc3QgY2hvc2VuSW5saW5lUmVzdWx0ID0gdXBkYXRlLmNob3Nlbl9pbmxpbmVfcmVzdWx0O1xuICAgIGNvbnN0IGNhbGxiYWNrUXVlcnkgPSB1cGRhdGUuY2FsbGJhY2tfcXVlcnk7XG4gICAgY29uc3Qgc2hpcHBpbmdRdWVyeSA9IHVwZGF0ZS5zaGlwcGluZ19xdWVyeTtcbiAgICBjb25zdCBwcmVDaGVja291dFF1ZXJ5ID0gdXBkYXRlLnByZV9jaGVja291dF9xdWVyeTtcbiAgICBjb25zdCBwb2xsID0gdXBkYXRlLnBvbGw7XG4gICAgY29uc3QgcG9sbEFuc3dlciA9IHVwZGF0ZS5wb2xsX2Fuc3dlcjtcbiAgICBjb25zdCBteUNoYXRNZW1iZXIgPSB1cGRhdGUubXlfY2hhdF9tZW1iZXI7XG4gICAgY29uc3QgY2hhdE1lbWJlciA9IHVwZGF0ZS5jaGF0X21lbWJlcjtcbiAgICBjb25zdCBjaGF0Sm9pblJlcXVlc3QgPSB1cGRhdGUuY2hhdF9qb2luX3JlcXVlc3Q7XG4gICAgY29uc3QgY2hhdEJvb3N0ID0gdXBkYXRlLmNoYXRfYm9vc3Q7XG4gICAgY29uc3QgcmVtb3ZlZENoYXRCb29zdCA9IHVwZGF0ZS5yZW1vdmVkX2NoYXRfYm9vc3Q7XG5cblxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgbWVzc2FnZSAlaicsIG1lc3NhZ2UpO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICAgIG1ldGFkYXRhLnR5cGUgPSBUZWxlZ3JhbUJvdC5tZXNzYWdlVHlwZXMuZmluZCgobWVzc2FnZVR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VbbWVzc2FnZVR5cGVdO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlLCBtZXRhZGF0YSk7XG4gICAgICBpZiAobWV0YWRhdGEudHlwZSkge1xuICAgICAgICBkZWJ1ZygnRW1pdHRpbmcgJXM6ICVqJywgbWV0YWRhdGEudHlwZSwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdChtZXRhZGF0YS50eXBlLCBtZXNzYWdlLCBtZXRhZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS50ZXh0KSB7XG4gICAgICAgIGRlYnVnKCdUZXh0IG1lc3NhZ2UnKTtcbiAgICAgICAgdGhpcy5fdGV4dFJlZ2V4cENhbGxiYWNrcy5zb21lKHJlZyA9PiB7XG4gICAgICAgICAgZGVidWcoJ01hdGNoaW5nICVzIHdpdGggJXMnLCBtZXNzYWdlLnRleHQsIHJlZy5yZWdleHApO1xuXG4gICAgICAgICAgaWYgKCEocmVnLnJlZ2V4cCBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHJlZy5yZWdleHAgPSBuZXcgUmVnRXhwKHJlZy5yZWdleHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZy5yZWdleHAuZXhlYyhtZXNzYWdlLnRleHQpO1xuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJlc2V0IGluZGV4IHNvIHdlIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlZ2V4IGVhY2ggdGltZVxuICAgICAgICAgIHJlZy5yZWdleHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICBkZWJ1ZygnTWF0Y2hlcyAlcycsIHJlZy5yZWdleHApO1xuICAgICAgICAgIHJlZy5jYWxsYmFjayhtZXNzYWdlLCByZXN1bHQpO1xuICAgICAgICAgIC8vIHJldHVybmluZyB0cnV0aHkgdmFsdWUgZXhpdHMgLnNvbWVcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm9ubHlGaXJzdE1hdGNoO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnJlcGx5X3RvX21lc3NhZ2UpIHtcbiAgICAgICAgLy8gT25seSBjYWxsYmFja3Mgd2FpdGluZyBmb3IgdGhpcyBtZXNzYWdlXG4gICAgICAgIHRoaXMuX3JlcGx5TGlzdGVuZXJzLmZvckVhY2gocmVwbHkgPT4ge1xuICAgICAgICAgIC8vIE1lc3NhZ2UgZnJvbSB0aGUgc2FtZSBjaGF0XG4gICAgICAgICAgaWYgKHJlcGx5LmNoYXRJZCA9PT0gbWVzc2FnZS5jaGF0LmlkKSB7XG4gICAgICAgICAgICAvLyBSZXNwb25kaW5nIHRvIHRoYXQgbWVzc2FnZVxuICAgICAgICAgICAgaWYgKHJlcGx5Lm1lc3NhZ2VJZCA9PT0gbWVzc2FnZS5yZXBseV90b19tZXNzYWdlLm1lc3NhZ2VfaWQpIHtcbiAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgICByZXBseS5jYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWRpdGVkTWVzc2FnZSkge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIGVkaXRlZF9tZXNzYWdlICVqJywgZWRpdGVkTWVzc2FnZSk7XG4gICAgICB0aGlzLmVtaXQoJ2VkaXRlZF9tZXNzYWdlJywgZWRpdGVkTWVzc2FnZSk7XG4gICAgICBpZiAoZWRpdGVkTWVzc2FnZS50ZXh0KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX21lc3NhZ2VfdGV4dCcsIGVkaXRlZE1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRlZE1lc3NhZ2UuY2FwdGlvbikge1xuICAgICAgICB0aGlzLmVtaXQoJ2VkaXRlZF9tZXNzYWdlX2NhcHRpb24nLCBlZGl0ZWRNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxQb3N0KSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgY2hhbm5lbF9wb3N0ICVqJywgY2hhbm5lbFBvc3QpO1xuICAgICAgdGhpcy5lbWl0KCdjaGFubmVsX3Bvc3QnLCBjaGFubmVsUG9zdCk7XG4gICAgfSBlbHNlIGlmIChlZGl0ZWRDaGFubmVsUG9zdCkge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIGVkaXRlZF9jaGFubmVsX3Bvc3QgJWonLCBlZGl0ZWRDaGFubmVsUG9zdCk7XG4gICAgICB0aGlzLmVtaXQoJ2VkaXRlZF9jaGFubmVsX3Bvc3QnLCBlZGl0ZWRDaGFubmVsUG9zdCk7XG4gICAgICBpZiAoZWRpdGVkQ2hhbm5lbFBvc3QudGV4dCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2VkaXRlZF9jaGFubmVsX3Bvc3RfdGV4dCcsIGVkaXRlZENoYW5uZWxQb3N0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0ZWRDaGFubmVsUG9zdC5jYXB0aW9uKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX2NoYW5uZWxfcG9zdF9jYXB0aW9uJywgZWRpdGVkQ2hhbm5lbFBvc3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYnVzaW5lc3NDb25uZWN0aW9uKSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgYnVzaW5lc3NfY29ubmVjdGlvbiAlaicsIGJ1c2luZXNzQ29ubmVjdGlvbik7XG4gICAgICB0aGlzLmVtaXQoJ2J1c2luZXNzX2Nvbm5lY3Rpb24nLCBidXNpbmVzc0Nvbm5lY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoYnVzaW5lc3NzTWVzc2FnZSkge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIGJ1c2luZXNzX21lc3NhZ2UgJWonLCBidXNpbmVzc3NNZXNzYWdlKTtcbiAgICAgIHRoaXMuZW1pdCgnYnVzaW5lc3NfbWVzc2FnZScsIGJ1c2luZXNzc01lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAoZWRpdGVkQnVzaW5lc3NNZXNzYWdlKSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgZWRpdGVkX2J1c2luZXNzX21lc3NhZ2UgJWonLCBlZGl0ZWRCdXNpbmVzc01lc3NhZ2UpO1xuICAgICAgdGhpcy5lbWl0KCdlZGl0ZWRfYnVzaW5lc3NfbWVzc2FnZScsIGVkaXRlZEJ1c2luZXNzTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChkZWxldGVkQnVzaW5lc3NNZXNzYWdlKSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgZGVsZXRlZF9idXNpbmVzc19tZXNzYWdlcyAlaicsIGRlbGV0ZWRCdXNpbmVzc01lc3NhZ2UpO1xuICAgICAgdGhpcy5lbWl0KCdkZWxldGVkX2J1c2luZXNzX21lc3NhZ2VzJywgZGVsZXRlZEJ1c2luZXNzTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlUmVhY3Rpb24pIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBtZXNzYWdlX3JlYWN0aW9uICVqJywgbWVzc2FnZVJlYWN0aW9uKTtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZV9yZWFjdGlvbicsIG1lc3NhZ2VSZWFjdGlvbik7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlUmVhY3Rpb25Db3VudCkge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIG1lc3NhZ2VfcmVhY3Rpb25fY291bnQgJWonLCBtZXNzYWdlUmVhY3Rpb25Db3VudCk7XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2VfcmVhY3Rpb25fY291bnQnLCBtZXNzYWdlUmVhY3Rpb25Db3VudCk7XG4gICAgfSBlbHNlIGlmIChpbmxpbmVRdWVyeSkge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIGlubGluZV9xdWVyeSAlaicsIGlubGluZVF1ZXJ5KTtcbiAgICAgIHRoaXMuZW1pdCgnaW5saW5lX3F1ZXJ5JywgaW5saW5lUXVlcnkpO1xuICAgIH0gZWxzZSBpZiAoY2hvc2VuSW5saW5lUmVzdWx0KSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgY2hvc2VuX2lubGluZV9yZXN1bHQgJWonLCBjaG9zZW5JbmxpbmVSZXN1bHQpO1xuICAgICAgdGhpcy5lbWl0KCdjaG9zZW5faW5saW5lX3Jlc3VsdCcsIGNob3NlbklubGluZVJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChjYWxsYmFja1F1ZXJ5KSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgY2FsbGJhY2tfcXVlcnkgJWonLCBjYWxsYmFja1F1ZXJ5KTtcbiAgICAgIHRoaXMuZW1pdCgnY2FsbGJhY2tfcXVlcnknLCBjYWxsYmFja1F1ZXJ5KTtcbiAgICB9IGVsc2UgaWYgKHNoaXBwaW5nUXVlcnkpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBzaGlwcGluZ19xdWVyeSAlaicsIHNoaXBwaW5nUXVlcnkpO1xuICAgICAgdGhpcy5lbWl0KCdzaGlwcGluZ19xdWVyeScsIHNoaXBwaW5nUXVlcnkpO1xuICAgIH0gZWxzZSBpZiAocHJlQ2hlY2tvdXRRdWVyeSkge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIHByZV9jaGVja291dF9xdWVyeSAlaicsIHByZUNoZWNrb3V0UXVlcnkpO1xuICAgICAgdGhpcy5lbWl0KCdwcmVfY2hlY2tvdXRfcXVlcnknLCBwcmVDaGVja291dFF1ZXJ5KTtcbiAgICB9IGVsc2UgaWYgKHBvbGwpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBwb2xsICVqJywgcG9sbCk7XG4gICAgICB0aGlzLmVtaXQoJ3BvbGwnLCBwb2xsKTtcbiAgICB9IGVsc2UgaWYgKHBvbGxBbnN3ZXIpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBwb2xsX2Fuc3dlciAlaicsIHBvbGxBbnN3ZXIpO1xuICAgICAgdGhpcy5lbWl0KCdwb2xsX2Fuc3dlcicsIHBvbGxBbnN3ZXIpO1xuICAgIH0gZWxzZSBpZiAoY2hhdE1lbWJlcikge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIGNoYXRfbWVtYmVyICVqJywgY2hhdE1lbWJlcik7XG4gICAgICB0aGlzLmVtaXQoJ2NoYXRfbWVtYmVyJywgY2hhdE1lbWJlcik7XG4gICAgfSBlbHNlIGlmIChteUNoYXRNZW1iZXIpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBteV9jaGF0X21lbWJlciAlaicsIG15Q2hhdE1lbWJlcik7XG4gICAgICB0aGlzLmVtaXQoJ215X2NoYXRfbWVtYmVyJywgbXlDaGF0TWVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKGNoYXRKb2luUmVxdWVzdCkge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIG15X2NoYXRfbWVtYmVyICVqJywgY2hhdEpvaW5SZXF1ZXN0KTtcbiAgICAgIHRoaXMuZW1pdCgnY2hhdF9qb2luX3JlcXVlc3QnLCBjaGF0Sm9pblJlcXVlc3QpO1xuICAgIH0gZWxzZSBpZiAoY2hhdEJvb3N0KSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgY2hhdF9ib29zdCAlaicsIGNoYXRCb29zdCk7XG4gICAgICB0aGlzLmVtaXQoJ2NoYXRfYm9vc3QnLCBjaGF0Qm9vc3QpO1xuICAgIH0gZWxzZSBpZiAocmVtb3ZlZENoYXRCb29zdCkge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIHJlbW92ZWRfY2hhdF9ib29zdCAlaicsIHJlbW92ZWRDaGF0Qm9vc3QpO1xuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVkX2NoYXRfYm9vc3QnLCByZW1vdmVkQ2hhdEJvb3N0KTtcbiAgICB9XG4gIH1cblxuICAvKiogU3RhcnQgVGVsZWdyYW0gQm90IEFQSSBtZXRob2RzICovXG5cbiAgLyoqXG4gICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlY2VpdmUgaW5jb21pbmcgdXBkYXRlcyB1c2luZyBsb25nIHBvbGxpbmcuXG4gICogVGhpcyBtZXRob2QgaGFzIGFuIFtvbGRlciwgY29tcGF0aWJsZSBzaWduYXR1cmVdW2dldFVwZGF0ZXMtdjAuMjUuMF1cbiAgKiB0aGF0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuXG4gICpcbiAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXR1cGRhdGVzXG4gICovXG4gIGdldFVwZGF0ZXMoZm9ybSA9IHt9KSB7XG4gICAgLyogVGhlIG9sZGVyIG1ldGhvZCBzaWduYXR1cmUgd2FzIGdldFVwZGF0ZXModGltZW91dCwgbGltaXQsIG9mZnNldCkuXG4gICAgICogV2UgbmVlZCB0byBlbnN1cmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICAgKiBjb25zaXN0ZW5jeSBvZiB0aGUgbWV0aG9kIHNpZ25hdHVyZXMgdGhyb3VnaG91dCB0aGUgbGlicmFyeSAqL1xuICAgIGlmICh0eXBlb2YgZm9ybSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgIGRlcHJlY2F0ZSgnVGhlIG1ldGhvZCBzaWduYXR1cmUgZ2V0VXBkYXRlcyh0aW1lb3V0LCBsaW1pdCwgb2Zmc2V0KSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYwLjI1LjAnKTtcbiAgICAgIGZvcm0gPSB7XG4gICAgICAgIHRpbWVvdXQ6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgbGltaXQ6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgb2Zmc2V0OiBhcmd1bWVudHNbMl0sXG4gICAgICB9O1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldFVwZGF0ZXMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSBhbiB1cmwgdG8gcmVjZWl2ZSBpbmNvbWluZyB1cGRhdGVzIHZpYSBhbiBvdXRnb2luZyB3ZWJIb29rLlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgYW4gW29sZGVyLCBjb21wYXRpYmxlIHNpZ25hdHVyZV1bc2V0V2ViSG9vay12MC4yNS4wXVxuICAgKiB0aGF0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdXJsIFVSTCB3aGVyZSBUZWxlZ3JhbSB3aWxsIG1ha2UgSFRUUCBQb3N0LiBMZWF2ZSBlbXB0eSB0b1xuICAgKiBkZWxldGUgd2ViSG9vay5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfSBbb3B0aW9ucy5jZXJ0aWZpY2F0ZV0gUEVNIGNlcnRpZmljYXRlIGtleSAocHVibGljKS5cbiAgICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5zZWNyZXRfdG9rZW5dIE9wdGlvbmFsIHNlY3JldCB0b2tlbiB0byBiZSBzZW50IGluIGEgaGVhZGVyIGBYLVRlbGVncmFtLUJvdC1BcGktU2VjcmV0LVRva2VuYCBpbiBldmVyeSB3ZWJob29rIHJlcXVlc3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXR3ZWJob29rXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgKi9cbiAgc2V0V2ViSG9vayh1cmwsIG9wdGlvbnMgPSB7fSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIC8qIFRoZSBvbGRlciBtZXRob2Qgc2lnbmF0dXJlIHdhcyBzZXRXZWJIb29rKHVybCwgY2VydCkuXG4gICAgICogV2UgbmVlZCB0byBlbnN1cmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICAgKiBjb25zaXN0ZW5jeSBvZiB0aGUgbWV0aG9kIHNpZ25hdHVyZXMgdGhyb3VnaG91dCB0aGUgbGlicmFyeSAqL1xuICAgIGxldCBjZXJ0O1xuICAgIC8vIE5vdGU6ICdvcHRpb25zJyBjb3VsZCBiZSBhbiBvYmplY3QsIGlmIGEgc3RyZWFtIHdhcyBwcm92aWRlZCAoaW4gcGxhY2Ugb2YgJ2NlcnQnKVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyBpbnN0YW5jZW9mIHN0cmVhbS5TdHJlYW0pIHtcbiAgICAgIGRlcHJlY2F0ZSgnVGhlIG1ldGhvZCBzaWduYXR1cmUgc2V0V2ViSG9vayh1cmwsIGNlcnQpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjAuMjUuMCcpO1xuICAgICAgY2VydCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB9IGVsc2Uge1xuICAgICAgY2VydCA9IG9wdGlvbnMuY2VydGlmaWNhdGU7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zLFxuICAgIH07XG4gICAgb3B0cy5xcy51cmwgPSB1cmw7XG5cbiAgICBpZiAoY2VydCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgnY2VydGlmaWNhdGUnLCBjZXJ0LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgICAgb3B0cy5xcy5jZXJ0aWZpY2F0ZSA9IHNlbmREYXRhWzFdO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0V2ViSG9vaycsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZW1vdmUgd2ViaG9vayBpbnRlZ3JhdGlvbiBpZiB5b3UgZGVjaWRlIHRvXG4gICAqIHN3aXRjaCBiYWNrIHRvIGdldFVwZGF0ZXMuIFJldHVybnMgVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZXdlYmhvb2tcbiAgICovXG4gIGRlbGV0ZVdlYkhvb2soZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZVdlYmhvb2snLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBjdXJyZW50IHdlYmhvb2sgc3RhdHVzLlxuICAgKiBPbiBzdWNjZXNzLCByZXR1cm5zIGEgW1dlYmhvb2tJbmZvXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3dlYmhvb2tpbmZvKSBvYmplY3QuXG4gICAqIElmIHRoZSBib3QgaXMgdXNpbmcgZ2V0VXBkYXRlcywgd2lsbCByZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlXG4gICAqIHVybCBmaWVsZCBlbXB0eS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXR3ZWJob29raW5mb1xuICAgKi9cbiAgZ2V0V2ViSG9va0luZm8oZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldFdlYmhvb2tJbmZvJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIG1ldGhvZCBmb3IgdGVzdGluZyB5b3VyIGJvdCdzIGF1dGhlbnRpY2F0aW9uIHRva2VuLiBSZXF1aXJlcyBubyBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGJvdCBpbiBmb3JtIG9mIGEgW1VzZXJdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXNlcikgb2JqZWN0LlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0bWVcbiAgICovXG4gIGdldE1lKGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRNZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBsb2cgb3V0IHlvdXIgYm90IGZyb20gdGhlIGNsb3VkIEJvdCBBUEkgc2VydmVyIGJlZm9yZSBsYXVuY2hpbmcgdGhlIGJvdCBsb2NhbGx5LlxuICAgKiBZb3UgbXVzdCBsb2cgb3V0IHRoZSBib3QgYmVmb3JlIHJ1bm5pbmcgaXQgbG9jYWxseSwgb3RoZXJ3aXNlIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBib3Qgd2lsbCByZWNlaXZlIHVwZGF0ZXMuXG4gICAqIEFmdGVyIGEgc3VjY2Vzc2Z1bCBjYWxsLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBsb2cgaW4gYWdhaW4gdXNpbmcgdGhlIHNhbWUgdG9rZW4gZm9yIDEwIG1pbnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNsb2dvdXRcbiAgICovXG4gIGxvZ091dChmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnbG9nT3V0JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNsb3NlIHRoZSBib3QgaW5zdGFuY2UgYmVmb3JlIG1vdmluZyBpdCBmcm9tIG9uZSBsb2NhbCBzZXJ2ZXIgdG8gYW5vdGhlci5cbiAgICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZXJyb3IgNDI5IGluIHRoZSBmaXJzdCAxMCBtaW51dGVzIGFmdGVyIHRoZSBib3QgaXMgbGF1bmNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjbG9zZVxuICAgKi9cbiAgY2xvc2UoZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Nsb3NlJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgdGV4dCBtZXNzYWdlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgVGV4dCBvZiB0aGUgbWVzc2FnZSB0byBiZSBzZW50XG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRtZXNzYWdlXG4gICAqL1xuICBzZW5kTWVzc2FnZShjaGF0SWQsIHRleHQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnRleHQgPSB0ZXh0O1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kTWVzc2FnZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3J3YXJkIG1lc3NhZ2VzIG9mIGFueSBraW5kLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBmcm9tQ2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCB3aGVyZSB0aGVcbiAgICogb3JpZ2luYWwgbWVzc2FnZSB3YXMgc2VudCAob3IgY2hhbm5lbCB1c2VybmFtZSBpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gbWVzc2FnZUlkICBVbmlxdWUgbWVzc2FnZSBpZGVudGlmaWVyIGluIHRoZSBjaGF0IHNwZWNpZmllZCBpbiBmcm9tQ2hhdElkXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZm9yd2FyZG1lc3NhZ2VcbiAgICovXG4gIGZvcndhcmRNZXNzYWdlKGNoYXRJZCwgZnJvbUNoYXRJZCwgbWVzc2FnZUlkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5mcm9tX2NoYXRfaWQgPSBmcm9tQ2hhdElkO1xuICAgIGZvcm0ubWVzc2FnZV9pZCA9IG1lc3NhZ2VJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZm9yd2FyZE1lc3NhZ2UnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGZvcndhcmQgbXVsdGlwbGUgbWVzc2FnZXMgb2YgYW55IGtpbmQuXG4gICAqIElmIHNvbWUgb2YgdGhlIHNwZWNpZmllZCBtZXNzYWdlcyBjYW4ndCBiZSBmb3VuZCBvciBmb3J3YXJkZWQsIHRoZXkgYXJlIHNraXBwZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGZyb21DaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IHdoZXJlIHRoZVxuICAgKiBvcmlnaW5hbCBtZXNzYWdlIHdhcyBzZW50IChvciBjaGFubmVsIHVzZXJuYW1lIGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtBcnJheTxOdW1iZXJ8U3RyaW5nPn0gbWVzc2FnZUlkcyBJZGVudGlmaWVycyBvZiAxLTEwMCBtZXNzYWdlcyBpbiB0aGUgY2hhdCBmcm9tX2NoYXRfaWQgdG8gZm9yd2FyZC5cbiAgICogVGhlIGlkZW50aWZpZXJzIG11c3QgYmUgc3BlY2lmaWVkIGluIGEgc3RyaWN0bHkgaW5jcmVhc2luZyBvcmRlci5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEFuIGFycmF5IG9mIE1lc3NhZ2VJZCBvZiB0aGUgc2VudCBtZXNzYWdlcyBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNmb3J3YXJkbWVzc2FnZXNcbiAgICovXG4gIGZvcndhcmRNZXNzYWdlcyhjaGF0SWQsIGZyb21DaGF0SWQsIG1lc3NhZ2VJZHMsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLmZyb21fY2hhdF9pZCA9IGZyb21DaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX2lkcyA9IG1lc3NhZ2VJZHM7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2ZvcndhcmRNZXNzYWdlcycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3B5IG1lc3NhZ2VzIG9mIGFueSBraW5kLiAqKlNlcnZpY2UgbWVzc2FnZXMgYW5kIGludm9pY2UgbWVzc2FnZXMgY2FuJ3QgYmUgY29waWVkLioqXG4gICAqIFRoZSBtZXRob2QgaXMgYW5hbG9nb3VzIHRvIHRoZSBtZXRob2QgZm9yd2FyZE1lc3NhZ2VzLCBidXQgdGhlIGNvcGllZCBtZXNzYWdlIGRvZXNuJ3RcbiAgICogaGF2ZSBhIGxpbmsgdG8gdGhlIG9yaWdpbmFsIG1lc3NhZ2UuXG4gICAqIFJldHVybnMgdGhlIE1lc3NhZ2VJZCBvZiB0aGUgc2VudCBtZXNzYWdlIG9uIHN1Y2Nlc3MuXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgICAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBmcm9tQ2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCB3aGVyZSB0aGVcbiAgICogb3JpZ2luYWwgbWVzc2FnZSB3YXMgc2VudFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBtZXNzYWdlSWQgIFVuaXF1ZSBtZXNzYWdlIGlkZW50aWZpZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBbTWVzc2FnZUlkXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2VpZCkgb2YgdGhlIHNlbnQgbWVzc2FnZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjb3B5bWVzc2FnZVxuICAgKi9cbiAgY29weU1lc3NhZ2UoY2hhdElkLCBmcm9tQ2hhdElkLCBtZXNzYWdlSWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLmZyb21fY2hhdF9pZCA9IGZyb21DaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX2lkID0gbWVzc2FnZUlkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjb3B5TWVzc2FnZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY29weSBtZXNzYWdlcyBvZiBhbnkga2luZC4gSWYgc29tZSBvZiB0aGUgc3BlY2lmaWVkIG1lc3NhZ2VzIGNhbid0IGJlIGZvdW5kIG9yIGNvcGllZCwgdGhleSBhcmUgc2tpcHBlZC5cbiAgICogU2VydmljZSBtZXNzYWdlcywgZ2l2ZWF3YXkgbWVzc2FnZXMsIGdpdmVhd2F5IHdpbm5lcnMgbWVzc2FnZXMsIGFuZCBpbnZvaWNlIG1lc3NhZ2VzIGNhbid0IGJlIGNvcGllZC5cbiAgICogUmV0dXJucyB0aGUgTWVzc2FnZUlkIG9mIHRoZSBzZW50IG1lc3NhZ2Ugb24gc3VjY2Vzcy5cbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXRcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gZnJvbUNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNoYXQgd2hlcmUgdGhlXG4gICAqIG9yaWdpbmFsIG1lc3NhZ2Ugd2FzIHNlbnRcbiAgICogQHBhcmFtICB7QXJyYXl9IG1lc3NhZ2VJZHMgIElkZW50aWZpZXJzIG9mIDEtMTAwIG1lc3NhZ2VzIGluIHRoZSBjaGF0IGZyb21fY2hhdF9pZCB0byBjb3B5LlxuICAgKiBUaGUgaWRlbnRpZmllcnMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gYSBzdHJpY3RseSBpbmNyZWFzaW5nIG9yZGVyLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQW4gYXJyYXkgb2YgTWVzc2FnZUlkIG9mIHRoZSBzZW50IG1lc3NhZ2VzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjb3B5bWVzc2FnZXNcbiAgICovXG4gIGNvcHlNZXNzYWdlcyhjaGF0SWQsIGZyb21DaGF0SWQsIG1lc3NhZ2VJZHMsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLmZyb21fY2hhdF9pZCA9IGZyb21DaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX2lkcyA9IHN0cmluZ2lmeShtZXNzYWdlSWRzKTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY29weU1lc3NhZ2VzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgcGhvdG9cbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gcGhvdG8gQSBmaWxlIHBhdGggb3IgYSBTdHJlYW0uIENhblxuICAgKiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHBob3RvXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgKi9cbiAgc2VuZFBob3RvKGNoYXRJZCwgcGhvdG8sIG9wdGlvbnMgPSB7fSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9ucyxcbiAgICB9O1xuICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgncGhvdG8nLCBwaG90bywgZmlsZU9wdGlvbnMpO1xuICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgb3B0cy5xcy5waG90byA9IHNlbmREYXRhWzFdO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZFBob3RvJywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgKiBTZW5kIGF1ZGlvXG4gICpcbiAgKiAqKllvdXIgYXVkaW8gbXVzdCBiZSBpbiB0aGUgLk1QMyBvciAuTTRBIGZvcm1hdC4qKlxuICAqXG4gICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBhdWRpbyBBIGZpbGUgcGF0aCwgU3RyZWFtIG9yIEJ1ZmZlci5cbiAgKiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRhdWRpb1xuICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAqL1xuICBzZW5kQXVkaW8oY2hhdElkLCBhdWRpbywgb3B0aW9ucyA9IHt9LCBmaWxlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfTtcblxuICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdhdWRpbycsIGF1ZGlvLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzLmF1ZGlvID0gc2VuZERhdGFbMV07XG4gICAgICB0aGlzLl9maXhBZGRGaWxlVGh1bWJuYWlsKG9wdGlvbnMsIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kQXVkaW8nLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAqIFNlbmQgRG9jdW1lbnRcbiAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IGRvYyBBIGZpbGUgcGF0aCwgU3RyZWFtIG9yIEJ1ZmZlci5cbiAgKiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICogQHJldHVybiB7UHJvbWlzZX0gIE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kRG9jdW1lbnRcbiAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgKi9cbiAgc2VuZERvY3VtZW50KGNoYXRJZCwgZG9jLCBvcHRpb25zID0ge30sIGZpbGVPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9O1xuICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgnZG9jdW1lbnQnLCBkb2MsIGZpbGVPcHRpb25zKTtcbiAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgIG9wdHMucXMuZG9jdW1lbnQgPSBzZW5kRGF0YVsxXTtcbiAgICAgIHRoaXMuX2ZpeEFkZEZpbGVUaHVtYm5haWwob3B0aW9ucywgb3B0cyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmREb2N1bWVudCcsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIHZpZGVvIGZpbGVzLCAqKlRlbGVncmFtIGNsaWVudHMgc3VwcG9ydCBtcDQgdmlkZW9zKiogKG90aGVyIGZvcm1hdHMgbWF5IGJlIHNlbnQgYXMgRG9jdW1lbnQpLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSB2aWRlbyBBIGZpbGUgcGF0aCBvciBTdHJlYW0uXG4gICAqIENhbiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmR2aWRlb1xuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgICovXG4gIHNlbmRWaWRlbyhjaGF0SWQsIHZpZGVvLCBvcHRpb25zID0ge30sIGZpbGVPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9O1xuICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgndmlkZW8nLCB2aWRlbywgZmlsZU9wdGlvbnMpO1xuICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgb3B0cy5xcy52aWRlbyA9IHNlbmREYXRhWzFdO1xuICAgICAgdGhpcy5fZml4QWRkRmlsZVRodW1ibmFpbChvcHRpb25zLCBvcHRzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRWaWRlbycsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGFuaW1hdGlvbiBmaWxlcyAoR0lGIG9yIEguMjY0L01QRUctNCBBVkMgdmlkZW8gd2l0aG91dCBzb3VuZCkuXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IGFuaW1hdGlvbiBBIGZpbGUgcGF0aCwgU3RyZWFtIG9yIEJ1ZmZlci5cbiAgICogQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGFuaW1hdGlvblxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgICovXG4gIHNlbmRBbmltYXRpb24oY2hhdElkLCBhbmltYXRpb24sIG9wdGlvbnMgPSB7fSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9uc1xuICAgIH07XG4gICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdhbmltYXRpb24nLCBhbmltYXRpb24sIGZpbGVPcHRpb25zKTtcbiAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgIG9wdHMucXMuYW5pbWF0aW9uID0gc2VuZERhdGFbMV07XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kQW5pbWF0aW9uJywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB2b2ljZVxuICAgKlxuICAgKiAqKllvdXIgYXVkaW8gbXVzdCBiZSBpbiBhbiAuT0dHIGZpbGUgZW5jb2RlZCB3aXRoIE9QVVMqKiwgb3IgaW4gLk1QMyBmb3JtYXQsIG9yIGluIC5NNEEgZm9ybWF0IChvdGhlciBmb3JtYXRzIG1heSBiZSBzZW50IGFzIEF1ZGlvIG9yIERvY3VtZW50KVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSB2b2ljZSBBIGZpbGUgcGF0aCwgU3RyZWFtIG9yIEJ1ZmZlci5cbiAgICogQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHZvaWNlXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgKi9cbiAgc2VuZFZvaWNlKGNoYXRJZCwgdm9pY2UsIG9wdGlvbnMgPSB7fSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9uc1xuICAgIH07XG4gICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCd2b2ljZScsIHZvaWNlLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzLnZvaWNlID0gc2VuZERhdGFbMV07XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kVm9pY2UnLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCB2aWRlbyBtZXNzYWdlc1xuICAgKiBUZWxlZ3JhbSBjbGllbnRzIHN1cHBvcnQgKipyb3VuZGVkIHNxdWFyZSBNUEVHNCB2aWRlb3MqKiBvZiB1cCB0byAxIG1pbnV0ZSBsb25nLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSB2aWRlb05vdGUgQSBmaWxlIHBhdGggb3IgU3RyZWFtLlxuICAgKiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAqIEBpbmZvIFRoZSBsZW5ndGggcGFyYW1ldGVyIGlzIGFjdHVhbGx5IG9wdGlvbmFsLiBIb3dldmVyLCB0aGUgQVBJIChhdCB0aW1lIG9mIHdyaXRpbmcpIHJlcXVpcmVzIHlvdSB0byBhbHdheXMgcHJvdmlkZSBpdCB1bnRpbCBpdCBpcyBmaXhlZC5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmR2aWRlb25vdGVcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzXG4gICovXG4gIHNlbmRWaWRlb05vdGUoY2hhdElkLCB2aWRlb05vdGUsIG9wdGlvbnMgPSB7fSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9uc1xuICAgIH07XG4gICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCd2aWRlb19ub3RlJywgdmlkZW9Ob3RlLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzLnZpZGVvX25vdGUgPSBzZW5kRGF0YVsxXTtcbiAgICAgIHRoaXMuX2ZpeEFkZEZpbGVUaHVtYm5haWwob3B0aW9ucywgb3B0cyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kVmlkZW9Ob3RlJywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgYSBncm91cCBvZiBwaG90b3Mgb3IgdmlkZW9zIGFzIGFuIGFsYnVtLlxuICAgKlxuICAgKiAqKkRvY3VtZW50cyBhbmQgYXVkaW8gZmlsZXMgY2FuIGJlIG9ubHkgZ3JvdXBlZCBpbiBhbiBhbGJ1bSB3aXRoIG1lc3NhZ2VzIG9mIHRoZSBzYW1lIHR5cGUqKlxuICAgKlxuICAgKiBJZiB5b3Ugd2lzaCB0byBbc3BlY2lmeSBmaWxlIG9wdGlvbnNdKGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXMpLFxuICAgKiBhZGQgYSBgZmlsZU9wdGlvbnNgIHByb3BlcnR5IHRvIHRoZSB0YXJnZXQgaW5wdXQgaW4gYG1lZGlhYC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtBcnJheX0gbWVkaWEgQSBKU09OLXNlcmlhbGl6ZWQgYXJyYXkgZGVzY3JpYmluZyBwaG90b3MgYW5kIHZpZGVvcyB0byBiZSBzZW50LCBtdXN0IGluY2x1ZGUgMuKAkzEwIGl0ZW1zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBhbiBhcnJheSBvZiB0aGUgc2VudCBbTWVzc2FnZXNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSlcbiAgICogaXMgcmV0dXJuZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kbWVkaWFncm91cFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgICovXG4gIHNlbmRNZWRpYUdyb3VwKGNoYXRJZCwgbWVkaWEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9ucyxcbiAgICB9O1xuICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcblxuICAgIG9wdHMuZm9ybURhdGEgPSB7fTtcbiAgICBjb25zdCBpbnB1dE1lZGlhID0gW107XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIG1lZGlhKSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgaW5wdXQpO1xuICAgICAgZGVsZXRlIHBheWxvYWQubWVkaWE7XG4gICAgICBkZWxldGUgcGF5bG9hZC5maWxlT3B0aW9ucztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGF0dGFjaE5hbWUgPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICBjb25zdCBbZm9ybURhdGEsIGZpbGVJZF0gPSB0aGlzLl9mb3JtYXRTZW5kRGF0YShhdHRhY2hOYW1lLCBpbnB1dC5tZWRpYSwgaW5wdXQuZmlsZU9wdGlvbnMpO1xuICAgICAgICBpZiAoZm9ybURhdGEpIHtcbiAgICAgICAgICBvcHRzLmZvcm1EYXRhW2F0dGFjaE5hbWVdID0gZm9ybURhdGFbYXR0YWNoTmFtZV07XG4gICAgICAgICAgcGF5bG9hZC5tZWRpYSA9IGBhdHRhY2g6Ly8ke2F0dGFjaE5hbWV9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXlsb2FkLm1lZGlhID0gZmlsZUlkO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgICAgaW5wdXRNZWRpYS5wdXNoKHBheWxvYWQpO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgb3B0cy5xcy5tZWRpYSA9IHN0cmluZ2lmeShpbnB1dE1lZGlhKTtcblxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kTWVkaWFHcm91cCcsIG9wdHMpO1xuICB9XG5cblxuICAvKipcbiAgICogU2VuZCBsb2NhdGlvbi5cbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgcG9pbnQgb24gdGhlIG1hcC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge0Zsb2F0fSBsYXRpdHVkZSBMYXRpdHVkZSBvZiBsb2NhdGlvblxuICAgKiBAcGFyYW0gIHtGbG9hdH0gbG9uZ2l0dWRlIExvbmdpdHVkZSBvZiBsb2NhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kbG9jYXRpb25cbiAgICovXG4gIHNlbmRMb2NhdGlvbihjaGF0SWQsIGxhdGl0dWRlLCBsb25naXR1ZGUsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgZm9ybS5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRMb2NhdGlvbicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCBsaXZlIGxvY2F0aW9uIG1lc3NhZ2VzIHNlbnQgYnlcbiAgICogdGhlIGJvdCBvciB2aWEgdGhlIGJvdCAoZm9yIGlubGluZSBib3RzKS5cbiAgICpcbiAgICogIEEgbG9jYXRpb24gKipjYW4gYmUgZWRpdGVkIHVudGlsIGl0cyBsaXZlX3BlcmlvZCBleHBpcmVzIG9yIGVkaXRpbmcgaXMgZXhwbGljaXRseSBkaXNhYmxlZCBieSBhIGNhbGwgdG8gW3N0b3BNZXNzYWdlTGl2ZUxvY2F0aW9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3N0b3BtZXNzYWdlbGl2ZWxvY2F0aW9uKSoqXG4gICAqXG4gICAqIE5vdGUgdGhhdCB5b3UgbXVzdCBwcm92aWRlIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvclxuICAgKiBpbmxpbmVfbWVzc2FnZV9pZCBpbiB5b3VyIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSAge0Zsb2F0fSBsYXRpdHVkZSBMYXRpdHVkZSBvZiBsb2NhdGlvblxuICAgKiBAcGFyYW0gIHtGbG9hdH0gbG9uZ2l0dWRlIExvbmdpdHVkZSBvZiBsb2NhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnMgKHByb3ZpZGUgZWl0aGVyIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCBoZXJlKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBpZiB0aGUgZWRpdGVkIG1lc3NhZ2UgaXMgbm90IGFuIGlubGluZSBtZXNzYWdlLCB0aGUgZWRpdGVkIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkLCBvdGhlcndpc2UgVHJ1ZSBpcyByZXR1cm5lZC5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2VkaXRtZXNzYWdlbGl2ZWxvY2F0aW9uXG4gICAqL1xuICBlZGl0TWVzc2FnZUxpdmVMb2NhdGlvbihsYXRpdHVkZSwgbG9uZ2l0dWRlLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgZm9ybS5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRNZXNzYWdlTGl2ZUxvY2F0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzdG9wIHVwZGF0aW5nIGEgbGl2ZSBsb2NhdGlvbiBtZXNzYWdlIHNlbnQgYnlcbiAgICogdGhlIGJvdCBvciB2aWEgdGhlIGJvdCAoZm9yIGlubGluZSBib3RzKSBiZWZvcmUgbGl2ZV9wZXJpb2QgZXhwaXJlcy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHlvdSBtdXN0IHByb3ZpZGUgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yXG4gICAqIGlubGluZV9tZXNzYWdlX2lkIGluIHlvdXIgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zIChwcm92aWRlIGVpdGhlciBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3IgaW5saW5lX21lc3NhZ2VfaWQgaGVyZSlcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgaWYgdGhlIGVkaXRlZCBtZXNzYWdlIGlzIG5vdCBhbiBpbmxpbmUgbWVzc2FnZSwgdGhlIGVkaXRlZCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIFRydWUgaXMgcmV0dXJuZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzdG9wbWVzc2FnZWxpdmVsb2NhdGlvblxuICAgKi9cbiAgc3RvcE1lc3NhZ2VMaXZlTG9jYXRpb24oZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3N0b3BNZXNzYWdlTGl2ZUxvY2F0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgdmVudWUuXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGluZm9ybWF0aW9uIGFib3V0IGEgdmVudWUuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtGbG9hdH0gbGF0aXR1ZGUgTGF0aXR1ZGUgb2YgbG9jYXRpb25cbiAgICogQHBhcmFtICB7RmxvYXR9IGxvbmdpdHVkZSBMb25naXR1ZGUgb2YgbG9jYXRpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSB0aXRsZSBOYW1lIG9mIHRoZSB2ZW51ZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFkZHJlc3MgQWRkcmVzcyBvZiB0aGUgdmVudWVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZC5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmR2ZW51ZVxuICAgKi9cbiAgc2VuZFZlbnVlKGNoYXRJZCwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgdGl0bGUsIGFkZHJlc3MsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgZm9ybS5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgZm9ybS50aXRsZSA9IHRpdGxlO1xuICAgIGZvcm0uYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRWZW51ZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGNvbnRhY3QuXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIHBob25lIGNvbnRhY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwaG9uZU51bWJlciBDb250YWN0J3MgcGhvbmUgbnVtYmVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZmlyc3ROYW1lIENvbnRhY3QncyBmaXJzdCBuYW1lXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRjb250YWN0XG4gICAqL1xuICBzZW5kQ29udGFjdChjaGF0SWQsIHBob25lTnVtYmVyLCBmaXJzdE5hbWUsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnBob25lX251bWJlciA9IHBob25lTnVtYmVyO1xuICAgIGZvcm0uZmlyc3RfbmFtZSA9IGZpcnN0TmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZENvbnRhY3QnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBwb2xsLlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBhIG5hdGl2ZSBwb2xsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAvY2hhbm5lbFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHF1ZXN0aW9uIFBvbGwgcXVlc3Rpb24sIDEtMzAwIGNoYXJhY3RlcnNcbiAgICogQHBhcmFtICB7QXJyYXl9IHBvbGxPcHRpb25zIFBvbGwgb3B0aW9ucywgYmV0d2VlbiAyLTEwIG9wdGlvbnMgKG9ubHkgMS0xMDAgY2hhcmFjdGVycyBlYWNoKVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kcG9sbFxuICAgKi9cbiAgc2VuZFBvbGwoY2hhdElkLCBxdWVzdGlvbiwgcG9sbE9wdGlvbnMsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnF1ZXN0aW9uID0gcXVlc3Rpb247XG4gICAgZm9ybS5vcHRpb25zID0gc3RyaW5naWZ5KHBvbGxPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZFBvbGwnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBEaWNlXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGFuIGFuaW1hdGVkIGVtb2ppIHRoYXQgd2lsbCBkaXNwbGF5IGEgcmFuZG9tIHZhbHVlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRkaWNlXG4gICAqL1xuICBzZW5kRGljZShjaGF0SWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9ucyxcbiAgICB9O1xuICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgnZGljZScpO1xuICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZERpY2UnLCBvcHRzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNlbmQgY2hhdCBhY3Rpb24uXG4gICAqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB3aGVuIHlvdSBuZWVkIHRvIHRlbGwgdGhlIHVzZXIgdGhhdCBzb21ldGhpbmcgaXMgaGFwcGVuaW5nIG9uIHRoZSBib3QncyBzaWRlLlxuICAgKiAqKlRoZSBzdGF0dXMgaXMgc2V0IGZvciA1IHNlY29uZHMgb3IgbGVzcyoqICh3aGVuIGEgbWVzc2FnZSBhcnJpdmVzIGZyb20geW91ciBib3QsIFRlbGVncmFtIGNsaWVudHMgY2xlYXIgaXRzIHR5cGluZyBzdGF0dXMpLlxuICAgKlxuICAgKiAgQWN0aW9uIGB0eXBpbmdgIGZvciBbdGV4dCBtZXNzYWdlc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kbWVzc2FnZSksXG4gICAqIGB1cGxvYWRfcGhvdG9gIGZvciBbcGhvdG9zXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRwaG90byksIGByZWNvcmRfdmlkZW9gIG9yIGB1cGxvYWRfdmlkZW9gIGZvciBbdmlkZW9zXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmR2aWRlbyksXG4gICAqIGByZWNvcmRfdm9pY2VgIG9yIGB1cGxvYWRfdm9pY2VgIGZvciBbdm9pY2Ugbm90ZXNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHZvaWNlKSwgYHVwbG9hZF9kb2N1bWVudGAgZm9yIFtnZW5lcmFsIGZpbGVzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRkb2N1bWVudCksXG4gICAqIGBjaG9vc2Vfc3RpY2tlcmAgZm9yIFtzdGlja2Vyc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kc3RpY2tlciksIGBmaW5kX2xvY2F0aW9uYCBmb3IgW2xvY2F0aW9uIGRhdGFdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGxvY2F0aW9uKSxcbiAgICogYHJlY29yZF92aWRlb19ub3RlYCBvciBgdXBsb2FkX3ZpZGVvX25vdGVgIGZvciBbdmlkZW8gbm90ZXNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHZpZGVvbm90ZSkuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFjdGlvbiBUeXBlIG9mIGFjdGlvbiB0byBicm9hZGNhc3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRjaGF0YWN0aW9uXG4gICAqL1xuICBzZW5kQ2hhdEFjdGlvbihjaGF0SWQsIGFjdGlvbiwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0uYWN0aW9uID0gYWN0aW9uO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kQ2hhdEFjdGlvbicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBjaG9zZW4gcmVhY3Rpb25zIG9uIGEgbWVzc2FnZS5cbiAgICogLSBTZXJ2aWNlIG1lc3NhZ2VzIGNhbid0IGJlIHJlYWN0ZWQgdG8uXG4gICAqIC0gQXV0b21hdGljYWxseSBmb3J3YXJkZWQgbWVzc2FnZXMgZnJvbSBhIGNoYW5uZWwgdG8gaXRzIGRpc2N1c3Npb24gZ3JvdXAgaGF2ZSB0aGUgc2FtZSBhdmFpbGFibGUgcmVhY3Rpb25zIGFzIG1lc3NhZ2VzIGluIHRoZSBjaGFubmVsLlxuICAgKiAtIEluIGFsYnVtcywgYm90cyBtdXN0IHJlYWN0IHRvIHRoZSBmaXJzdCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IEBjaGFubmVsdXNlcm5hbWUpXG4gICAqIEBwYXJhbSAge051bWJlcn0gbWVzc2FnZUlkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IG1lc3NhZ2VcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Qm9vbGVhbj59IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0bWVzc2FnZXJlYWN0aW9uXG4gICAqL1xuICBzZXRNZXNzYWdlUmVhY3Rpb24oY2hhdElkLCBtZXNzYWdlSWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLm1lc3NhZ2VfaWQgPSBtZXNzYWdlSWQ7XG4gICAgaWYgKGZvcm0ucmVhY3Rpb24pIHtcbiAgICAgIGZvcm0ucmVhY3Rpb24gPSBzdHJpbmdpZnkoZm9ybS5yZWFjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRNZXNzYWdlUmVhY3Rpb24nLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBhIGxpc3Qgb2YgcHJvZmlsZSBwaWN0dXJlcyBmb3IgYSB1c2VyLlxuICAgKiBSZXR1cm5zIGEgW1VzZXJQcm9maWxlUGhvdG9zXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VzZXJwcm9maWxlcGhvdG9zKSBvYmplY3QuXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBhbiBbb2xkZXIsIGNvbXBhdGlibGUgc2lnbmF0dXJlXVtnZXRVc2VyUHJvZmlsZVBob3Rvcy12MC4yNS4wXVxuICAgKiB0aGF0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBSZXR1cm5zIGEgW1VzZXJQcm9maWxlUGhvdG9zXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VzZXJwcm9maWxlcGhvdG9zKSBvYmplY3RcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHVzZXJwcm9maWxlcGhvdG9zXG4gICAqL1xuICBnZXRVc2VyUHJvZmlsZVBob3Rvcyh1c2VySWQsIGZvcm0gPSB7fSkge1xuICAgIC8qIFRoZSBvbGRlciBtZXRob2Qgc2lnbmF0dXJlIHdhcyBnZXRVc2VyUHJvZmlsZVBob3Rvcyh1c2VySWQsIG9mZnNldCwgbGltaXQpLlxuICAgICAqIFdlIG5lZWQgdG8gZW5zdXJlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdoaWxlIG1haW50YWluaW5nXG4gICAgICogY29uc2lzdGVuY3kgb2YgdGhlIG1ldGhvZCBzaWduYXR1cmVzIHRocm91Z2hvdXQgdGhlIGxpYnJhcnkgKi9cbiAgICBpZiAodHlwZW9mIGZvcm0gIT09ICdvYmplY3QnKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgICBkZXByZWNhdGUoJ1RoZSBtZXRob2Qgc2lnbmF0dXJlIGdldFVzZXJQcm9maWxlUGhvdG9zKHVzZXJJZCwgb2Zmc2V0LCBsaW1pdCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2MC4yNS4wJyk7XG4gICAgICBmb3JtID0ge1xuICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgbGltaXQ6IGFyZ3VtZW50c1syXSxcbiAgICAgIH07XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICB9XG4gICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRVc2VyUHJvZmlsZVBob3RvcycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZmlsZS5cbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBiYXNpYyBpbmZvIGFib3V0IGEgZmlsZSBhbmQgcHJlcGFyZSBpdCBmb3IgZG93bmxvYWRpbmcuXG4gICAqXG4gICAqIEF0dGVudGlvbjogKipsaW5rIHdpbGwgYmUgdmFsaWQgZm9yIDEgaG91ci4qKlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVJZCAgRmlsZSBpZGVudGlmaWVyIHRvIGdldCBpbmZvIGFib3V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBhIFtGaWxlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2ZpbGUpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0ZmlsZVxuICAgKi9cbiAgZ2V0RmlsZShmaWxlSWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uZmlsZV9pZCA9IGZpbGVJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0RmlsZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGJhbiBhIHVzZXIgaW4gYSBncm91cCwgYSBzdXBlcmdyb3VwIG9yIGEgY2hhbm5lbC5cbiAgICAqIEluIHRoZSBjYXNlIG9mIHN1cGVyZ3JvdXBzIGFuZCBjaGFubmVscywgdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0b1xuICAgICogcmV0dXJuIHRvIHRoZSBjaGF0IG9uIHRoZWlyIG93biB1c2luZyBpbnZpdGUgbGlua3MsIGV0Yy4sIHVubGVzcyB1bmJhbm5lZCBmaXJzdC4uXG4gICAgKlxuICAgICogVGhlICoqYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgZ3JvdXAsIHN1cGVyZ3JvdXAgb3IgYSBjaGFubmVsKiogZm9yIHRoaXMgdG8gd29yay5cbiAgICAqXG4gICAgKlxuICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYmFuY2hhdG1lbWJlclxuICAgICovXG4gIGJhbkNoYXRNZW1iZXIoY2hhdElkLCB1c2VySWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2JhbkNoYXRNZW1iZXInLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgKiBVc2UgdGhpcyBtZXRob2QgdG8gdW5iYW4gYSBwcmV2aW91c2x5IGtpY2tlZCB1c2VyIGluIGEgc3VwZXJncm91cC5cbiAgKiBUaGUgdXNlciB3aWxsIG5vdCByZXR1cm4gdG8gdGhlIGdyb3VwIGF1dG9tYXRpY2FsbHksIGJ1dCB3aWxsIGJlXG4gICogYWJsZSB0byBqb2luIHZpYSBsaW5rLCBldGMuXG4gICpcbiAgKiBUaGUgKipib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yKiogaW4gdGhlIHN1cGVyZ3JvdXAgb3IgY2hhbm5lbCBmb3IgdGhpcyB0byB3b3JrLlxuICAqXG4gICogKipCeSBkZWZhdWx0KiosIHRoaXMgbWV0aG9kIGd1YXJhbnRlZXMgdGhhdCBhZnRlciB0aGUgY2FsbCB0aGUgdXNlciBpcyBub3QgYSBtZW1iZXIgb2YgdGhlIGNoYXQsIGJ1dCB3aWxsIGJlIGFibGUgdG8gam9pbiBpdC5cbiAgKiBTbyAqKmlmIHRoZSB1c2VyIGlzIGEgbWVtYmVyIG9mIHRoZSBjaGF0IHRoZXkgd2lsbCBhbHNvIGJlIHJlbW92ZWQgZnJvbSB0aGUgY2hhdCoqLiBJZiB5b3UgZG9uJ3Qgd2FudCB0aGlzLCB1c2UgdGhlIHBhcmFtZXRlciAqb25seV9pZl9iYW5uZWQqXG4gICpcbiAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bmJhbmNoYXRtZW1iZXJcbiAgKi9cbiAgdW5iYW5DaGF0TWVtYmVyKGNoYXRJZCwgdXNlcklkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bmJhbkNoYXRNZW1iZXInLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVzdHJpY3QgYSB1c2VyIGluIGEgc3VwZXJncm91cC5cbiAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBzdXBlcmdyb3VwKiogZm9yIHRoaXMgdG8gd29ya1xuICAqIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy4gUGFzcyBUcnVlIGZvciBhbGwgYm9vbGVhbiBwYXJhbWV0ZXJzXG4gICogdG8gbGlmdCByZXN0cmljdGlvbnMgZnJvbSBhIHVzZXIuIFJldHVybnMgVHJ1ZSBvbiBzdWNjZXNzLlxuICAqXG4gICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Jlc3RyaWN0Y2hhdG1lbWJlclxuICAqL1xuICByZXN0cmljdENoYXRNZW1iZXIoY2hhdElkLCB1c2VySWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3Jlc3RyaWN0Q2hhdE1lbWJlcicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcHJvbW90ZSBvciBkZW1vdGUgYSB1c2VyIGluIGEgc3VwZXJncm91cCBvciBhIGNoYW5uZWwuXG4gICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IqKiBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrXG4gICAqIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy4gUGFzcyBGYWxzZSBmb3IgYWxsIGJvb2xlYW4gcGFyYW1ldGVycyB0byBkZW1vdGUgYSB1c2VyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzcy5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Byb21vdGVjaGF0bWVtYmVyXG4gICAqL1xuICBwcm9tb3RlQ2hhdE1lbWJlcihjaGF0SWQsIHVzZXJJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncHJvbW90ZUNoYXRNZW1iZXInLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCBhIGN1c3RvbSB0aXRsZSBmb3IgYW4gYWRtaW5pc3RyYXRvciBpbiBhIHN1cGVyZ3JvdXAgcHJvbW90ZWQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGN1c3RvbVRpdGxlIE5ldyBjdXN0b20gdGl0bGUgZm9yIHRoZSBhZG1pbmlzdHJhdG9yOyAwLTE2IGNoYXJhY3RlcnMsIGVtb2ppIGFyZSBub3QgYWxsb3dlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRjaGF0YWRtaW5pc3RyYXRvcmN1c3RvbXRpdGxlXG4gICAqL1xuICBzZXRDaGF0QWRtaW5pc3RyYXRvckN1c3RvbVRpdGxlKGNoYXRJZCwgdXNlcklkLCBjdXN0b21UaXRsZSwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICBmb3JtLmN1c3RvbV90aXRsZSA9IGN1c3RvbVRpdGxlO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0QWRtaW5pc3RyYXRvckN1c3RvbVRpdGxlJywgeyBmb3JtIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGJhbiBhIGNoYW5uZWwgY2hhdCBpbiBhIHN1cGVyZ3JvdXAgb3IgYSBjaGFubmVsLlxuICAgKlxuICAgKiBVbnRpbCB0aGUgY2hhdCBpcyBbdW5iYW5uZWRdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdW5iYW5jaGF0c2VuZGVyY2hhdCksIHRoZSBvd25lciBvZiB0aGUgYmFubmVkIGNoYXQgd29uJ3QgYmUgYWJsZSB0byBzZW5kIG1lc3NhZ2VzIG9uIGJlaGFsZiBvZiBhbnkgb2YgdGhlaXIgY2hhbm5lbHMuXG4gICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIHN1cGVyZ3JvdXAgb3IgY2hhbm5lbCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW5pc3RyYXRvciByaWdodHNcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNlbmRlckNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNiYW5jaGF0c2VuZGVyY2hhdFxuICAgKi9cbiAgYmFuQ2hhdFNlbmRlckNoYXQoY2hhdElkLCBzZW5kZXJDaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnNlbmRlcl9jaGF0X2lkID0gc2VuZGVyQ2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdiYW5DaGF0U2VuZGVyQ2hhdCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIFVzZSB0aGlzIG1ldGhvZCB0byB1bmJhbiBhIHByZXZpb3VzbHkgYmFubmVkIGNoYW5uZWwgY2hhdCBpbiBhIHN1cGVyZ3JvdXAgb3IgY2hhbm5lbC5cbiAgKlxuICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAqXG4gICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNlbmRlckNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdW5iYW5jaGF0c2VuZGVyY2hhdFxuICAqL1xuICB1bmJhbkNoYXRTZW5kZXJDaGF0KGNoYXRJZCwgc2VuZGVyQ2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5zZW5kZXJfY2hhdF9pZCA9IHNlbmRlckNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgndW5iYW5DaGF0U2VuZGVyQ2hhdCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2V0IGRlZmF1bHQgY2hhdCBwZXJtaXNzaW9ucyBmb3IgYWxsIG1lbWJlcnMuXG4gICAqXG4gICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGdyb3VwIG9yIGEgc3VwZXJncm91cCoqIGZvciB0aGlzIHRvXG4gICAqIHdvcmsgYW5kICoqbXVzdCBoYXZlIHRoZSBgY2FuX3Jlc3RyaWN0X21lbWJlcnNgIGFkbWluIHJpZ2h0cy4qKlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7QXJyYXl9IGNoYXRQZXJtaXNzaW9ucyBOZXcgZGVmYXVsdCBjaGF0IHBlcm1pc3Npb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGNoYXRwZXJtaXNzaW9uc1xuICAgKi9cbiAgc2V0Q2hhdFBlcm1pc3Npb25zKGNoYXRJZCwgY2hhdFBlcm1pc3Npb25zLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5wZXJtaXNzaW9ucyA9IHN0cmluZ2lmeShjaGF0UGVybWlzc2lvbnMpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0UGVybWlzc2lvbnMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdlbmVyYXRlIGEgbmV3IHByaW1hcnkgaW52aXRlIGxpbmsgZm9yIGEgY2hhdC4gKipBbnkgcHJldmlvdXNseSBnZW5lcmF0ZWQgcHJpbWFyeSBsaW5rIGlzIHJldm9rZWQqKi5cbiAgICpcbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBFeHBvcnRlZCBpbnZpdGUgbGluayBhcyBTdHJpbmcgb24gc3VjY2Vzcy5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2V4cG9ydGNoYXRpbnZpdGVsaW5rXG4gICAqL1xuICBleHBvcnRDaGF0SW52aXRlTGluayhjaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZXhwb3J0Q2hhdEludml0ZUxpbmsnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGludml0ZSBsaW5rIGZvciBhIGNoYXQuXG4gICAqXG4gICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy5cbiAgICpcbiAgICogVGhlIGxpbmsgZ2VuZXJhdGVkIHdpdGggdGhpcyBtZXRob2QgY2FuIGJlIHJldm9rZWQgdXNpbmcgdGhlIG1ldGhvZCBbcmV2b2tlQ2hhdEludml0ZUxpbmtdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcmV2b2tlY2hhdGludml0ZWxpbmspXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgaW52aXRlIGxpbmsgYXMgW0NoYXRJbnZpdGVMaW5rXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRpbnZpdGVsaW5rKSBvYmplY3RcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NyZWF0ZWNoYXRpbnZpdGVsaW5rXG4gICAqL1xuICBjcmVhdGVDaGF0SW52aXRlTGluayhjaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY3JlYXRlQ2hhdEludml0ZUxpbmsnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgYSBub24tcHJpbWFyeSBpbnZpdGUgbGluayBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAqXG4gICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpbnZpdGVMaW5rIFRleHQgd2l0aCB0aGUgaW52aXRlIGxpbmsgdG8gZWRpdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIGVkaXRlZCBpbnZpdGUgbGluayBhcyBhIFtDaGF0SW52aXRlTGlua10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjaGF0aW52aXRlbGluaykgb2JqZWN0XG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0Y2hhdGludml0ZWxpbmtcbiAgICovXG4gIGVkaXRDaGF0SW52aXRlTGluayhjaGF0SWQsIGludml0ZUxpbmssIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLmludml0ZV9saW5rID0gaW52aXRlTGluaztcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdENoYXRJbnZpdGVMaW5rJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZXZva2UgYW4gaW52aXRlIGxpbmsgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgKiBOb3RlOiBJZiB0aGUgcHJpbWFyeSBsaW5rIGlzIHJldm9rZWQsIGEgbmV3IGxpbmsgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWRcbiAgICpcbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGludml0ZUxpbmsgVGhlIGludml0ZSBsaW5rIHRvIHJldm9rZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHJldm9rZWQgaW52aXRlIGxpbmsgYXMgW0NoYXRJbnZpdGVMaW5rXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRpbnZpdGVsaW5rKSBvYmplY3RcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Jldm9rZWNoYXRpbnZpdGVsaW5rXG4gICAqL1xuICByZXZva2VDaGF0SW52aXRlTGluayhjaGF0SWQsIGludml0ZUxpbmssIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLmludml0ZV9saW5rID0gaW52aXRlTGluaztcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncmV2b2tlQ2hhdEludml0ZUxpbmsnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGFwcHJvdmUgYSBjaGF0IGpvaW4gcmVxdWVzdC5cbiAgICpcbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kICoqbXVzdCBoYXZlIHRoZSBgY2FuX2ludml0ZV91c2Vyc2AgYWRtaW5pc3RyYXRvciByaWdodC4qKlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2FwcHJvdmVjaGF0am9pbnJlcXVlc3RcbiAgICovXG4gIGFwcHJvdmVDaGF0Sm9pblJlcXVlc3QoY2hhdElkLCB1c2VySWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2FwcHJvdmVDaGF0Sm9pblJlcXVlc3QnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGRlY2xpbmUgYSBjaGF0IGpvaW4gcmVxdWVzdC5cbiAgICpcbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kICoqbXVzdCBoYXZlIHRoZSBgY2FuX2ludml0ZV91c2Vyc2AgYWRtaW5pc3RyYXRvciByaWdodCoqLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlY2xpbmVjaGF0am9pbnJlcXVlc3RcbiAgICovXG4gIGRlY2xpbmVDaGF0Sm9pblJlcXVlc3QoY2hhdElkLCB1c2VySWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlY2xpbmVDaGF0Sm9pblJlcXVlc3QnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCBhIG5ldyBwcm9maWxlIHBob3RvIGZvciB0aGUgY2hhdC4gKipQaG90b3MgY2FuJ3QgYmUgY2hhbmdlZCBmb3IgcHJpdmF0ZSBjaGF0cyoqLlxuICAgKlxuICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbiByaWdodHMuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gcGhvdG8gQSBmaWxlIHBhdGggb3IgYSBTdHJlYW0uXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGNoYXRwaG90b1xuICAgKi9cbiAgc2V0Q2hhdFBob3RvKGNoYXRJZCwgcGhvdG8sIG9wdGlvbnMgPSB7fSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9ucyxcbiAgICB9O1xuICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgncGhvdG8nLCBwaG90bywgZmlsZU9wdGlvbnMpO1xuICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgb3B0cy5xcy5waG90byA9IHNlbmREYXRhWzFdO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0Q2hhdFBob3RvJywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIGEgY2hhdCBwaG90by4gKipQaG90b3MgY2FuJ3QgYmUgY2hhbmdlZCBmb3IgcHJpdmF0ZSBjaGF0cyoqLlxuICAqXG4gICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAqXG4gICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZWNoYXRwaG90b1xuICAqL1xuICBkZWxldGVDaGF0UGhvdG8oY2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZUNoYXRQaG90bycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSB0aXRsZSBvZiBhIGNoYXQuICoqVGl0bGVzIGNhbid0IGJlIGNoYW5nZWQgZm9yIHByaXZhdGUgY2hhdHMqKi5cbiAgICpcbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0aXRsZSBOZXcgY2hhdCB0aXRsZSwgMS0yNTUgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRjaGF0dGl0bGVcbiAgICovXG4gIHNldENoYXRUaXRsZShjaGF0SWQsIHRpdGxlLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS50aXRsZSA9IHRpdGxlO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0VGl0bGUnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgZGVzY3JpcHRpb24gb2YgYSBncm91cCwgYSBzdXBlcmdyb3VwIG9yIGEgY2hhbm5lbC5cbiAgICpcbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfSBkZXNjcmlwdGlvbiBOZXcgY2hhdCB0aXRsZSwgMC0yNTUgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRjaGF0ZGVzY3JpcHRpb25cbiAgICovXG4gIHNldENoYXREZXNjcmlwdGlvbihjaGF0SWQsIGRlc2NyaXB0aW9uLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0RGVzY3JpcHRpb24nLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHBpbiBhIG1lc3NhZ2UgaW4gYSBzdXBlcmdyb3VwLlxuICAgKlxuICAgKiBJZiB0aGUgY2hhdCBpcyBub3QgYSBwcml2YXRlIGNoYXQsIHRoZSAqKmJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGBjYW5fcGluX21lc3NhZ2VzYCBhZG1pbmlzdHJhdG9yXG4gICAqIHJpZ2h0IGluIGEgc3VwZXJncm91cCBvciBgY2FuX2VkaXRfbWVzc2FnZXNgIGFkbWluaXN0cmF0b3IgcmlnaHQgaW4gYSBjaGFubmVsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7TnVtYmVyfSBtZXNzYWdlSWQgSWRlbnRpZmllciBvZiBhIG1lc3NhZ2UgdG8gcGluXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3BpbmNoYXRtZXNzYWdlXG4gICAqL1xuICBwaW5DaGF0TWVzc2FnZShjaGF0SWQsIG1lc3NhZ2VJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubWVzc2FnZV9pZCA9IG1lc3NhZ2VJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncGluQ2hhdE1lc3NhZ2UnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlbW92ZSBhIG1lc3NhZ2UgZnJvbSB0aGUgbGlzdCBvZiBwaW5uZWQgbWVzc2FnZXMgaW4gYSBjaGF0XG4gICAqXG4gICAqIElmIHRoZSBjaGF0IGlzIG5vdCBhIHByaXZhdGUgY2hhdCwgdGhlICoqYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYGNhbl9waW5fbWVzc2FnZXNgIGFkbWluaXN0cmF0b3JcbiAgICogcmlnaHQgaW4gYSBzdXBlcmdyb3VwIG9yIGBjYW5fZWRpdF9tZXNzYWdlc2AgYWRtaW5pc3RyYXRvciByaWdodCBpbiBhIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bnBpbmNoYXRtZXNzYWdlXG4gICAqL1xuICB1bnBpbkNoYXRNZXNzYWdlKGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bnBpbkNoYXRNZXNzYWdlJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICogVXNlIHRoaXMgbWV0aG9kIHRvIGNsZWFyIHRoZSBsaXN0IG9mIHBpbm5lZCBtZXNzYWdlcyBpbiBhIGNoYXQuXG4gICpcbiAgKiBJZiB0aGUgY2hhdCBpcyBub3QgYSBwcml2YXRlIGNoYXQsIHRoZSAqKmJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGBjYW5fcGluX21lc3NhZ2VzYCBhZG1pbmlzdHJhdG9yXG4gICogcmlnaHQgaW4gYSBzdXBlcmdyb3VwIG9yIGBjYW5fZWRpdF9tZXNzYWdlc2AgYWRtaW5pc3RyYXRvciByaWdodCBpbiBhIGNoYW5uZWwuXG4gICpcbiAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdW5waW5hbGxjaGF0bWVzc2FnZXNcbiAgKi9cbiAgdW5waW5BbGxDaGF0TWVzc2FnZXMoY2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3VucGluQWxsQ2hhdE1lc3NhZ2VzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCBmb3IgeW91ciBib3QgdG8gbGVhdmUgYSBncm91cCwgc3VwZXJncm91cCBvciBjaGFubmVsXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNsZWF2ZWNoYXRcbiAgICovXG4gIGxlYXZlQ2hhdChjaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnbGVhdmVDaGF0JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdXAgdG8gZGF0ZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hhdFxuICAgKiAoY3VycmVudCBuYW1lIG9mIHRoZSB1c2VyIGZvciBvbmUtb24tb25lIGNvbnZlcnNhdGlvbnMsIGN1cnJlbnRcbiAgICogdXNlcm5hbWUgb2YgYSB1c2VyLCBncm91cCBvciBjaGFubmVsLCBldGMuKS5cbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYCkgb3IgY2hhbm5lbFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gW0NoYXRGdWxsSW5mb10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjaGF0ZnVsbGluZm8pIG9iamVjdCBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0XG4gICAqL1xuICBnZXRDaGF0KGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRDaGF0JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgYSBsaXN0IG9mIGFkbWluaXN0cmF0b3JzIGluIGEgY2hhdFxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgcmV0dXJucyBhbiBBcnJheSBvZiBbQ2hhdE1lbWJlcl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjaGF0bWVtYmVyKSBvYmplY3RzIHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYWxsIGNoYXQgYWRtaW5pc3RyYXRvcnMgZXhjZXB0IG90aGVyIGJvdHMuXG4gICAqIElmIHRoZSBjaGF0IGlzIGEgZ3JvdXAgb3IgYSBzdXBlcmdyb3VwIGFuZCBubyBhZG1pbmlzdHJhdG9ycyB3ZXJlIGFwcG9pbnRlZCwgb25seSB0aGUgY3JlYXRvciB3aWxsIGJlIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0YWRtaW5pc3RyYXRvcnNcbiAgICovXG4gIGdldENoYXRBZG1pbmlzdHJhdG9ycyhjaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0Q2hhdEFkbWluaXN0cmF0b3JzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB0aGUgbnVtYmVyIG9mIG1lbWJlcnMgaW4gYSBjaGF0LlxuICAqXG4gICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXBcbiAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBJbnQgb24gc3VjY2Vzc1xuICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0bWVtYmVyY291bnRcbiAgKi9cbiAgZ2V0Q2hhdE1lbWJlckNvdW50KGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRDaGF0TWVtYmVyQ291bnQnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dCBhIG1lbWJlciBvZiBhIGNoYXQuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFtDaGF0TWVtYmVyXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRtZW1iZXIpIG9iamVjdCBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0bWVtYmVyXG4gICAqL1xuICBnZXRDaGF0TWVtYmVyKGNoYXRJZCwgdXNlcklkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRDaGF0TWVtYmVyJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBuZXcgZ3JvdXAgc3RpY2tlciBzZXQgZm9yIGEgc3VwZXJncm91cC5cbiAgICpcbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICAqXG4gICAqICoqTm90ZToqKiBVc2UgdGhlIGZpZWxkIGBjYW5fc2V0X3N0aWNrZXJfc2V0YCBvcHRpb25hbGx5IHJldHVybmVkIGluIFtnZXRDaGF0XShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXQpIHJlcXVlc3RzIHRvIGNoZWNrIGlmIHRoZSBib3QgY2FuIHVzZSB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXJTZXROYW1lIE5hbWUgb2YgdGhlIHN0aWNrZXIgc2V0IHRvIGJlIHNldCBhcyB0aGUgZ3JvdXAgc3RpY2tlciBzZXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y2hhdHN0aWNrZXJzZXRcbiAgICovXG4gIHNldENoYXRTdGlja2VyU2V0KGNoYXRJZCwgc3RpY2tlclNldE5hbWUsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnN0aWNrZXJfc2V0X25hbWUgPSBzdGlja2VyU2V0TmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0Q2hhdFN0aWNrZXJTZXQnLCB7IGZvcm0gfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIGEgZ3JvdXAgc3RpY2tlciBzZXQgZnJvbSBhIHN1cGVyZ3JvdXAuXG4gICAqXG4gICAqIFVzZSB0aGUgZmllbGQgYGNhbl9zZXRfc3RpY2tlcl9zZXRgIG9wdGlvbmFsbHkgcmV0dXJuZWQgaW4gW2dldENoYXRdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Y2hhdCkgcmVxdWVzdHMgdG8gY2hlY2sgaWYgdGhlIGJvdCBjYW4gdXNlIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZWNoYXRzdGlja2Vyc2V0XG4gICAqL1xuICBkZWxldGVDaGF0U3RpY2tlclNldChjaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlQ2hhdFN0aWNrZXJTZXQnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBjdXN0b20gZW1vamkgc3RpY2tlcnMsIHdoaWNoIGNhbiBiZSB1c2VkIGFzIGEgZm9ydW0gdG9waWMgaWNvbiBieSBhbnkgdXNlci5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQXJyYXkgb2YgW1N0aWNrZXJdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc3RpY2tlcikgb2JqZWN0c1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Zm9ydW10b3BpY2ljb25zdGlja2Vyc1xuICAgKi9cbiAgZ2V0Rm9ydW1Ub3BpY0ljb25TdGlja2VycyhjaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0Rm9ydW1Ub3BpY0ljb25TdGlja2VycycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGEgdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICAqXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNyZWF0ZWQgdG9waWMgYXMgYSBbRm9ydW1Ub3BpY10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNmb3J1bXRvcGljKSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFRvcGljIG5hbWUsIDEtMTI4IGNoYXJhY3RlcnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjcmVhdGVmb3J1bXRvcGljXG4gICAqL1xuICBjcmVhdGVGb3J1bVRvcGljKGNoYXRJZCwgbmFtZSwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2NyZWF0ZUZvcnVtVG9waWMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgbmFtZSBhbmQgaWNvbiBvZiBhIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMsIHVubGVzcyBpdCBpcyB0aGUgY3JlYXRvciBvZiB0aGUgdG9waWMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZVRocmVhZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IG1lc3NhZ2UgdGhyZWFkIG9mIHRoZSBmb3J1bSB0b3BpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2VkaXRmb3J1bXRvcGljXG4gICAqL1xuICBlZGl0Rm9ydW1Ub3BpYyhjaGF0SWQsIG1lc3NhZ2VUaHJlYWRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubWVzc2FnZV90aHJlYWRfaWQgPSBtZXNzYWdlVGhyZWFkSWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRGb3J1bVRvcGljJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjbG9zZSBhbiBvcGVuIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLCB1bmxlc3MgaXQgaXMgdGhlIGNyZWF0b3Igb2YgdGhlIHRvcGljLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1lc3NhZ2VUaHJlYWRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBtZXNzYWdlIHRocmVhZCBvZiB0aGUgZm9ydW0gdG9waWNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjbG9zZWZvcnVtdG9waWNcbiAgICovXG4gIGNsb3NlRm9ydW1Ub3BpYyhjaGF0SWQsIG1lc3NhZ2VUaHJlYWRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubWVzc2FnZV90aHJlYWRfaWQgPSBtZXNzYWdlVGhyZWFkSWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Nsb3NlRm9ydW1Ub3BpYycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVvcGVuIGEgY2xvc2VkIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLCB1bmxlc3MgaXQgaXMgdGhlIGNyZWF0b3Igb2YgdGhlIHRvcGljLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1lc3NhZ2VUaHJlYWRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBtZXNzYWdlIHRocmVhZCBvZiB0aGUgZm9ydW0gdG9waWNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNyZW9wZW5mb3J1bXRvcGljXG4gICAqL1xuICByZW9wZW5Gb3J1bVRvcGljKGNoYXRJZCwgbWVzc2FnZVRocmVhZElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX3RocmVhZF9pZCA9IG1lc3NhZ2VUaHJlYWRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncmVvcGVuRm9ydW1Ub3BpYycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIGEgZm9ydW0gdG9waWMgYWxvbmcgd2l0aCBhbGwgaXRzIG1lc3NhZ2VzIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9kZWxldGVfbWVzc2FnZXMgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZVRocmVhZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IG1lc3NhZ2UgdGhyZWFkIG9mIHRoZSBmb3J1bSB0b3BpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZWZvcnVtdG9waWNcbiAgICovXG4gIGRlbGV0ZUZvcnVtVG9waWMoY2hhdElkLCBtZXNzYWdlVGhyZWFkSWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLm1lc3NhZ2VfdGhyZWFkX2lkID0gbWVzc2FnZVRocmVhZElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVGb3J1bVRvcGljJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjbGVhciB0aGUgbGlzdCBvZiBwaW5uZWQgbWVzc2FnZXMgaW4gYSBmb3J1bSB0b3BpYy5cbiAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fcGluX21lc3NhZ2VzIGFkbWluaXN0cmF0b3IgcmlnaHQgaW4gdGhlIHN1cGVyZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZVRocmVhZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IG1lc3NhZ2UgdGhyZWFkIG9mIHRoZSBmb3J1bSB0b3BpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VucGluYWxsZm9ydW10b3BpY21lc3NhZ2VzXG4gICAqL1xuICB1bnBpbkFsbEZvcnVtVG9waWNNZXNzYWdlcyhjaGF0SWQsIG1lc3NhZ2VUaHJlYWRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubWVzc2FnZV90aHJlYWRfaWQgPSBtZXNzYWdlVGhyZWFkSWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3VucGluQWxsRm9ydW1Ub3BpY01lc3NhZ2VzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgdGhlIG5hbWUgb2YgdGhlICdHZW5lcmFsJyB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAqIFRoZSB0b3BpYyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdW5oaWRkZW4gaWYgaXQgd2FzIGhpZGRlbi5cbiAgKlxuICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5ldyB0b3BpYyBuYW1lLCAxLTEyOCBjaGFyYWN0ZXJzXG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdGdlbmVyYWxmb3J1bXRvcGljXG4gICovXG4gIGVkaXRHZW5lcmFsRm9ydW1Ub3BpYyhjaGF0SWQsIG5hbWUsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdlZGl0R2VuZXJhbEZvcnVtVG9waWMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2xvc2UgYW4gb3BlbiAnR2VuZXJhbCcgdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fbWFuYWdlX3RvcGljcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgKiBUaGUgdG9waWMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVuaGlkZGVuIGlmIGl0IHdhcyBoaWRkZW4uXG4gICpcbiAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjbG9zZWdlbmVyYWxmb3J1bXRvcGljXG4gICovXG4gIGNsb3NlR2VuZXJhbEZvcnVtVG9waWMoY2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Nsb3NlR2VuZXJhbEZvcnVtVG9waWMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVvcGVuIGEgY2xvc2VkICdHZW5lcmFsJyB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAqIFRoZSB0b3BpYyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdW5oaWRkZW4gaWYgaXQgd2FzIGhpZGRlbi5cbiAgKlxuICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Jlb3BlbmdlbmVyYWxmb3J1bXRvcGljXG4gICovXG4gIHJlb3BlbkdlbmVyYWxGb3J1bVRvcGljKGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdyZW9wZW5HZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIFVzZSB0aGlzIG1ldGhvZCB0byBoaWRlIHRoZSAnR2VuZXJhbCcgdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fbWFuYWdlX3RvcGljcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgKiBUaGUgdG9waWMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNsb3NlZCBpZiBpdCB3YXMgb3Blbi5cbiAgKlxuICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2hpZGVnZW5lcmFsZm9ydW10b3BpY1xuICAqL1xuICBoaWRlR2VuZXJhbEZvcnVtVG9waWMoY2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2hpZGVHZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gdW5oaWRlIHRoZSAnR2VuZXJhbCcgdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHNcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdW5oaWRlZ2VuZXJhbGZvcnVtdG9waWNcbiAgICovXG4gIHVuaGlkZUdlbmVyYWxGb3J1bVRvcGljKGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bmhpZGVHZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2xlYXIgdGhlIGxpc3Qgb2YgcGlubmVkIG1lc3NhZ2VzIGluIGEgR2VuZXJhbCBmb3J1bSB0b3BpYy5cbiAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fcGluX21lc3NhZ2VzIGFkbWluaXN0cmF0b3IgcmlnaHQgaW4gdGhlIHN1cGVyZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VucGluYWxsZ2VuZXJhbGZvcnVtdG9waWNtZXNzYWdlc1xuICAgKi9cbiAgdW5waW5BbGxHZW5lcmFsRm9ydW1Ub3BpY01lc3NhZ2VzKGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bmhpZGVHZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBhbnN3ZXJzIHRvIGNhbGxiYWNrIHF1ZXJpZXMgc2VudCBmcm9tXG4gICAqIFtpbmxpbmUga2V5Ym9hcmRzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMjaW5saW5lLWtleWJvYXJkcy1hbmQtb24tdGhlLWZseS11cGRhdGluZykuXG4gICAqXG4gICAqIFRoZSBhbnN3ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgYXMgYSBub3RpZmljYXRpb24gYXQgdGhlIHRvcCBvZiB0aGUgY2hhdCBzY3JlZW4gb3IgYXMgYW4gYWxlcnQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGhhcyAqKm9sZGVyLCBjb21wYXRpYmxlIHNpZ25hdHVyZXMgKFsxXVthbnN3ZXJDYWxsYmFja1F1ZXJ5LXYwLjI3LjFdKShbMl1bYW5zd2VyQ2FsbGJhY2tRdWVyeS12MC4yOS4wXSkqKlxuICAgKiB0aGF0IGFyZSBiZWluZyBkZXByZWNhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNhbGxiYWNrUXVlcnlJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHF1ZXJ5IHRvIGJlIGFuc3dlcmVkXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Fuc3dlcmNhbGxiYWNrcXVlcnlcbiAgICovXG4gIGFuc3dlckNhbGxiYWNrUXVlcnkoY2FsbGJhY2tRdWVyeUlkLCBmb3JtID0ge30pIHtcbiAgICAvKiBUaGUgb2xkZXIgbWV0aG9kIHNpZ25hdHVyZSAoaW4vYmVmb3JlIHYwLjI3LjEpIHdhcyBhbnN3ZXJDYWxsYmFja1F1ZXJ5KGNhbGxiYWNrUXVlcnlJZCwgdGV4dCwgc2hvd0FsZXJ0KS5cbiAgICAgKiBXZSBuZWVkIHRvIGVuc3VyZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aGlsZSBtYWludGFpbmluZ1xuICAgICAqIGNvbnNpc3RlbmN5IG9mIHRoZSBtZXRob2Qgc2lnbmF0dXJlcyB0aHJvdWdob3V0IHRoZSBsaWJyYXJ5ICovXG4gICAgaWYgKHR5cGVvZiBmb3JtICE9PSAnb2JqZWN0Jykge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgZGVwcmVjYXRlKCdUaGUgbWV0aG9kIHNpZ25hdHVyZSBhbnN3ZXJDYWxsYmFja1F1ZXJ5KGNhbGxiYWNrUXVlcnlJZCwgdGV4dCwgc2hvd0FsZXJ0KSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYwLjI3LjEnKTtcbiAgICAgIGZvcm0gPSB7XG4gICAgICAgIGNhbGxiYWNrX3F1ZXJ5X2lkOiBhcmd1bWVudHNbMF0sXG4gICAgICAgIHRleHQ6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgc2hvd19hbGVydDogYXJndW1lbnRzWzJdLFxuICAgICAgfTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgIH1cbiAgICAvKiBUaGUgb2xkZXIgbWV0aG9kIHNpZ25hdHVyZSAoaW4vYmVmb3JlIHYwLjI5LjApIHdhcyBhbnN3ZXJDYWxsYmFja1F1ZXJ5KFtvcHRpb25zXSkuXG4gICAgICogV2UgbmVlZCB0byBlbnN1cmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICAgKiBjb25zaXN0ZW5jeSBvZiB0aGUgbWV0aG9kIHNpZ25hdHVyZXMgdGhyb3VnaG91dCB0aGUgbGlicmFyeS4gKi9cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrUXVlcnlJZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgIGRlcHJlY2F0ZSgnVGhlIG1ldGhvZCBzaWduYXR1cmUgYW5zd2VyQ2FsbGJhY2tRdWVyeShbb3B0aW9uc10pIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjAuMjkuMCcpO1xuICAgICAgZm9ybSA9IGNhbGxiYWNrUXVlcnlJZDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtLmNhbGxiYWNrX3F1ZXJ5X2lkID0gY2FsbGJhY2tRdWVyeUlkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYW5zd2VyQ2FsbGJhY2tRdWVyeScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBsaXN0IG9mIGJvb3N0cyBhZGRlZCB0byBhIGNoYXQgYnkgYSB1c2UuXG4gICAqIFJlcXVpcmVzIGFkbWluaXN0cmF0b3IgcmlnaHRzIGluIHRoZSBjaGF0XG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBncm91cC9jaGFubmVsXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcl9pZCBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHJldHVybnMgYSBbVXNlckNoYXRCb29zdHNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXNlcmNoYXRib29zdHMpIG9iamVjdFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0dXNlcmNoYXRib29zdHNcbiAgICovXG4gIGdldFVzZXJDaGF0Qm9vc3RzKGNoYXRJZCwgcG9sbElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX2lkID0gcG9sbElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRVc2VyQ2hhdEJvb3N0cycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb25uZWN0aW9uIG9mIHRoZSBib3Qgd2l0aCBhIGJ1c2luZXNzIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gYnVzaW5lc3NDb25uZWN0aW9uSWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAvY2hhbm5lbFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgcmV0dXJucyBbQnVzaW5lc3NDb25uZWN0aW9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2J1c2luZXNzY29ubmVjdGlvbikgb2JqZWN0XG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRidXNpbmVzc2Nvbm5lY3Rpb25cbiAgICovXG4gIGdldEJ1c2luZXNzQ29ubmVjdGlvbihidXNpbmVzc0Nvbm5lY3Rpb25JZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5idXNpbmVzc19jb25uZWN0aW9uX2lkID0gYnVzaW5lc3NDb25uZWN0aW9uSWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldEJ1c2luZXNzQ29ubmVjdGlvbicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBsaXN0IG9mIHRoZSBib3QncyBjb21tYW5kcy5cbiAgICpcbiAgICogU2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cyNjb21tYW5kcyBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IGJvdCBjb21tYW5kc1xuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheX0gY29tbWFuZHMgIExpc3Qgb2YgYm90IGNvbW1hbmRzIHRvIGJlIHNldCBhcyB0aGUgbGlzdCBvZiB0aGUgW2JvdCdzIGNvbW1hbmRzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2JvdGNvbW1hbmQpLiBBdCBtb3N0IDEwMCBjb21tYW5kcyBjYW4gYmUgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRteWNvbW1hbmRzXG4gICAqL1xuICBzZXRNeUNvbW1hbmRzKGNvbW1hbmRzLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNvbW1hbmRzID0gc3RyaW5naWZ5KGNvbW1hbmRzKTtcblxuICAgIGlmIChmb3JtLnNjb3BlKSB7XG4gICAgICBmb3JtLnNjb3BlID0gc3RyaW5naWZ5KGZvcm0uc2NvcGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRNeUNvbW1hbmRzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgdGhlIGxpc3Qgb2YgdGhlIGJvdCdzIGNvbW1hbmRzIGZvciB0aGUgZ2l2ZW4gc2NvcGUgYW5kIHVzZXIgbGFuZ3VhZ2UuXG4gICAqXG4gICAqICBBZnRlciBkZWxldGlvbiwgW2hpZ2hlciBsZXZlbCBjb21tYW5kc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZXRlcm1pbmluZy1saXN0LW9mLWNvbW1hbmRzKSB3aWxsIGJlIHNob3duIHRvIGFmZmVjdGVkIHVzZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGVteWNvbW1hbmRzXG4gICAqL1xuICBkZWxldGVNeUNvbW1hbmRzKGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVNeUNvbW1hbmRzJywgeyBmb3JtIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB0aGUgY3VycmVudCBsaXN0IG9mIHRoZSBib3QncyBjb21tYW5kcyBmb3IgdGhlIGdpdmVuIHNjb3BlIGFuZCB1c2VyIGxhbmd1YWdlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQXJyYXkgb2YgW0JvdENvbW1hbmRdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYm90Y29tbWFuZCkgb24gc3VjY2Vzcy4gSWYgY29tbWFuZHMgYXJlbid0IHNldCwgYW4gZW1wdHkgbGlzdCBpcyByZXR1cm5lZC5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldG15Y29tbWFuZHNcbiAgICovXG4gIGdldE15Q29tbWFuZHMoZm9ybSA9IHt9KSB7XG4gICAgaWYgKGZvcm0uc2NvcGUpIHtcbiAgICAgIGZvcm0uc2NvcGUgPSBzdHJpbmdpZnkoZm9ybS5zY29wZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRNeUNvbW1hbmRzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGJvdCdzIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldG15bmFtZVxuICAgKi9cbiAgc2V0TXlOYW1lKGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRNeU5hbWUnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB0aGUgY3VycmVudCBib3QgbmFtZSBmb3IgdGhlIGdpdmVuIHVzZXIgbGFuZ3VhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBbQm90TmFtZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNib3RuYW1lKSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRteW5hbWVcbiAgICovXG4gIGdldE15TmFtZShmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0TXlOYW1lJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGJvdCdzIGRlc2NyaXB0aW9uLCB3aGljaCBpcyBzaG93biBpbiB0aGUgY2hhdCB3aXRoIHRoZSBib3QgaWYgdGhlIGNoYXQgaXMgZW1wdHkuXG4gICAqXG4gICAqIFJldHVybnMgVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRteWRlc2NyaXB0aW9uXG4gICAqL1xuICBzZXRNeURlc2NyaXB0aW9uKGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRNeURlc2NyaXB0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgYm90IGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gdXNlciBsYW5ndWFnZS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgW0JvdERlc2NyaXB0aW9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2JvdGRlc2NyaXB0aW9uKSBvbiBzdWNjZXNzLlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0bXlkZXNjcmlwdGlvblxuICAgKi9cbiAgZ2V0TXlEZXNjcmlwdGlvbihmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0TXlEZXNjcmlwdGlvbicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBib3QncyBzaG9ydCBkZXNjcmlwdGlvbiwgd2hpY2ggaXMgc2hvd24gb24gdGhlIGJvdCdzIHByb2ZpbGUgcGFnZVxuICAgKiBhbmQgaXMgc2VudCB0b2dldGhlciB3aXRoIHRoZSBsaW5rIHdoZW4gdXNlcnMgc2hhcmUgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0bXlzaG9ydGRlc2NyaXB0aW9uXG4gICAqL1xuICBzZXRNeVNob3J0RGVzY3JpcHRpb24oZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldE15U2hvcnREZXNjcmlwdGlvbicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBjdXJyZW50IGJvdCBzaG9ydCBkZXNjcmlwdGlvbiBmb3IgdGhlIGdpdmVuIHVzZXIgbGFuZ3VhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIFtCb3RTaG9ydERlc2NyaXB0aW9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2JvdHNob3J0ZGVzY3JpcHRpb24pIG9uIHN1Y2Nlc3MuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRteXNob3J0ZGVzY3JpcHRpb25cbiAgICovXG4gIGdldE15U2hvcnREZXNjcmlwdGlvbihmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0TXlTaG9ydERlc2NyaXB0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGJvdCdzIG1lbnUgYnV0dG9uIGluIGEgcHJpdmF0ZSBjaGF0LCBvciB0aGUgZGVmYXVsdCBtZW51IGJ1dHRvbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y2hhdG1lbnVidXR0b25cbiAgICovXG4gIHNldENoYXRNZW51QnV0dG9uKGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0TWVudUJ1dHRvbicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBib3QncyBtZW51IGJ1dHRvbiBpbiBhIHByaXZhdGUgY2hhdCwgb3IgdGhlIGRlZmF1bHQgbWVudSBidXR0b24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBbTWVudUJ1dHRvbl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZW51YnV0dG9uKSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0bWVudWJ1dHRvblxuICAgKi9cbiAgZ2V0Q2hhdE1lbnVCdXR0b24oZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldENoYXRNZW51QnV0dG9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGRlZmF1bHQgYWRtaW5pc3RyYXRvciByaWdodHMgcmVxdWVzdGVkIGJ5IHRoZSBib3Qgd2hlbiBpdCdzIGFkZGVkIGFzIGFuIGFkbWluaXN0cmF0b3IgdG8gZ3JvdXBzIG9yIGNoYW5uZWxzLlxuICAgKlxuICAgKiBUaGVzZSByaWdodHMgd2lsbCBiZSBzdWdnZXN0ZWQgdG8gdXNlcnMsIGJ1dCB0aGV5IGFyZSBhcmUgZnJlZSB0byBtb2RpZnkgdGhlIGxpc3QgYmVmb3JlIGFkZGluZyB0aGUgYm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0bWVudWJ1dHRvblxuICAgKi9cbiAgc2V0TXlEZWZhdWx0QWRtaW5pc3RyYXRvclJpZ2h0cyhmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0TXlEZWZhdWx0QWRtaW5pc3RyYXRvclJpZ2h0cycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBjdXJyZW50IGRlZmF1bHQgYWRtaW5pc3RyYXRvciByaWdodHMgb2YgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFtDaGF0QWRtaW5pc3RyYXRvclJpZ2h0c10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjaGF0YWRtaW5pc3RyYXRvcnJpZ2h0cykgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0bXlkZWZhdWx0YWRtaW5pc3RyYXRvcnJpZ2h0c1xuICAgKi9cbiAgZ2V0TXlEZWZhdWx0QWRtaW5pc3RyYXRvclJpZ2h0cyhmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0TXlEZWZhdWx0QWRtaW5pc3RyYXRvclJpZ2h0cycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCB0ZXh0IG9yIFtnYW1lXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dhbWVzKSBtZXNzYWdlcyBzZW50IGJ5IHRoZSBib3Qgb3IgdmlhIHRoZSBib3QgKGZvciBpbmxpbmUgYm90cykuXG4gICAqXG4gICAqIE5vdGU6IHRoYXQgKip5b3UgbXVzdCBwcm92aWRlIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCoqIGluIHlvdXIgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0ICBOZXcgdGV4dCBvZiB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnMgKHByb3ZpZGUgZWl0aGVyIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCBoZXJlKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBpZiB0aGUgZWRpdGVkIG1lc3NhZ2UgaXMgbm90IGFuIGlubGluZSBtZXNzYWdlLCB0aGUgZWRpdGVkIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkLCBvdGhlcndpc2UgVHJ1ZSBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdG1lc3NhZ2V0ZXh0XG4gICAqL1xuICBlZGl0TWVzc2FnZVRleHQodGV4dCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS50ZXh0ID0gdGV4dDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VUZXh0JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBlZGl0IGNhcHRpb25zIG9mIG1lc3NhZ2VzIHNlbnQgYnkgdGhlIGJvdCBvciB2aWEgdGhlIGJvdCAoZm9yIGlubGluZSBib3RzKS5cbiAgICpcbiAgICogTm90ZTogWW91ICoqbXVzdCBwcm92aWRlIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCoqIGluIHlvdXIgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBjYXB0aW9uICBOZXcgY2FwdGlvbiBvZiB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnMgKHByb3ZpZGUgZWl0aGVyIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCBoZXJlKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBpZiB0aGUgZWRpdGVkIG1lc3NhZ2UgaXMgbm90IGFuIGlubGluZSBtZXNzYWdlLCB0aGUgZWRpdGVkIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkLCBvdGhlcndpc2UgVHJ1ZSBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdG1lc3NhZ2VjYXB0aW9uXG4gICAqL1xuICBlZGl0TWVzc2FnZUNhcHRpb24oY2FwdGlvbiwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jYXB0aW9uID0gY2FwdGlvbjtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VDYXB0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBlZGl0IGFuaW1hdGlvbiwgYXVkaW8sIGRvY3VtZW50LCBwaG90bywgb3IgdmlkZW8gbWVzc2FnZXMuXG4gICAqXG4gICAqIElmIGEgbWVzc2FnZSBpcyBhIHBhcnQgb2YgYSBtZXNzYWdlIGFsYnVtLCB0aGVuIGl0IGNhbiBiZSBlZGl0ZWQgb25seSB0byBhIHBob3RvIG9yIGEgdmlkZW8uXG4gICAqXG4gICAqIE90aGVyd2lzZSwgbWVzc2FnZSB0eXBlIGNhbiBiZSBjaGFuZ2VkIGFyYml0cmFyaWx5LiBXaGVuIGlubGluZSBtZXNzYWdlIGlzIGVkaXRlZCwgbmV3IGZpbGUgY2FuJ3QgYmUgdXBsb2FkZWQuXG4gICAqIFVzZSBwcmV2aW91c2x5IHVwbG9hZGVkIGZpbGUgdmlhIGl0cyBmaWxlX2lkIG9yIHNwZWNpZnkgYSBVUkwuXG4gICAqXG4gICAqIE5vdGU6IFlvdSAqKm11c3QgcHJvdmlkZSBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3IgaW5saW5lX21lc3NhZ2VfaWQqKiBpbiB5b3VyIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gbWVkaWEgIEEgSlNPTi1zZXJpYWxpemVkIG9iamVjdCBmb3IgYSBuZXcgbWVkaWEgY29udGVudCBvZiB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnMgKHByb3ZpZGUgZWl0aGVyIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCBoZXJlKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBpZiB0aGUgZWRpdGVkIG1lc3NhZ2UgaXMgbm90IGFuIGlubGluZSBtZXNzYWdlLCB0aGUgZWRpdGVkIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkLCBvdGhlcndpc2UgVHJ1ZSBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdG1lc3NhZ2VtZWRpYVxuICAgKi9cbiAgZWRpdE1lc3NhZ2VNZWRpYShtZWRpYSwgZm9ybSA9IHt9KSB7XG4gICAgY29uc3QgcmVnZXhBdHRhY2ggPSAvYXR0YWNoOlxcL1xcLy4rLztcblxuICAgIGlmICh0eXBlb2YgbWVkaWEubWVkaWEgPT09ICdzdHJpbmcnICYmIHJlZ2V4QXR0YWNoLnRlc3QobWVkaWEubWVkaWEpKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBxczogZm9ybSxcbiAgICAgIH07XG5cbiAgICAgIG9wdHMuZm9ybURhdGEgPSB7fTtcblxuICAgICAgY29uc3QgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIG1lZGlhKTtcbiAgICAgIGRlbGV0ZSBwYXlsb2FkLm1lZGlhO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhdHRhY2hOYW1lID0gU3RyaW5nKDApO1xuICAgICAgICBjb25zdCBbZm9ybURhdGFdID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoXG4gICAgICAgICAgYXR0YWNoTmFtZSxcbiAgICAgICAgICBtZWRpYS5tZWRpYS5yZXBsYWNlKCdhdHRhY2g6Ly8nLCAnJyksXG4gICAgICAgICAgbWVkaWEuZmlsZU9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoZm9ybURhdGEpIHtcbiAgICAgICAgICBvcHRzLmZvcm1EYXRhW2F0dGFjaE5hbWVdID0gZm9ybURhdGFbYXR0YWNoTmFtZV07XG4gICAgICAgICAgcGF5bG9hZC5tZWRpYSA9IGBhdHRhY2g6Ly8ke2F0dGFjaE5hbWV9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkZhdGFsRXJyb3IoYEZhaWxlZCB0byBwcm9jZXNzIHRoZSByZXBsYWNlbWVudCBhY3Rpb24gZm9yIHlvdXIgJHttZWRpYS50eXBlfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuXG4gICAgICBvcHRzLnFzLm1lZGlhID0gc3RyaW5naWZ5KHBheWxvYWQpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VNZWRpYScsIG9wdHMpO1xuICAgIH1cblxuICAgIGZvcm0ubWVkaWEgPSBzdHJpbmdpZnkobWVkaWEpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRNZXNzYWdlTWVkaWEnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgb25seSB0aGUgcmVwbHkgbWFya3VwIG9mIG1lc3NhZ2VzIHNlbnQgYnkgdGhlIGJvdCBvciB2aWEgdGhlIGJvdCAoZm9yIGlubGluZSBib3RzKS5cbiAgICpcbiAgICogTm90ZTogWW91ICoqbXVzdCBwcm92aWRlIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCoqIGluIHlvdXIgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZXBseU1hcmt1cCAgQSBKU09OLXNlcmlhbGl6ZWQgb2JqZWN0IGZvciBhbiBpbmxpbmUga2V5Ym9hcmQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9ucyAocHJvdmlkZSBlaXRoZXIgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkIGhlcmUpXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBlZGl0ZWQgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBlZGl0ZWQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0bWVzc2FnZXRleHRcbiAgICovXG4gIGVkaXRNZXNzYWdlUmVwbHlNYXJrdXAocmVwbHlNYXJrdXAsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0ucmVwbHlfbWFya3VwID0gcmVwbHlNYXJrdXA7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRNZXNzYWdlUmVwbHlNYXJrdXAnLCB7IGZvcm0gfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc3RvcCBhIHBvbGwgd2hpY2ggd2FzIHNlbnQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGdyb3VwL2NoYW5uZWxcbiAgICogQHBhcmFtICB7TnVtYmVyfSBwb2xsSWQgSWRlbnRpZmllciBvZiB0aGUgb3JpZ2luYWwgbWVzc2FnZSB3aXRoIHRoZSBwb2xsXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc3RvcHBlZCBbUG9sbF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNwb2xsKSBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc3RvcHBvbGxcbiAgICovXG4gIHN0b3BQb2xsKGNoYXRJZCwgcG9sbElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX2lkID0gcG9sbElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzdG9wUG9sbCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBzdGF0aWMgLldFQlAsIFthbmltYXRlZF0oaHR0cHM6Ly90ZWxlZ3JhbS5vcmcvYmxvZy9hbmltYXRlZC1zdGlja2VycykgLlRHUyxcbiAgICogb3IgW3ZpZGVvXShodHRwczovL3RlbGVncmFtLm9yZy9ibG9nL3ZpZGVvLXN0aWNrZXJzLWJldHRlci1yZWFjdGlvbnMpIC5XRUJNIHN0aWNrZXJzLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBzdGlja2VyIEEgZmlsZSBwYXRoLCBTdHJlYW0gb3IgQnVmZmVyLlxuICAgKiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLiBTdGlja2VycyBhcmUgV2ViUCBmb3JtYXQgZmlsZXMuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHN0aWNrZXJcbiAgICovXG4gIHNlbmRTdGlja2VyKGNoYXRJZCwgc3RpY2tlciwgb3B0aW9ucyA9IHt9LCBmaWxlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfTtcbiAgICBvcHRzLnFzLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3N0aWNrZXInLCBzdGlja2VyLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzLnN0aWNrZXIgPSBzZW5kRGF0YVsxXTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRTdGlja2VyJywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBhIHN0aWNrZXIgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgc3RpY2tlciBzZXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGEgW1N0aWNrZXJTZXRdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc3RpY2tlcnNldCkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRzdGlja2Vyc2V0XG4gICAqL1xuICBnZXRTdGlja2VyU2V0KG5hbWUsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldFN0aWNrZXJTZXQnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dCBjdXN0b20gZW1vamkgc3RpY2tlcnMgYnkgdGhlaXIgaWRlbnRpZmllcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fSBjdXN0b21fZW1vamlfaWRzIExpc3Qgb2YgY3VzdG9tIGVtb2ppIGlkZW50aWZpZXJzLiBBdCBtb3N0IDIwMCBjdXN0b20gZW1vamkgaWRlbnRpZmllcnMgY2FuIGJlIHNwZWNpZmllZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEFycmF5IG9mIFtTdGlja2VyXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3N0aWNrZXIpIG9iamVjdHMuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjdXN0b21lbW9qaXN0aWNrZXJzXG4gICAqL1xuICBnZXRDdXN0b21FbW9qaVN0aWNrZXJzKGN1c3RvbUVtb2ppSWRzLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmN1c3RvbV9lbW9qaV9pZHMgPSBzdHJpbmdpZnkoY3VzdG9tRW1vamlJZHMpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRDdXN0b21FbW9qaVN0aWNrZXJzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byB1cGxvYWQgYSBmaWxlIHdpdGggYSBzdGlja2VyIGZvciBsYXRlciB1c2UgaW4gKmNyZWF0ZU5ld1N0aWNrZXJTZXQqIGFuZCAqYWRkU3RpY2tlclRvU2V0KiBtZXRob2RzIChjYW4gYmUgdXNlZCBtdWx0aXBsZVxuICAgKiB0aW1lcykuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkIFVzZXIgaWRlbnRpZmllciBvZiBzdGlja2VyIGZpbGUgb3duZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBzdGlja2VyIEEgZmlsZSBwYXRoIG9yIGEgU3RyZWFtIHdpdGggdGhlIHN0aWNrZXIgaW4gLldFQlAsIC5QTkcsIC5UR1MsIG9yIC5XRUJNIGZvcm1hdC4gQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0aWNrZXJGb3JtYXQgQWxsb3cgdmFsdWVzOiAgYHN0YXRpY2AsIGBhbmltYXRlZGAgb3IgYHZpZGVvYFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgYSBbRmlsZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNmaWxlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VwbG9hZHN0aWNrZXJmaWxlXG4gICAqL1xuICB1cGxvYWRTdGlja2VyRmlsZSh1c2VySWQsIHN0aWNrZXIsIHN0aWNrZXJGb3JtYXQgPSAnc3RhdGljJywgb3B0aW9ucyA9IHt9LCBmaWxlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zLFxuICAgIH07XG4gICAgb3B0cy5xcy51c2VyX2lkID0gdXNlcklkO1xuICAgIG9wdHMucXMuc3RpY2tlcl9mb3JtYXQgPSBzdGlja2VyRm9ybWF0O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3N0aWNrZXInLCBzdGlja2VyLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzLnN0aWNrZXIgPSBzZW5kRGF0YVsxXTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3VwbG9hZFN0aWNrZXJGaWxlJywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBuZXcgc3RpY2tlciBzZXQgb3duZWQgYnkgYSB1c2VyLlxuICAgKlxuICAgKiBUaGUgYm90IHdpbGwgYmUgYWJsZSB0byBlZGl0IHRoZSBjcmVhdGVkIHN0aWNrZXIgc2V0LlxuICAgKlxuICAgKiBZb3UgbXVzdCB1c2UgZXhhY3RseSBvbmUgb2YgdGhlIGZpZWxkcyAqcG5nX3N0aWNrZXIqLCAqdGdzX3N0aWNrZXIqLCBvciAqd2VibV9zdGlja2VyKlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCBVc2VyIGlkZW50aWZpZXIgb2YgY3JlYXRlZCBzdGlja2VyIHNldCBvd25lclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU2hvcnQgbmFtZSBvZiBzdGlja2VyIHNldCwgdG8gYmUgdXNlZCBpbiBgdC5tZS9hZGRzdGlja2Vycy9gIFVSTHMgKGUuZy4sICAgKlwiYW5pbWFsc1wiKikuIENhbiBjb250YWluIG9ubHkgZW5nbGlzaCBsZXR0ZXJzLCBkaWdpdHMgYW5kIHVuZGVyc2NvcmVzLlxuICAgKiAgTXVzdCBiZWdpbiB3aXRoIGEgbGV0dGVyLCBjYW4ndCBjb250YWluIGNvbnNlY3V0aXZlIHVuZGVyc2NvcmVzIGFuZCBtdXN0IGVuZCBpbiBgXCJfYnlfPGJvdF91c2VybmFtZT5cImAuIGA8Ym90X3VzZXJuYW1lPmAgaXMgY2FzZSBpbnNlbnNpdGl2ZS4gMS02NCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlIFN0aWNrZXIgc2V0IHRpdGxlLCAxLTY0IGNoYXJhY3RlcnNcbiAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBwbmdTdGlja2VyIFBuZyBpbWFnZSB3aXRoIHRoZSBzdGlja2VyLCBtdXN0IGJlIHVwIHRvIDUxMiBraWxvYnl0ZXMgaW4gc2l6ZSxcbiAgICogIGRpbWVuc2lvbnMgbXVzdCBub3QgZXhjZWVkIDUxMnB4LCBhbmQgZWl0aGVyIHdpZHRoIG9yIGhlaWdodCBtdXN0IGJlIGV4YWN0bHkgNTEycHguXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZW1vamlzIE9uZSBvciBtb3JlIGVtb2ppIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN0aWNrZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NyZWF0ZW5ld3N0aWNrZXJzZXRcbiAgICovXG4gIGNyZWF0ZU5ld1N0aWNrZXJTZXQodXNlcklkLCBuYW1lLCB0aXRsZSwgcG5nU3RpY2tlciwgZW1vamlzLCBvcHRpb25zID0ge30sIGZpbGVPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgcXM6IG9wdGlvbnMsXG4gICAgfTtcbiAgICBvcHRzLnFzLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgb3B0cy5xcy5uYW1lID0gbmFtZTtcbiAgICBvcHRzLnFzLnRpdGxlID0gdGl0bGU7XG4gICAgb3B0cy5xcy5lbW9qaXMgPSBlbW9qaXM7XG4gICAgb3B0cy5xcy5tYXNrX3Bvc2l0aW9uID0gc3RyaW5naWZ5KG9wdGlvbnMubWFza19wb3NpdGlvbik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3BuZ19zdGlja2VyJywgcG5nU3RpY2tlciwgZmlsZU9wdGlvbnMpO1xuICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgb3B0cy5xcy5wbmdfc3RpY2tlciA9IHNlbmREYXRhWzFdO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY3JlYXRlTmV3U3RpY2tlclNldCcsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBhZGQgYSBuZXcgc3RpY2tlciB0byBhIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAqXG4gICAqIFlvdSBtdXN0IHVzZSBleGFjdGx5IG9uZSBvZiB0aGUgZmllbGRzICpwbmdfc3RpY2tlciosICp0Z3Nfc3RpY2tlciosIG9yICp3ZWJtX3N0aWNrZXIqXG4gICAqXG4gICAqIEFuaW1hdGVkIHN0aWNrZXJzIGNhbiBiZSBhZGRlZCB0byBhbmltYXRlZCBzdGlja2VyIHNldHMgYW5kIG9ubHkgdG8gdGhlbVxuICAgKlxuICAgKiBOb3RlOlxuICAgKiAtIEVtb2ppIHN0aWNrZXIgc2V0cyBjYW4gaGF2ZSB1cCB0byAyMDAgc3RpY2tlclxuICAgKiAtIFN0YXRpYyBvciBBbmltYXRlZCBzdGlja2VyIHNldHMgY2FuIGhhdmUgdXAgdG8gMTIwIHN0aWNrZXJzXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkIFVzZXIgaWRlbnRpZmllciBvZiBzdGlja2VyIHNldCBvd25lclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU3RpY2tlciBzZXQgbmFtZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHN0aWNrZXIgUG5nIGltYWdlIHdpdGggdGhlIHN0aWNrZXIgKG11c3QgYmUgdXAgdG8gNTEyIGtpbG9ieXRlcyBpbiBzaXplLFxuICAgKiBkaW1lbnNpb25zIG11c3Qgbm90IGV4Y2VlZCA1MTJweCwgYW5kIGVpdGhlciB3aWR0aCBvciBoZWlnaHQgbXVzdCBiZSBleGFjdGx5IDUxMnB4LCBbVEdTIGFuaW1hdGlvbl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9zdGlja2VycyNhbmltYXRlZC1zdGlja2VyLXJlcXVpcmVtZW50cylcbiAgICogd2l0aCB0aGUgc3RpY2tlciBvciBbV0VCTSB2aWRlb10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9zdGlja2VycyN2aWRlby1zdGlja2VyLXJlcXVpcmVtZW50cykgd2l0aCB0aGUgc3RpY2tlci5cbiAgICogQHBhcmFtICB7U3RyaW5nfSBlbW9qaXMgT25lIG9yIG1vcmUgZW1vamkgY29ycmVzcG9uZGluZyB0byB0aGUgc3RpY2tlclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXJUeXBlIEFsbG93IHZhbHVlczogYHBuZ19zdGlja2VyYCwgYHRnc19zdGlja2VyYCwgb3IgYHdlYm1fc3RpY2tlcmAuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhZGRzdGlja2VydG9zZXRcbiAgICovXG4gIGFkZFN0aWNrZXJUb1NldCh1c2VySWQsIG5hbWUsIHN0aWNrZXIsIGVtb2ppcywgc3RpY2tlclR5cGUgPSAncG5nX3N0aWNrZXInLCBvcHRpb25zID0ge30sIGZpbGVPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgcXM6IG9wdGlvbnMsXG4gICAgfTtcbiAgICBvcHRzLnFzLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgb3B0cy5xcy5uYW1lID0gbmFtZTtcbiAgICBvcHRzLnFzLmVtb2ppcyA9IGVtb2ppcztcbiAgICBvcHRzLnFzLm1hc2tfcG9zaXRpb24gPSBzdHJpbmdpZnkob3B0aW9ucy5tYXNrX3Bvc2l0aW9uKTtcblxuICAgIGlmICh0eXBlb2Ygc3RpY2tlclR5cGUgIT09ICdzdHJpbmcnIHx8IFsncG5nX3N0aWNrZXInLCAndGdzX3N0aWNrZXInLCAnd2VibV9zdGlja2VyJ10uaW5kZXhPZihzdGlja2VyVHlwZSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdzdGlja2VyVHlwZSBtdXN0IGJlIGEgc3RyaW5nIGFuZCB0aGUgYWxsb3cgdHlwZXMgaXM6IHBuZ19zdGlja2VyLCB0Z3Nfc3RpY2tlciwgd2VibV9zdGlja2VyJykpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKHN0aWNrZXJUeXBlLCBzdGlja2VyLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzW3N0aWNrZXJUeXBlXSA9IHNlbmREYXRhWzFdO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYWRkU3RpY2tlclRvU2V0Jywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIG1vdmUgYSBzdGlja2VyIGluIGEgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdCB0byBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXIgRmlsZSBpZGVudGlmaWVyIG9mIHRoZSBzdGlja2VyXG4gICAqIEBwYXJhbSAge051bWJlcn0gcG9zaXRpb24gTmV3IHN0aWNrZXIgcG9zaXRpb24gaW4gdGhlIHNldCwgemVyby1iYXNlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRzdGlja2VycG9zaXRpb25pbnNldFxuICAgKi9cbiAgc2V0U3RpY2tlclBvc2l0aW9uSW5TZXQoc3RpY2tlciwgcG9zaXRpb24sIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uc3RpY2tlciA9IHN0aWNrZXI7XG4gICAgZm9ybS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRTdGlja2VyUG9zaXRpb25JblNldCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIGEgc3RpY2tlciBmcm9tIGEgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzdGlja2VyIEZpbGUgaWRlbnRpZmllciBvZiB0aGUgc3RpY2tlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGVzdGlja2VyZnJvbXNldFxuICAgKiBAdG9kbyBBZGQgdGVzdHMgZm9yIHRoaXMgbWV0aG9kIVxuICAgKi9cbiAgZGVsZXRlU3RpY2tlckZyb21TZXQoc3RpY2tlciwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5zdGlja2VyID0gc3RpY2tlcjtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlU3RpY2tlckZyb21TZXQnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlcGxhY2UgYW4gZXhpc3Rpbmcgc3RpY2tlciBpbiBhIHN0aWNrZXIgc2V0IHdpdGggYSBuZXcgb25lXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcl9pZCBVc2VyIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXIgc2V0IG93bmVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBTdGlja2VyIHNldCBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlciBGaWxlIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcmVwbGFjZXN0aWNrZXJpbnNldFxuICAgKiBAdG9kbyBBZGQgdGVzdHMgZm9yIHRoaXMgbWV0aG9kIVxuICAgKi9cbiAgcmVwbGFjZVN0aWNrZXJJblNldCh1c2VySWQsIG5hbWUsIG9sZFN0aWNrZXIsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgIGZvcm0ub2xkX3N0aWNrZXIgPSBvbGRTdGlja2VyO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVTdGlja2VyRnJvbVNldCcsIHsgZm9ybSB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGxpc3Qgb2YgZW1vamkgYXNzaWduZWQgdG8gYSByZWd1bGFyIG9yIGN1c3RvbSBlbW9qaSBzdGlja2VyLlxuICAgKlxuICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzdGlja2VyIEZpbGUgaWRlbnRpZmllciBvZiB0aGUgc3RpY2tlclxuICAgKiBAcGFyYW0geyBBcnJheSB9IGVtb2ppTGlzdCBBIEpTT04tc2VyaWFsaXplZCBsaXN0IG9mIDEtMjAgZW1vamkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdGlja2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHN0aWNrZXJlbW9qaWxpc3RcbiAgICovXG4gIHNldFN0aWNrZXJFbW9qaUxpc3Qoc3RpY2tlciwgZW1vamlMaXN0LCBmb3JtID0ge30pIHtcbiAgICBmb3JtLnN0aWNrZXIgPSBzdGlja2VyO1xuICAgIGZvcm0uZW1vamlfbGlzdCA9IHN0cmluZ2lmeShlbW9qaUxpc3QpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRTdGlja2VyRW1vamlMaXN0JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGxpc3Qgb2YgZW1vamkgYXNzaWduZWQgdG8gYSBgcmVndWxhcmAgb3IgYGN1c3RvbSBlbW9qaWAgc3RpY2tlci5cbiAgICpcbiAgICogVGhlIHN0aWNrZXIgbXVzdCBiZWxvbmcgdG8gYSBzdGlja2VyIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlciBGaWxlIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0c3RpY2tlcmtleXdvcmRzXG4gICAqL1xuICBzZXRTdGlja2VyS2V5d29yZHMoc3RpY2tlciwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5zdGlja2VyID0gc3RpY2tlcjtcbiAgICBpZiAoZm9ybS5rZXl3b3Jkcykge1xuICAgICAgZm9ybS5rZXl3b3JkcyA9IHN0cmluZ2lmeShmb3JtLmtleXdvcmRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJLZXl3b3JkcycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBbbWFzayBwb3NpdGlvbl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtYXNrcG9zaXRpb24pIG9mIGEgbWFzayBzdGlja2VyLlxuICAgKlxuICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzdGlja2VyIEZpbGUgaWRlbnRpZmllciBvZiB0aGUgc3RpY2tlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRzdGlja2VybWFza3Bvc2l0aW9uXG4gICAqL1xuICBzZXRTdGlja2VyTWFza1Bvc2l0aW9uKHN0aWNrZXIsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uc3RpY2tlciA9IHN0aWNrZXI7XG4gICAgaWYgKGZvcm0ubWFza19wb3NpdGlvbikge1xuICAgICAgZm9ybS5tYXNrX3Bvc2l0aW9uID0gc3RyaW5naWZ5KGZvcm0ubWFza19wb3NpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRTdGlja2VyTWFza1Bvc2l0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgdGhlIHRpdGxlIG9mIGEgY3JlYXRlZCBzdGlja2VyIHNldC5cbiAgICpcbiAgICogVGhlIHN0aWNrZXIgbXVzdCBiZWxvbmcgdG8gYSBzdGlja2VyIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBTdGlja2VyIHNldCBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGUgU3RpY2tlciBzZXQgdGl0bGUsIDEtNjQgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRzdGlja2Vyc2V0dGl0bGVcbiAgICovXG4gIHNldFN0aWNrZXJTZXRUaXRsZShuYW1lLCB0aXRsZSwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5uYW1lID0gbmFtZTtcbiAgICBmb3JtLnRpdGxlID0gdGl0bGU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJTZXRUaXRsZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gYWRkIGEgdGh1bWIgdG8gYSBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgKlxuICAgKiBBbmltYXRlZCB0aHVtYm5haWxzIGNhbiBiZSBzZXQgZm9yIGFuaW1hdGVkIHN0aWNrZXIgc2V0cyBvbmx5LiBWaWRlbyB0aHVtYm5haWxzIGNhbiBiZSBzZXQgb25seSBmb3IgdmlkZW8gc3RpY2tlciBzZXRzIG9ubHlcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgVXNlciBpZGVudGlmaWVyIG9mIHN0aWNrZXIgc2V0IG93bmVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBTdGlja2VyIHNldCBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gdGh1bWJuYWlsIEEgLldFQlAgb3IgLlBORyBpbWFnZSB3aXRoIHRoZSB0aHVtYm5haWwsXG4gICAqIG11c3QgYmUgdXAgdG8gMTI4IGtpbG9ieXRlcyBpbiBzaXplIGFuZCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgZXhhY3RseSAxMDBweCxcbiAgICogYSBUR1MgYW5pbWF0aW9uIHdpdGggdGhlIHRodW1ibmFpbCB1cCB0byAzMiBraWxvYnl0ZXMgaW4gc2l6ZSBvciBhIFdFQk0gdmlkZW8gd2l0aCB0aGUgdGh1bWJuYWlsIHVwIHRvIDMyIGtpbG9ieXRlcyBpbiBzaXplLlxuICAgKlxuICAgKiBQYXNzIGEgZmlsZV9pZCBhcyBhIFN0cmluZyB0byBzZW5kIGEgZmlsZSB0aGF0IGFscmVhZHkgZXhpc3RzIG9uIHRoZSBUZWxlZ3JhbSBzZXJ2ZXJzLCBwYXNzIGFuIEhUVFAgVVJMIGFzIGEgU3RyaW5nIGZvciBUZWxlZ3JhbVxuICAgKiB0byBnZXQgYSBmaWxlIGZyb20gdGhlIEludGVybmV0LCBvciB1cGxvYWQgYSBuZXcgb25lLiBBbmltYXRlZCBzdGlja2VyIHNldCB0aHVtYm5haWxzIGNhbid0IGJlIHVwbG9hZGVkIHZpYSBIVFRQIFVSTC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0c3RpY2tlcnNldHRodW1ibmFpbFxuICAgKi9cbiAgc2V0U3RpY2tlclNldFRodW1ibmFpbCh1c2VySWQsIG5hbWUsIHRodW1ibmFpbCwgb3B0aW9ucyA9IHt9LCBmaWxlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zLFxuICAgIH07XG4gICAgb3B0cy5xcy51c2VyX2lkID0gdXNlcklkO1xuICAgIG9wdHMucXMubmFtZSA9IG5hbWU7XG4gICAgb3B0cy5xcy5tYXNrX3Bvc2l0aW9uID0gc3RyaW5naWZ5KG9wdGlvbnMubWFza19wb3NpdGlvbik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3RodW1ibmFpbCcsIHRodW1ibmFpbCwgZmlsZU9wdGlvbnMpO1xuICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgb3B0cy5xcy50aHVtYm5haWwgPSBzZW5kRGF0YVsxXTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJTZXRUaHVtYm5haWwnLCBvcHRzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgdGhlIHRodW1ibmFpbCBvZiBhIGN1c3RvbSBlbW9qaSBzdGlja2VyIHNldC5cbiAgICpcbiAgICogVGhlIHN0aWNrZXIgbXVzdCBiZWxvbmcgdG8gYSBzdGlja2VyIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBTdGlja2VyIHNldCBuYW1lXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGN1c3RvbWVtb2ppc3RpY2tlcnNldHRodW1ibmFpbFxuICAgKi9cbiAgc2V0Q3VzdG9tRW1vamlTdGlja2VyU2V0VGh1bWJuYWlsKG5hbWUsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldEN1c3RvbUVtb2ppU3RpY2tlclNldFRodW1ibmFpbCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIGEgc3RpY2tlciBzZXQgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgKlxuICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFN0aWNrZXIgc2V0IG5hbWVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRlc3RpY2tlcnNldFxuICAgKi9cbiAgZGVsZXRlU3RpY2tlclNldChuYW1lLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVTdGlja2VyU2V0JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYW5zd2VycyB0byBhbiBpbmxpbmUgcXVlcnkuXG4gICAqXG4gICAqIE5vdGU6IE5vIG1vcmUgdGhhbiA1MCByZXN1bHRzIHBlciBxdWVyeSBhcmUgYWxsb3dlZC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpbmxpbmVRdWVyeUlkIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBxdWVyeVxuICAgKiBAcGFyYW0gIHtJbmxpbmVRdWVyeVJlc3VsdFtdfSByZXN1bHRzIEFuIGFycmF5IG9mIHJlc3VsdHMgZm9yIHRoZSBpbmxpbmUgcXVlcnlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIFRydWUgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Fuc3dlcmlubGluZXF1ZXJ5XG4gICAqL1xuICBhbnN3ZXJJbmxpbmVRdWVyeShpbmxpbmVRdWVyeUlkLCByZXN1bHRzLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmlubGluZV9xdWVyeV9pZCA9IGlubGluZVF1ZXJ5SWQ7XG4gICAgZm9ybS5yZXN1bHRzID0gc3RyaW5naWZ5KHJlc3VsdHMpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdhbnN3ZXJJbmxpbmVRdWVyeScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2V0IHRoZSByZXN1bHQgb2YgYW4gaW50ZXJhY3Rpb24gd2l0aCBhIFtXZWIgQXBwXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvd2ViYXBwcylcbiAgICogYW5kIHNlbmQgYSBjb3JyZXNwb25kaW5nIG1lc3NhZ2Ugb24gYmVoYWxmIG9mIHRoZSB1c2VyIHRvIHRoZSBjaGF0IGZyb20gd2hpY2ggdGhlIHF1ZXJ5IG9yaWdpbmF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gd2ViQXBwUXVlcnlJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHF1ZXJ5IHRvIGJlIGFuc3dlcmVkXG4gICAqIEBwYXJhbSAge0lubGluZVF1ZXJ5UmVzdWx0fSByZXN1bHQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBvbmUgcmVzdWx0IG9mIGFuIGlubGluZSBxdWVyeVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgYSBbU2VudFdlYkFwcE1lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VudHdlYmFwcG1lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYW5zd2Vyd2ViYXBwcXVlcnlcbiAgICovXG4gIGFuc3dlcldlYkFwcFF1ZXJ5KHdlYkFwcFF1ZXJ5SWQsIHJlc3VsdCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS53ZWJfYXBwX3F1ZXJ5X2lkID0gd2ViQXBwUXVlcnlJZDtcbiAgICBmb3JtLnJlc3VsdCA9IHN0cmluZ2lmeShyZXN1bHQpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdhbnN3ZXJXZWJBcHBRdWVyeScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBhbiBpbnZvaWNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0aXRsZSBQcm9kdWN0IG5hbWUsIDEtMzIgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFByb2R1Y3QgZGVzY3JpcHRpb24sIDEtMjU1IGNoYXJhY3RlcnNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYXlsb2FkIEJvdCBkZWZpbmVkIGludm9pY2UgcGF5bG9hZCwgMS0xMjggYnl0ZXMuIFRoaXMgd2lsbCBub3QgYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyLCB1c2UgZm9yIHlvdXIgaW50ZXJuYWwgcHJvY2Vzc2VzLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHByb3ZpZGVyVG9rZW4gUGF5bWVudHMgcHJvdmlkZXIgdG9rZW4sIG9idGFpbmVkIHZpYSBgQEJvdEZhdGhlcmBcbiAgICogQHBhcmFtICB7U3RyaW5nfSBjdXJyZW5jeSBUaHJlZS1sZXR0ZXIgSVNPIDQyMTcgY3VycmVuY3kgY29kZVxuICAgKiBAcGFyYW0gIHtBcnJheX0gcHJpY2VzIEJyZWFrZG93biBvZiBwcmljZXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kaW52b2ljZVxuICAgKi9cbiAgc2VuZEludm9pY2UoY2hhdElkLCB0aXRsZSwgZGVzY3JpcHRpb24sIHBheWxvYWQsIHByb3ZpZGVyVG9rZW4sIGN1cnJlbmN5LCBwcmljZXMsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnRpdGxlID0gdGl0bGU7XG4gICAgZm9ybS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIGZvcm0ucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgZm9ybS5wcm92aWRlcl90b2tlbiA9IHByb3ZpZGVyVG9rZW47XG4gICAgZm9ybS5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgIGZvcm0ucHJpY2VzID0gc3RyaW5naWZ5KHByaWNlcyk7XG4gICAgZm9ybS5wcm92aWRlcl9kYXRhID0gc3RyaW5naWZ5KGZvcm0ucHJvdmlkZXJfZGF0YSk7XG4gICAgaWYgKGZvcm0uc3VnZ2VzdGVkX3RpcF9hbW91bnRzKSB7XG4gICAgICBmb3JtLnN1Z2dlc3RlZF90aXBfYW1vdW50cyA9IHN0cmluZ2lmeShmb3JtLnN1Z2dlc3RlZF90aXBfYW1vdW50cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kSW52b2ljZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYSBsaW5rIGZvciBhbiBpbnZvaWNlLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlIFByb2R1Y3QgbmFtZSwgMS0zMiBjaGFyYWN0ZXJzXG4gICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFByb2R1Y3QgZGVzY3JpcHRpb24sIDEtMjU1IGNoYXJhY3RlcnNcbiAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZCBCb3QgZGVmaW5lZCBpbnZvaWNlIHBheWxvYWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gcHJvdmlkZXJUb2tlbiBQYXltZW50IHByb3ZpZGVyIHRva2VuXG4gICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbmN5IFRocmVlLWxldHRlciBJU08gNDIxNyBjdXJyZW5jeSBjb2RlXG4gICogQHBhcmFtIHtBcnJheX0gcHJpY2VzIEJyZWFrZG93biBvZiBwcmljZXNcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgY3JlYXRlZCBpbnZvaWNlIGxpbmsgYXMgU3RyaW5nIG9uIHN1Y2Nlc3MuXG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NyZWF0ZWludm9pY2VsaW5rXG4gICovXG4gIGNyZWF0ZUludm9pY2VMaW5rKHRpdGxlLCBkZXNjcmlwdGlvbiwgcGF5bG9hZCwgcHJvdmlkZXJUb2tlbiwgY3VycmVuY3ksIHByaWNlcywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS50aXRsZSA9IHRpdGxlO1xuICAgIGZvcm0uZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICBmb3JtLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIGZvcm0ucHJvdmlkZXJfdG9rZW4gPSBwcm92aWRlclRva2VuO1xuICAgIGZvcm0uY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgICBmb3JtLnByaWNlcyA9IHN0cmluZ2lmeShwcmljZXMpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjcmVhdGVJbnZvaWNlTGluaycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZXBseSB0byBzaGlwcGluZyBxdWVyaWVzLlxuICAqXG4gICogSWYgeW91IHNlbnQgYW4gaW52b2ljZSByZXF1ZXN0aW5nIGEgc2hpcHBpbmcgYWRkcmVzcyBhbmQgdGhlIHBhcmFtZXRlciBpc19mbGV4aWJsZSB3YXMgc3BlY2lmaWVkLFxuICAqIHRoZSBCb3QgQVBJIHdpbGwgc2VuZCBhbiBbVXBkYXRlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VwZGF0ZSkgd2l0aCBhIHNoaXBwaW5nX3F1ZXJ5IGZpZWxkIHRvIHRoZSBib3RcbiAgKlxuICAqIEBwYXJhbSAge1N0cmluZ30gc2hpcHBpbmdRdWVyeUlkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHF1ZXJ5IHRvIGJlIGFuc3dlcmVkXG4gICogQHBhcmFtICB7Qm9vbGVhbn0gb2sgU3BlY2lmeSBpZiBkZWxpdmVyeSBvZiB0aGUgcHJvZHVjdCBpcyBwb3NzaWJsZVxuICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIFRydWUgaXMgcmV0dXJuZWRcbiAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYW5zd2Vyc2hpcHBpbmdxdWVyeVxuICAqL1xuICBhbnN3ZXJTaGlwcGluZ1F1ZXJ5KHNoaXBwaW5nUXVlcnlJZCwgb2ssIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uc2hpcHBpbmdfcXVlcnlfaWQgPSBzaGlwcGluZ1F1ZXJ5SWQ7XG4gICAgZm9ybS5vayA9IG9rO1xuICAgIGZvcm0uc2hpcHBpbmdfb3B0aW9ucyA9IHN0cmluZ2lmeShmb3JtLnNoaXBwaW5nX29wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdhbnN3ZXJTaGlwcGluZ1F1ZXJ5JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZXNwb25kIHRvIHN1Y2ggcHJlLWNoZWNrb3V0IHF1ZXJpZXNcbiAgICpcbiAgICogT25jZSB0aGUgdXNlciBoYXMgY29uZmlybWVkIHRoZWlyIHBheW1lbnQgYW5kIHNoaXBwaW5nIGRldGFpbHMsIHRoZSBCb3QgQVBJIHNlbmRzIHRoZSBmaW5hbCBjb25maXJtYXRpb24gaW4gdGhlIGZvcm0gb2ZcbiAgICogYW4gW1VwZGF0ZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1cGRhdGUpIHdpdGggdGhlIGZpZWxkICpwcmVfY2hlY2tvdXRfcXVlcnkqLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhlIEJvdCBBUEkgbXVzdCByZWNlaXZlIGFuIGFuc3dlciB3aXRoaW4gMTAgc2Vjb25kcyBhZnRlciB0aGUgcHJlLWNoZWNrb3V0IHF1ZXJ5IHdhcyBzZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHByZUNoZWNrb3V0UXVlcnlJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBxdWVyeSB0byBiZSBhbnN3ZXJlZFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBvayBTcGVjaWZ5IGlmIGV2ZXJ5IG9yZGVyIGRldGFpbHMgYXJlIG9rXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBUcnVlIGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhbnN3ZXJwcmVjaGVja291dHF1ZXJ5XG4gICAqL1xuICBhbnN3ZXJQcmVDaGVja291dFF1ZXJ5KHByZUNoZWNrb3V0UXVlcnlJZCwgb2ssIGZvcm0gPSB7fSkge1xuICAgIGZvcm0ucHJlX2NoZWNrb3V0X3F1ZXJ5X2lkID0gcHJlQ2hlY2tvdXRRdWVyeUlkO1xuICAgIGZvcm0ub2sgPSBvaztcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYW5zd2VyUHJlQ2hlY2tvdXRRdWVyeScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBhIGdhbWUuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZ2FtZVNob3J0TmFtZSBuYW1lIG9mIHRoZSBnYW1lIHRvIGJlIHNlbnQuIFNldCB1cCB5b3VyIGdhbWVzIHZpYSBgQEJvdEZhdGhlcmAuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGdhbWVcbiAgICovXG4gIHNlbmRHYW1lKGNoYXRJZCwgZ2FtZVNob3J0TmFtZSwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0uZ2FtZV9zaG9ydF9uYW1lID0gZ2FtZVNob3J0TmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZEdhbWUnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCB0aGUgc2NvcmUgb2YgdGhlIHNwZWNpZmllZCB1c2VyIGluIGEgZ2FtZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAqIEBwYXJhbSAge051bWJlcn0gc2NvcmUgTmV3IHNjb3JlIHZhbHVlLCBtdXN0IGJlIG5vbi1uZWdhdGl2ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgaWYgdGhlIG1lc3NhZ2UgaXMgbm90IGFuIGlubGluZSBtZXNzYWdlLCB0aGUgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRnYW1lc2NvcmVcbiAgICovXG4gIHNldEdhbWVTY29yZSh1c2VySWQsIHNjb3JlLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgZm9ybS5zY29yZSA9IHNjb3JlO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRHYW1lU2NvcmUnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBkYXRhIGZvciBoaWdoIHNjb3JlIHRhYmxlcy5cbiAgICpcbiAgICogV2lsbCByZXR1cm4gdGhlIHNjb3JlIG9mIHRoZSBzcGVjaWZpZWQgdXNlciBhbmQgc2V2ZXJhbCBvZiB0aGVpciBuZWlnaGJvcnMgaW4gYSBnYW1lLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCByZXR1cm5zIGFuIEFycmF5IG9mIFtHYW1lSGlnaFNjb3JlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dhbWVoaWdoc2NvcmUpIG9iamVjdHNcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGdhbWVoaWdoc2NvcmVzXG4gICAqL1xuICBnZXRHYW1lSGlnaFNjb3Jlcyh1c2VySWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0R2FtZUhpZ2hTY29yZXMnLCB7IGZvcm0gfSk7XG4gIH1cblxuXG4gIC8qKlxuICogVXNlIHRoaXMgbWV0aG9kIHRvIGRlbGV0ZSBhIG1lc3NhZ2UsIGluY2x1ZGluZyBzZXJ2aWNlIG1lc3NhZ2VzLCB3aXRoIHRoZSBmb2xsb3dpbmcgbGltaXRhdGlvbnM6XG4gKiAtIEEgbWVzc2FnZSBjYW4gb25seSBiZSBkZWxldGVkIGlmIGl0IHdhcyBzZW50IGxlc3MgdGhhbiA0OCBob3VycyBhZ28uXG4gKiAtIEEgZGljZSBtZXNzYWdlIGNhbiBvbmx5IGJlIGRlbGV0ZWQgaWYgaXQgd2FzIHNlbnQgbW9yZSB0aGFuIDI0IGhvdXJzIGFnby5cbiAqIC0gQm90cyBjYW4gZGVsZXRlIG91dGdvaW5nIG1lc3NhZ2VzIGluIGdyb3VwcyBhbmQgc3VwZXJncm91cHMuXG4gKiAtIEJvdHMgY2FuIGRlbGV0ZSBpbmNvbWluZyBtZXNzYWdlcyBpbiBncm91cHMsIHN1cGVyZ3JvdXBzIGFuZCBjaGFubmVscy5cbiAqIC0gQm90cyBncmFudGVkIGBjYW5fcG9zdF9tZXNzYWdlc2AgcGVybWlzc2lvbnMgY2FuIGRlbGV0ZSBvdXRnb2luZyBtZXNzYWdlcyBpbiBjaGFubmVscy5cbiAqIC0gSWYgdGhlIGJvdCBpcyBhbiBhZG1pbmlzdHJhdG9yIG9mIGEgZ3JvdXAsIGl0IGNhbiBkZWxldGUgYW55IG1lc3NhZ2UgdGhlcmUuXG4gKiAtIElmIHRoZSBib3QgaGFzIGBjYW5fZGVsZXRlX21lc3NhZ2VzYCBwZXJtaXNzaW9uIGluIGEgc3VwZXJncm91cCwgaXQgY2FuIGRlbGV0ZSBhbnkgbWVzc2FnZSB0aGVyZS5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IEBjaGFubmVsdXNlcm5hbWUpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1lc3NhZ2VJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCBtZXNzYWdlXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZW1lc3NhZ2VcbiAqL1xuICBkZWxldGVNZXNzYWdlKGNoYXRJZCwgbWVzc2FnZUlkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX2lkID0gbWVzc2FnZUlkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVNZXNzYWdlJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgbXVsdGlwbGUgbWVzc2FnZXMgc2ltdWx0YW5lb3VzbHkuIElmIHNvbWUgb2YgdGhlIHNwZWNpZmllZCBtZXNzYWdlcyBjYW4ndCBiZSBmb3VuZCwgdGhleSBhcmUgc2tpcHBlZC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBAY2hhbm5lbHVzZXJuYW1lKVxuICAgKiBAcGFyYW0gIHtBcnJheTxOdW1iZXJ8U3RyaW5nPn0gbWVzc2FnZUlkcyAgSWRlbnRpZmllcnMgb2YgMS0xMDAgbWVzc2FnZXMgdG8gZGVsZXRlLiBTZWUgZGVsZXRlTWVzc2FnZSBmb3IgbGltaXRhdGlvbnMgb24gd2hpY2ggbWVzc2FnZXMgY2FuIGJlIGRlbGV0ZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Qm9vbGVhbj59IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRlbWVzc2FnZXNcbiAgICovXG4gIGRlbGV0ZU1lc3NhZ2VzKGNoYXRJZCwgbWVzc2FnZUlkcywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubWVzc2FnZV9pZHMgPSBzdHJpbmdpZnkobWVzc2FnZUlkcyk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZU1lc3NhZ2VzJywgeyBmb3JtIH0pO1xuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZWxlZ3JhbUJvdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/src/telegram.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/src/telegramPolling.js":
/*!*******************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/src/telegramPolling.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/src/errors.js\");\nconst debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nconst deprecate = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/node-telegram-bot-api/src/utils.js\").deprecate);\nconst ANOTHER_WEB_HOOK_USED = 409;\n\n\nclass TelegramBotPolling {\n  /**\n   * Handles polling against the Telegram servers.\n   * @param  {TelegramBot} bot\n   * @see https://core.telegram.org/bots/api#getting-updates\n   */\n  constructor(bot) {\n    this.bot = bot;\n    this.options = (typeof bot.options.polling === 'boolean') ? {} : bot.options.polling;\n    this.options.interval = (typeof this.options.interval === 'number') ? this.options.interval : 300;\n    this.options.params = (typeof this.options.params === 'object') ? this.options.params : {};\n    this.options.params.offset = (typeof this.options.params.offset === 'number') ? this.options.params.offset : 0;\n    this.options.params.timeout = (typeof this.options.params.timeout === 'number') ? this.options.params.timeout : 10;\n    if (typeof this.options.timeout === 'number') {\n      deprecate('`options.polling.timeout` is deprecated. Use `options.polling.params` instead.');\n      this.options.params.timeout = this.options.timeout;\n    }\n    this._lastUpdate = 0;\n    this._lastRequest = null;\n    this._abort = false;\n    this._pollingTimeout = null;\n  }\n\n  /**\n   * Start polling\n   * @param  {Object} [options]\n   * @param  {Object} [options.restart]\n   * @return {Promise}\n   */\n  start(options = {}) {\n    if (this._lastRequest) {\n      if (!options.restart) {\n        return Promise.resolve();\n      }\n      return this.stop({\n        cancel: true,\n        reason: 'Polling restart',\n      }).then(() => {\n        return this._polling();\n      });\n    }\n    return this._polling();\n  }\n\n  /**\n   * Stop polling\n   * @param  {Object} [options] Options\n   * @param  {Boolean} [options.cancel] Cancel current request\n   * @param  {String} [options.reason] Reason for stopping polling\n   * @return {Promise}\n   */\n  stop(options = {}) {\n    if (!this._lastRequest) {\n      return Promise.resolve();\n    }\n    const lastRequest = this._lastRequest;\n    this._lastRequest = null;\n    clearTimeout(this._pollingTimeout);\n    if (options.cancel) {\n      const reason = options.reason || 'Polling stop';\n      lastRequest.cancel(reason);\n      return Promise.resolve();\n    }\n    this._abort = true;\n    return lastRequest.finally(() => {\n      this._abort = false;\n    });\n  }\n\n  /**\n   * Return `true` if is polling. Otherwise, `false`.\n   */\n  isPolling() {\n    return !!this._lastRequest;\n  }\n\n  /**\n   * Handle error thrown during polling.\n   * @private\n   * @param  {Error} error\n   */\n  _error(error) {\n    if (!this.bot.listeners('polling_error').length) {\n      return console.error('error: [polling_error] %j', error); // eslint-disable-line no-console\n    }\n    return this.bot.emit('polling_error', error);\n  }\n\n  /**\n   * Invokes polling (with recursion!)\n   * @return {Promise} promise of the current request\n   * @private\n   */\n  _polling() {\n    this._lastRequest = this\n      ._getUpdates()\n      .then(updates => {\n        this._lastUpdate = Date.now();\n        debug('polling data %j', updates);\n        updates.forEach(update => {\n          this.options.params.offset = update.update_id + 1;\n          debug('updated offset: %s', this.options.params.offset);\n          try {\n            this.bot.processUpdate(update);\n          } catch (err) {\n            err._processing = true;\n            throw err;\n          }\n        });\n        return null;\n      })\n      .catch(err => {\n        debug('polling error: %s', err.message);\n        if (!err._processing) {\n          return this._error(err);\n        }\n        delete err._processing;\n        /*\n         * An error occured while processing the items,\n         * i.e. in `this.bot.processUpdate()` above.\n         * We need to mark the already-processed items\n         * to avoid fetching them again once the application\n         * is restarted, or moves to next polling interval\n         * (in cases where unhandled rejections do not terminate\n         * the process).\n         * See https://github.com/yagop/node-telegram-bot-api/issues/36#issuecomment-268532067\n         */\n        if (!this.bot.options.badRejection) {\n          return this._error(err);\n        }\n        const opts = {\n          offset: this.options.params.offset,\n          limit: 1,\n          timeout: 0,\n        };\n        return this.bot.getUpdates(opts).then(() => {\n          return this._error(err);\n        }).catch(requestErr => {\n          /*\n           * We have been unable to handle this error.\n           * We have to log this to stderr to ensure devops\n           * understands that they may receive already-processed items\n           * on app restart.\n           * We simply can not rescue this situation, emit \"error\"\n           * event, with the hope that the application exits.\n           */\n          /* eslint-disable no-console */\n          const bugUrl = 'https://github.com/yagop/node-telegram-bot-api/issues/36#issuecomment-268532067';\n          console.error('error: Internal handling of The Offset Infinite Loop failed');\n          console.error(`error: Due to error '${requestErr}'`);\n          console.error('error: You may receive already-processed updates on app restart');\n          console.error(`error: Please see ${bugUrl} for more information`);\n          /* eslint-enable no-console */\n          return this.bot.emit('error', new errors.FatalError(err));\n        });\n      })\n      .finally(() => {\n        if (this._abort) {\n          debug('Polling is aborted!');\n        } else {\n          debug('setTimeout for %s miliseconds', this.options.interval);\n          this._pollingTimeout = setTimeout(() => this._polling(), this.options.interval);\n        }\n      });\n    return this._lastRequest;\n  }\n\n  /**\n   * Unset current webhook. Used when we detect that a webhook has been set\n   * and we are trying to poll. Polling and WebHook are mutually exclusive.\n   * @see https://core.telegram.org/bots/api#getting-updates\n   * @private\n   */\n  _unsetWebHook() {\n    debug('unsetting webhook');\n    return this.bot._request('setWebHook');\n  }\n\n  /**\n   * Retrieve updates\n   */\n  _getUpdates() {\n    debug('polling with options: %j', this.options.params);\n    return this.bot.getUpdates(this.options.params)\n      .catch(err => {\n        if (err.response && err.response.statusCode === ANOTHER_WEB_HOOK_USED) {\n          return this._unsetWebHook().then(() => {\n            return this.bot.getUpdates(this.options.params);\n          });\n        }\n        throw err;\n      });\n  }\n}\n\nmodule.exports = TelegramBotPolling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL3NyYy90ZWxlZ3JhbVBvbGxpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLDBFQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx5RkFBTztBQUM3QixrQkFBa0IseUdBQTRCO0FBQzlDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG9saXN0LXdlYi8uL25vZGVfbW9kdWxlcy9ub2RlLXRlbGVncmFtLWJvdC1hcGkvc3JjL3RlbGVncmFtUG9sbGluZy5qcz8yYTYxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ25vZGUtdGVsZWdyYW0tYm90LWFwaScpO1xuY29uc3QgZGVwcmVjYXRlID0gcmVxdWlyZSgnLi91dGlscycpLmRlcHJlY2F0ZTtcbmNvbnN0IEFOT1RIRVJfV0VCX0hPT0tfVVNFRCA9IDQwOTtcblxuXG5jbGFzcyBUZWxlZ3JhbUJvdFBvbGxpbmcge1xuICAvKipcbiAgICogSGFuZGxlcyBwb2xsaW5nIGFnYWluc3QgdGhlIFRlbGVncmFtIHNlcnZlcnMuXG4gICAqIEBwYXJhbSAge1RlbGVncmFtQm90fSBib3RcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHRpbmctdXBkYXRlc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYm90KSB7XG4gICAgdGhpcy5ib3QgPSBib3Q7XG4gICAgdGhpcy5vcHRpb25zID0gKHR5cGVvZiBib3Qub3B0aW9ucy5wb2xsaW5nID09PSAnYm9vbGVhbicpID8ge30gOiBib3Qub3B0aW9ucy5wb2xsaW5nO1xuICAgIHRoaXMub3B0aW9ucy5pbnRlcnZhbCA9ICh0eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsID09PSAnbnVtYmVyJykgPyB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwgOiAzMDA7XG4gICAgdGhpcy5vcHRpb25zLnBhcmFtcyA9ICh0eXBlb2YgdGhpcy5vcHRpb25zLnBhcmFtcyA9PT0gJ29iamVjdCcpID8gdGhpcy5vcHRpb25zLnBhcmFtcyA6IHt9O1xuICAgIHRoaXMub3B0aW9ucy5wYXJhbXMub2Zmc2V0ID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMucGFyYW1zLm9mZnNldCA9PT0gJ251bWJlcicpID8gdGhpcy5vcHRpb25zLnBhcmFtcy5vZmZzZXQgOiAwO1xuICAgIHRoaXMub3B0aW9ucy5wYXJhbXMudGltZW91dCA9ICh0eXBlb2YgdGhpcy5vcHRpb25zLnBhcmFtcy50aW1lb3V0ID09PSAnbnVtYmVyJykgPyB0aGlzLm9wdGlvbnMucGFyYW1zLnRpbWVvdXQgOiAxMDtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgZGVwcmVjYXRlKCdgb3B0aW9ucy5wb2xsaW5nLnRpbWVvdXRgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgb3B0aW9ucy5wb2xsaW5nLnBhcmFtc2AgaW5zdGVhZC4nKTtcbiAgICAgIHRoaXMub3B0aW9ucy5wYXJhbXMudGltZW91dCA9IHRoaXMub3B0aW9ucy50aW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLl9sYXN0VXBkYXRlID0gMDtcbiAgICB0aGlzLl9sYXN0UmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5fYWJvcnQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2xsaW5nVGltZW91dCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcG9sbGluZ1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLnJlc3RhcnRdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzdGFydChvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5fbGFzdFJlcXVlc3QpIHtcbiAgICAgIGlmICghb3B0aW9ucy5yZXN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0b3Aoe1xuICAgICAgICBjYW5jZWw6IHRydWUsXG4gICAgICAgIHJlYXNvbjogJ1BvbGxpbmcgcmVzdGFydCcsXG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbGxpbmcoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9sbGluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgcG9sbGluZ1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmNhbmNlbF0gQ2FuY2VsIGN1cnJlbnQgcmVxdWVzdFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLnJlYXNvbl0gUmVhc29uIGZvciBzdG9wcGluZyBwb2xsaW5nXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzdG9wKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5fbGFzdFJlcXVlc3QpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdFJlcXVlc3QgPSB0aGlzLl9sYXN0UmVxdWVzdDtcbiAgICB0aGlzLl9sYXN0UmVxdWVzdCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3BvbGxpbmdUaW1lb3V0KTtcbiAgICBpZiAob3B0aW9ucy5jYW5jZWwpIHtcbiAgICAgIGNvbnN0IHJlYXNvbiA9IG9wdGlvbnMucmVhc29uIHx8ICdQb2xsaW5nIHN0b3AnO1xuICAgICAgbGFzdFJlcXVlc3QuY2FuY2VsKHJlYXNvbik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHRoaXMuX2Fib3J0ID0gdHJ1ZTtcbiAgICByZXR1cm4gbGFzdFJlcXVlc3QuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLl9hYm9ydCA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgdHJ1ZWAgaWYgaXMgcG9sbGluZy4gT3RoZXJ3aXNlLCBgZmFsc2VgLlxuICAgKi9cbiAgaXNQb2xsaW5nKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2xhc3RSZXF1ZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBlcnJvciB0aHJvd24gZHVyaW5nIHBvbGxpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge0Vycm9yfSBlcnJvclxuICAgKi9cbiAgX2Vycm9yKGVycm9yKSB7XG4gICAgaWYgKCF0aGlzLmJvdC5saXN0ZW5lcnMoJ3BvbGxpbmdfZXJyb3InKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdlcnJvcjogW3BvbGxpbmdfZXJyb3JdICVqJywgZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYm90LmVtaXQoJ3BvbGxpbmdfZXJyb3InLCBlcnJvcik7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlcyBwb2xsaW5nICh3aXRoIHJlY3Vyc2lvbiEpXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugb2YgdGhlIGN1cnJlbnQgcmVxdWVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BvbGxpbmcoKSB7XG4gICAgdGhpcy5fbGFzdFJlcXVlc3QgPSB0aGlzXG4gICAgICAuX2dldFVwZGF0ZXMoKVxuICAgICAgLnRoZW4odXBkYXRlcyA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICBkZWJ1ZygncG9sbGluZyBkYXRhICVqJywgdXBkYXRlcyk7XG4gICAgICAgIHVwZGF0ZXMuZm9yRWFjaCh1cGRhdGUgPT4ge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5wYXJhbXMub2Zmc2V0ID0gdXBkYXRlLnVwZGF0ZV9pZCArIDE7XG4gICAgICAgICAgZGVidWcoJ3VwZGF0ZWQgb2Zmc2V0OiAlcycsIHRoaXMub3B0aW9ucy5wYXJhbXMub2Zmc2V0KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5ib3QucHJvY2Vzc1VwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLl9wcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgZGVidWcoJ3BvbGxpbmcgZXJyb3I6ICVzJywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICBpZiAoIWVyci5fcHJvY2Vzc2luZykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBlcnIuX3Byb2Nlc3Npbmc7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEFuIGVycm9yIG9jY3VyZWQgd2hpbGUgcHJvY2Vzc2luZyB0aGUgaXRlbXMsXG4gICAgICAgICAqIGkuZS4gaW4gYHRoaXMuYm90LnByb2Nlc3NVcGRhdGUoKWAgYWJvdmUuXG4gICAgICAgICAqIFdlIG5lZWQgdG8gbWFyayB0aGUgYWxyZWFkeS1wcm9jZXNzZWQgaXRlbXNcbiAgICAgICAgICogdG8gYXZvaWQgZmV0Y2hpbmcgdGhlbSBhZ2FpbiBvbmNlIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICAgKiBpcyByZXN0YXJ0ZWQsIG9yIG1vdmVzIHRvIG5leHQgcG9sbGluZyBpbnRlcnZhbFxuICAgICAgICAgKiAoaW4gY2FzZXMgd2hlcmUgdW5oYW5kbGVkIHJlamVjdGlvbnMgZG8gbm90IHRlcm1pbmF0ZVxuICAgICAgICAgKiB0aGUgcHJvY2VzcykuXG4gICAgICAgICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2lzc3Vlcy8zNiNpc3N1ZWNvbW1lbnQtMjY4NTMyMDY3XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIXRoaXMuYm90Lm9wdGlvbnMuYmFkUmVqZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMub3B0aW9ucy5wYXJhbXMub2Zmc2V0LFxuICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgIHRpbWVvdXQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmJvdC5nZXRVcGRhdGVzKG9wdHMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9KS5jYXRjaChyZXF1ZXN0RXJyID0+IHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIFdlIGhhdmUgYmVlbiB1bmFibGUgdG8gaGFuZGxlIHRoaXMgZXJyb3IuXG4gICAgICAgICAgICogV2UgaGF2ZSB0byBsb2cgdGhpcyB0byBzdGRlcnIgdG8gZW5zdXJlIGRldm9wc1xuICAgICAgICAgICAqIHVuZGVyc3RhbmRzIHRoYXQgdGhleSBtYXkgcmVjZWl2ZSBhbHJlYWR5LXByb2Nlc3NlZCBpdGVtc1xuICAgICAgICAgICAqIG9uIGFwcCByZXN0YXJ0LlxuICAgICAgICAgICAqIFdlIHNpbXBseSBjYW4gbm90IHJlc2N1ZSB0aGlzIHNpdHVhdGlvbiwgZW1pdCBcImVycm9yXCJcbiAgICAgICAgICAgKiBldmVudCwgd2l0aCB0aGUgaG9wZSB0aGF0IHRoZSBhcHBsaWNhdGlvbiBleGl0cy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgY29uc3QgYnVnVXJsID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvaXNzdWVzLzM2I2lzc3VlY29tbWVudC0yNjg1MzIwNjcnO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiBJbnRlcm5hbCBoYW5kbGluZyBvZiBUaGUgT2Zmc2V0IEluZmluaXRlIExvb3AgZmFpbGVkJyk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgZXJyb3I6IER1ZSB0byBlcnJvciAnJHtyZXF1ZXN0RXJyfSdgKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdlcnJvcjogWW91IG1heSByZWNlaXZlIGFscmVhZHktcHJvY2Vzc2VkIHVwZGF0ZXMgb24gYXBwIHJlc3RhcnQnKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBlcnJvcjogUGxlYXNlIHNlZSAke2J1Z1VybH0gZm9yIG1vcmUgaW5mb3JtYXRpb25gKTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICByZXR1cm4gdGhpcy5ib3QuZW1pdCgnZXJyb3InLCBuZXcgZXJyb3JzLkZhdGFsRXJyb3IoZXJyKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2Fib3J0KSB7XG4gICAgICAgICAgZGVidWcoJ1BvbGxpbmcgaXMgYWJvcnRlZCEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1Zygnc2V0VGltZW91dCBmb3IgJXMgbWlsaXNlY29uZHMnLCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgICAgICAgIHRoaXMuX3BvbGxpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9wb2xsaW5nKCksIHRoaXMub3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9sYXN0UmVxdWVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnNldCBjdXJyZW50IHdlYmhvb2suIFVzZWQgd2hlbiB3ZSBkZXRlY3QgdGhhdCBhIHdlYmhvb2sgaGFzIGJlZW4gc2V0XG4gICAqIGFuZCB3ZSBhcmUgdHJ5aW5nIHRvIHBvbGwuIFBvbGxpbmcgYW5kIFdlYkhvb2sgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHRpbmctdXBkYXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Vuc2V0V2ViSG9vaygpIHtcbiAgICBkZWJ1ZygndW5zZXR0aW5nIHdlYmhvb2snKTtcbiAgICByZXR1cm4gdGhpcy5ib3QuX3JlcXVlc3QoJ3NldFdlYkhvb2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB1cGRhdGVzXG4gICAqL1xuICBfZ2V0VXBkYXRlcygpIHtcbiAgICBkZWJ1ZygncG9sbGluZyB3aXRoIG9wdGlvbnM6ICVqJywgdGhpcy5vcHRpb25zLnBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXMuYm90LmdldFVwZGF0ZXModGhpcy5vcHRpb25zLnBhcmFtcylcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXNDb2RlID09PSBBTk9USEVSX1dFQl9IT09LX1VTRUQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdW5zZXRXZWJIb29rKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3QuZ2V0VXBkYXRlcyh0aGlzLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlbGVncmFtQm90UG9sbGluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/src/telegramPolling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/src/telegramWebHook.js":
/*!*******************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/src/telegramWebHook.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/src/errors.js\");\nconst debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst bl = __webpack_require__(/*! bl */ \"(rsc)/./node_modules/bl/bl.js\");\n\nclass TelegramBotWebHook {\n  /**\n   * Sets up a webhook to receive updates\n   * @param  {TelegramBot} bot\n   * @see https://core.telegram.org/bots/api#getting-updates\n   */\n  constructor(bot) {\n    this.bot = bot;\n    this.options = (typeof bot.options.webHook === 'boolean') ? {} : bot.options.webHook;\n    this.options.host = this.options.host || '0.0.0.0';\n    this.options.port = this.options.port || 8443;\n    this.options.https = this.options.https || {};\n    this.options.healthEndpoint = this.options.healthEndpoint || '/healthz';\n    this._healthRegex = new RegExp(this.options.healthEndpoint);\n    this._webServer = null;\n    this._open = false;\n    this._requestListener = this._requestListener.bind(this);\n    this._parseBody = this._parseBody.bind(this);\n\n    if (this.options.key && this.options.cert) {\n      debug('HTTPS WebHook enabled (by key/cert)');\n      this.options.https.key = fs.readFileSync(this.options.key);\n      this.options.https.cert = fs.readFileSync(this.options.cert);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (this.options.pfx) {\n      debug('HTTPS WebHook enabled (by pfx)');\n      this.options.https.pfx = fs.readFileSync(this.options.pfx);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (Object.keys(this.options.https).length) {\n      debug('HTTPS WebHook enabled by (https)');\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else {\n      debug('HTTP WebHook enabled');\n      this._webServer = http.createServer(this._requestListener);\n    }\n  }\n\n  /**\n   * Open WebHook by listening on the port\n   * @return {Promise}\n   */\n  open() {\n    if (this.isOpen()) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      this._webServer.listen(this.options.port, this.options.host, () => {\n        debug('WebHook listening on port %s', this.options.port);\n        this._open = true;\n        return resolve();\n      });\n\n      this._webServer.once('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Close the webHook\n   * @return {Promise}\n   */\n  close() {\n    if (!this.isOpen()) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      this._webServer.close(error => {\n        if (error) return reject(error);\n        this._open = false;\n        return resolve();\n      });\n    });\n  }\n\n  /**\n   * Return `true` if server is listening. Otherwise, `false`.\n   */\n  isOpen() {\n    // NOTE: Since `http.Server.listening` was added in v5.7.0\n    // and we still need to support Node v4,\n    // we are going to fallback to 'this._open'.\n    // The following LOC would suffice for newer versions of Node.js\n    // return this._webServer.listening;\n    return this._open;\n  }\n\n  /**\n   * Handle error thrown during processing of webhook request.\n   * @private\n   * @param  {Error} error\n   */\n  _error(error) {\n    if (!this.bot.listeners('webhook_error').length) {\n      return console.error('error: [webhook_error] %j', error); // eslint-disable-line no-console\n    }\n    return this.bot.emit('webhook_error', error);\n  }\n\n  /**\n   * Handle request body by passing it to 'callback'\n   * @private\n   */\n  _parseBody(error, body) {\n    if (error) {\n      return this._error(new errors.FatalError(error));\n    }\n\n    let data;\n    try {\n      data = JSON.parse(body.toString());\n    } catch (parseError) {\n      return this._error(new errors.ParseError(parseError.message));\n    }\n\n    return this.bot.processUpdate(data);\n  }\n\n  /**\n   * Listener for 'request' event on server\n   * @private\n   * @see https://nodejs.org/docs/latest/api/http.html#http_http_createserver_requestlistener\n   * @see https://nodejs.org/docs/latest/api/https.html#https_https_createserver_options_requestlistener\n   */\n  _requestListener(req, res) {\n    debug('WebHook request URL: %s', req.url);\n    debug('WebHook request headers: %j', req.headers);\n\n    if (req.url.indexOf(this.bot.token) !== -1) {\n      if (req.method !== 'POST') {\n        debug('WebHook request isn\\'t a POST');\n        res.statusCode = 418; // I'm a teabot!\n        res.end();\n      } else {\n        req\n          .pipe(bl(this._parseBody))\n          .on('finish', () => res.end('OK'));\n      }\n    } else if (this._healthRegex.test(req.url)) {\n      debug('WebHook health check passed');\n      res.statusCode = 200;\n      res.end('OK');\n    } else {\n      debug('WebHook request unauthorized');\n      res.statusCode = 401;\n      res.end();\n    }\n  }\n}\n\nmodule.exports = TelegramBotWebHook;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL3NyYy90ZWxlZ3JhbVdlYkhvb2suanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLDBFQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx5RkFBTztBQUM3QixjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyx5Q0FBSTs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG9saXN0LXdlYi8uL25vZGVfbW9kdWxlcy9ub2RlLXRlbGVncmFtLWJvdC1hcGkvc3JjL3RlbGVncmFtV2ViSG9vay5qcz9jNmY0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ25vZGUtdGVsZWdyYW0tYm90LWFwaScpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IGJsID0gcmVxdWlyZSgnYmwnKTtcblxuY2xhc3MgVGVsZWdyYW1Cb3RXZWJIb29rIHtcbiAgLyoqXG4gICAqIFNldHMgdXAgYSB3ZWJob29rIHRvIHJlY2VpdmUgdXBkYXRlc1xuICAgKiBAcGFyYW0gIHtUZWxlZ3JhbUJvdH0gYm90XG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXR0aW5nLXVwZGF0ZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGJvdCkge1xuICAgIHRoaXMuYm90ID0gYm90O1xuICAgIHRoaXMub3B0aW9ucyA9ICh0eXBlb2YgYm90Lm9wdGlvbnMud2ViSG9vayA9PT0gJ2Jvb2xlYW4nKSA/IHt9IDogYm90Lm9wdGlvbnMud2ViSG9vaztcbiAgICB0aGlzLm9wdGlvbnMuaG9zdCA9IHRoaXMub3B0aW9ucy5ob3N0IHx8ICcwLjAuMC4wJztcbiAgICB0aGlzLm9wdGlvbnMucG9ydCA9IHRoaXMub3B0aW9ucy5wb3J0IHx8IDg0NDM7XG4gICAgdGhpcy5vcHRpb25zLmh0dHBzID0gdGhpcy5vcHRpb25zLmh0dHBzIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5oZWFsdGhFbmRwb2ludCA9IHRoaXMub3B0aW9ucy5oZWFsdGhFbmRwb2ludCB8fCAnL2hlYWx0aHonO1xuICAgIHRoaXMuX2hlYWx0aFJlZ2V4ID0gbmV3IFJlZ0V4cCh0aGlzLm9wdGlvbnMuaGVhbHRoRW5kcG9pbnQpO1xuICAgIHRoaXMuX3dlYlNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgIHRoaXMuX3JlcXVlc3RMaXN0ZW5lciA9IHRoaXMuX3JlcXVlc3RMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3BhcnNlQm9keSA9IHRoaXMuX3BhcnNlQm9keS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZXkgJiYgdGhpcy5vcHRpb25zLmNlcnQpIHtcbiAgICAgIGRlYnVnKCdIVFRQUyBXZWJIb29rIGVuYWJsZWQgKGJ5IGtleS9jZXJ0KScpO1xuICAgICAgdGhpcy5vcHRpb25zLmh0dHBzLmtleSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLm9wdGlvbnMua2V5KTtcbiAgICAgIHRoaXMub3B0aW9ucy5odHRwcy5jZXJ0ID0gZnMucmVhZEZpbGVTeW5jKHRoaXMub3B0aW9ucy5jZXJ0KTtcbiAgICAgIHRoaXMuX3dlYlNlcnZlciA9IGh0dHBzLmNyZWF0ZVNlcnZlcih0aGlzLm9wdGlvbnMuaHR0cHMsIHRoaXMuX3JlcXVlc3RMaXN0ZW5lcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMucGZ4KSB7XG4gICAgICBkZWJ1ZygnSFRUUFMgV2ViSG9vayBlbmFibGVkIChieSBwZngpJyk7XG4gICAgICB0aGlzLm9wdGlvbnMuaHR0cHMucGZ4ID0gZnMucmVhZEZpbGVTeW5jKHRoaXMub3B0aW9ucy5wZngpO1xuICAgICAgdGhpcy5fd2ViU2VydmVyID0gaHR0cHMuY3JlYXRlU2VydmVyKHRoaXMub3B0aW9ucy5odHRwcywgdGhpcy5fcmVxdWVzdExpc3RlbmVyKTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5odHRwcykubGVuZ3RoKSB7XG4gICAgICBkZWJ1ZygnSFRUUFMgV2ViSG9vayBlbmFibGVkIGJ5IChodHRwcyknKTtcbiAgICAgIHRoaXMuX3dlYlNlcnZlciA9IGh0dHBzLmNyZWF0ZVNlcnZlcih0aGlzLm9wdGlvbnMuaHR0cHMsIHRoaXMuX3JlcXVlc3RMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdIVFRQIFdlYkhvb2sgZW5hYmxlZCcpO1xuICAgICAgdGhpcy5fd2ViU2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIodGhpcy5fcmVxdWVzdExpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3BlbiBXZWJIb29rIGJ5IGxpc3RlbmluZyBvbiB0aGUgcG9ydFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgb3BlbigpIHtcbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fd2ViU2VydmVyLmxpc3Rlbih0aGlzLm9wdGlvbnMucG9ydCwgdGhpcy5vcHRpb25zLmhvc3QsICgpID0+IHtcbiAgICAgICAgZGVidWcoJ1dlYkhvb2sgbGlzdGVuaW5nIG9uIHBvcnQgJXMnLCB0aGlzLm9wdGlvbnMucG9ydCk7XG4gICAgICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3dlYlNlcnZlci5vbmNlKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgd2ViSG9va1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzT3BlbigpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl93ZWJTZXJ2ZXIuY2xvc2UoZXJyb3IgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYHRydWVgIGlmIHNlcnZlciBpcyBsaXN0ZW5pbmcuIE90aGVyd2lzZSwgYGZhbHNlYC5cbiAgICovXG4gIGlzT3BlbigpIHtcbiAgICAvLyBOT1RFOiBTaW5jZSBgaHR0cC5TZXJ2ZXIubGlzdGVuaW5nYCB3YXMgYWRkZWQgaW4gdjUuNy4wXG4gICAgLy8gYW5kIHdlIHN0aWxsIG5lZWQgdG8gc3VwcG9ydCBOb2RlIHY0LFxuICAgIC8vIHdlIGFyZSBnb2luZyB0byBmYWxsYmFjayB0byAndGhpcy5fb3BlbicuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBMT0Mgd291bGQgc3VmZmljZSBmb3IgbmV3ZXIgdmVyc2lvbnMgb2YgTm9kZS5qc1xuICAgIC8vIHJldHVybiB0aGlzLl93ZWJTZXJ2ZXIubGlzdGVuaW5nO1xuICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBlcnJvciB0aHJvd24gZHVyaW5nIHByb2Nlc3Npbmcgb2Ygd2ViaG9vayByZXF1ZXN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtFcnJvcn0gZXJyb3JcbiAgICovXG4gIF9lcnJvcihlcnJvcikge1xuICAgIGlmICghdGhpcy5ib3QubGlzdGVuZXJzKCd3ZWJob29rX2Vycm9yJykubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignZXJyb3I6IFt3ZWJob29rX2Vycm9yXSAlaicsIGVycm9yKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJvdC5lbWl0KCd3ZWJob29rX2Vycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSByZXF1ZXN0IGJvZHkgYnkgcGFzc2luZyBpdCB0byAnY2FsbGJhY2snXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGFyc2VCb2R5KGVycm9yLCBib2R5KSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IobmV3IGVycm9ycy5GYXRhbEVycm9yKGVycm9yKSk7XG4gICAgfVxuXG4gICAgbGV0IGRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGJvZHkudG9TdHJpbmcoKSk7XG4gICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKG5ldyBlcnJvcnMuUGFyc2VFcnJvcihwYXJzZUVycm9yLm1lc3NhZ2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ib3QucHJvY2Vzc1VwZGF0ZShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW5lciBmb3IgJ3JlcXVlc3QnIGV2ZW50IG9uIHNlcnZlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC9hcGkvaHR0cC5odG1sI2h0dHBfaHR0cF9jcmVhdGVzZXJ2ZXJfcmVxdWVzdGxpc3RlbmVyXG4gICAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9odHRwcy5odG1sI2h0dHBzX2h0dHBzX2NyZWF0ZXNlcnZlcl9vcHRpb25zX3JlcXVlc3RsaXN0ZW5lclxuICAgKi9cbiAgX3JlcXVlc3RMaXN0ZW5lcihyZXEsIHJlcykge1xuICAgIGRlYnVnKCdXZWJIb29rIHJlcXVlc3QgVVJMOiAlcycsIHJlcS51cmwpO1xuICAgIGRlYnVnKCdXZWJIb29rIHJlcXVlc3QgaGVhZGVyczogJWonLCByZXEuaGVhZGVycyk7XG5cbiAgICBpZiAocmVxLnVybC5pbmRleE9mKHRoaXMuYm90LnRva2VuKSAhPT0gLTEpIHtcbiAgICAgIGlmIChyZXEubWV0aG9kICE9PSAnUE9TVCcpIHtcbiAgICAgICAgZGVidWcoJ1dlYkhvb2sgcmVxdWVzdCBpc25cXCd0IGEgUE9TVCcpO1xuICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQxODsgLy8gSSdtIGEgdGVhYm90IVxuICAgICAgICByZXMuZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXFcbiAgICAgICAgICAucGlwZShibCh0aGlzLl9wYXJzZUJvZHkpKVxuICAgICAgICAgIC5vbignZmluaXNoJywgKCkgPT4gcmVzLmVuZCgnT0snKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9oZWFsdGhSZWdleC50ZXN0KHJlcS51cmwpKSB7XG4gICAgICBkZWJ1ZygnV2ViSG9vayBoZWFsdGggY2hlY2sgcGFzc2VkJyk7XG4gICAgICByZXMuc3RhdHVzQ29kZSA9IDIwMDtcbiAgICAgIHJlcy5lbmQoJ09LJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdXZWJIb29rIHJlcXVlc3QgdW5hdXRob3JpemVkJyk7XG4gICAgICByZXMuc3RhdHVzQ29kZSA9IDQwMTtcbiAgICAgIHJlcy5lbmQoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZWxlZ3JhbUJvdFdlYkhvb2s7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/src/telegramWebHook.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/src/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/src/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! util */ \"util\");\n// Native deprecation warning\nexports.deprecate = (msg) => util.deprecate(() => { }, msg, 'node-telegram-bot-api')();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0I7QUFDQSxpQkFBaUIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kb2xpc3Qtd2ViLy4vbm9kZV9tb2R1bGVzL25vZGUtdGVsZWdyYW0tYm90LWFwaS9zcmMvdXRpbHMuanM/NmZlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuLy8gTmF0aXZlIGRlcHJlY2F0aW9uIHdhcm5pbmdcbmV4cG9ydHMuZGVwcmVjYXRlID0gKG1zZykgPT4gdXRpbC5kZXByZWNhdGUoKCkgPT4geyB9LCBtc2csICdub2RlLXRlbGVncmFtLWJvdC1hcGknKSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/src/utils.js\n");

/***/ })

};
;